---
layout: default
title: spna106a
nav_order: 3
parent: TMS570 Startup
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p><i>Application Report</i></p>
<p><i>SPNA106A</i>–<i>January 2012</i></p>
<p><i><b>Initialization of Hercules</b></i>™<i><b> ARM</b></i></p>
<p>®</p>
<p><i><b>Cortex</b></i>™<i><b>-R4F</b></i></p>
<p><i><b>Microcontrollers</b></i></p>
<p><i>Sunil</i></p>
<p><i>Oak</i></p>
<p>........................................................................................................................................</p>
<p><b>ABSTRACT</b></p>
<p>This application report</p>
<p>provides a brief</p>
<p>overview and initialization procedure of</p>
<p>the TMS570LS31x series</p>
<p>and the RM4x series of microcontrollers in the Hercules family. &quot;Hercules MCU&quot; will</p>
<p>be used henceforth in</p>
<p>this document to refer to any part in these series of microcontrollers.</p>
<p>The document also shows code fragments from source files that are generated using the HALCoGen tool.</p>
<p>All</p>
<p>code constructs used in this document are defined in header files also generated by the same utility.</p>
<p>Project</p>
<p>collateral</p>
<p>and source code discussed in this application report</p>
<p>can be downloaded from the</p>
<p>following URL: http://www.ti.com/lit/zip/spna106.</p>
<p><b>Contents</b></p>
<p>1</p>
<p>Block Diagram</p>
<p>...............................................................................................................</p>
<p>2</p>
<p>2</p>
<p>Standard Initialization Sequence for Hercules Microcontrollers</p>
<p>......................................................</p>
<p>3</p>
<p>3</p>
<p>References</p>
<p>.................................................................................................................</p>
<p>15</p>
<p><b>List of Figures</b></p>
<p>1</p>
<p>Device Block Diagram</p>
<p>......................................................................................................</p>
<p>2</p>
<p>2</p>
<p>Color Legend for Block Diagram</p>
<p>..........................................................................................</p>
<p>2</p>
<p>3</p>
<p>FMPLL Block Diagram</p>
<p>.....................................................................................................</p>
<p>6</p>
<p>4</p>
<p>VIM Interrupt Address Memory Map</p>
<p>....................................................................................</p>
<p>14</p>
<p><b>List of Tables</b></p>
<p>1</p>
<p>Clock Sources on Hercules Microcontrollers</p>
<p>............................................................................</p>
<p>7</p>
<p>2</p>
<p>Clock Domains on Hercules Microcontrollers</p>
<p>..........................................................................</p>
<p>10</p>
<p>Hercules is a trademark of Texas Instruments.</p>
<p>Cortex is a trademark of ARM Limited.</p>
<p>ARM is a registered trademark of ARM Limited.</p>
<p>All</p>
<p>other trademarks are the property of their respective owners.</p>
<p>1</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>3M</p>
<p>Flash</p>
<p>with</p>
<p>ECC</p>
<p>64K</p>
<p>64K</p>
<p>64K</p>
<p>64K</p>
<p>256K</p>
<p>RAM</p>
<p>with</p>
<p>ECC</p>
<p>ETM-R4</p>
<p>(CPU Trace)</p>
<p>Dual Cortex-R4F</p>
<p>CPUs in Lockstep</p>
<p>RTP</p>
<p>(RAM Trace)</p>
<p>DMA</p>
<p>POM</p>
<p>DMM</p>
<p>HTU1</p>
<p>FTU</p>
<p>HTU2</p>
<p>EMAC</p>
<p>Switched Centrol Resource</p>
<p>64 KB Flash</p>
<p>for EEPROM</p>
<p>Emulation</p>
<p>with ECC</p>
<p>CRC</p>
<p>EMAC</p>
<p>EMIF</p>
<p>Slave</p>
<p>Switched Central Resource</p>
<p>Peripheral Central Resource Bridge</p>
<p>Switched Centrol Resource</p>
<p>Switched Centrol Resource</p>
<p>Main Cross Bar: Arbitration and :Prioritization Control</p>
<p>MibADC1</p>
<p>MibADC2</p>
<p>DCAN1</p>
<p>DCAN2</p>
<p>DCAN3</p>
<p>SPI2</p>
<p>SPI4</p>
<p>FlexRay</p>
<p>GIO</p>
<p>N2HET2</p>
<p>N2HET1</p>
<p>I2C</p>
<p>SCI</p>
<p>LIN</p>
<p>MibSPIx</p>
<p>Core/RAM</p>
<p>Core</p>
<p>RAM</p>
<p>#1</p>
<p>#2</p>
<p>#1</p>
<p>#3</p>
<p>#2</p>
<p>#4</p>
<p>#3</p>
<p>#5</p>
<p>always on</p>
<p><i>Block Diagram</i></p>
<p>www.ti.com</p>
<p><b>1</b></p>
<p><b>Block Diagram</b></p>
<p>Section 1 shows a high-level</p>
<p>block diagram of the superset TMS570LS31x microcontroller. For the actual</p>
<p>block diagram relevant for any derivative of the TMS570LS series or for the RM4x series of</p>
<p>microcontrollers, see the device-specific data sheet.</p>
<p><b>Figure 1. Device Block Diagram</b></p>
<p>The block diagram includes a color-coded representation of the individual</p>
<p>core-power domains</p>
<p>implemented on the microcontroller (see Figure 2). These power domains can be individually turned ON or</p>
<p>OFF during initialization as per the application requirements.</p>
<p><b>Figure 2. Color Legend for Block Diagram</b></p>
<p>2</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p>SPNA106A– January 2012</p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>www.ti.com</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p><b>2</b></p>
<p><b>Standard Initialization Sequence for Hercules Microcontrollers</b></p>
<p>A basic sequence for initialization and configuration of the key features on a Hercules MCU is summarized</p>
<p>below and many steps are detailed in the following sections. The source code example accompanying this</p>
<p>application report demonstrates many of the suggested steps. Some parts of the initialization sequence</p>
<p>are not mandatory. Applications that are non-safety-critical</p>
<p>can choose to not use the error correction</p>
<p>coding (ECC) feature for Flash and RAM accesses, for example. Each application must also have its</p>
<p>specific exception handling scheme: reset handler, abort handler, etc. The code generated using</p>
<p>HALCoGen includes template handling routines for each exception. These routines need to be modified as</p>
<p>required by the application.</p>
<p>1.</p>
<p>Enable the floating-point unit (FPU) inside the Cortex-R4F CPU (Section 2.1).</p>
<p>2.</p>
<p>Initialize the CPU registers and FPU registers, including stack pointers (Section 2.2).</p>
<p>3.</p>
<p>Enable the flash interface module's response to an ECC error indicated by the CPU on accesses to</p>
<p>flash (Section 2.3).</p>
<p>4.</p>
<p>Enable the CPU's Event Bus export mechanism (Section 2.4).</p>
<p>5.</p>
<p>Enable the CPU's Single-Error-Correction Double-Error-Detection (SECDED) logic for accesses to</p>
<p>Flash memory (CPU's ATCM interface) (Section 2.5).</p>
<p>6.</p>
<p>Handle the cause of reset to determine whether or not to continue with the start-up sequence</p>
<p>(Section 2.6)</p>
<p>7.</p>
<p>Check if any ESM group3 error was indicated during power-up. If any ESM group3 error occurred</p>
<p>during the power-up, it is not safe to continue code execution and the microcontroller initialization</p>
<p>process can be stopped at this point. The subsequent steps in this sequence assume that there was</p>
<p>no ESM group3 error during power-up.</p>
<p>8.</p>
<p>Configure PLL control</p>
<p>registers with the largest value for the last-stage of the dividers (R-dividers)</p>
<p>(Section 2.7).</p>
<p>9.</p>
<p>Enable the Phased-Locked Loops (PLLs) (Section 2.8).</p>
<p>10. Run the eFuse controller start-up checks and start the self-test on the eFuse controller SECDED logic</p>
<p>(Section 2.9).</p>
<p>11. Release the peripherals from reset and enable clocks to all</p>
<p>peripherals (Section 2.10).</p>
<p>12. Set up the device-level</p>
<p>multiplexing options as well</p>
<p>as the input/output (I/O) multiplexing.</p>
<p>13. Wait for the eFuse controller ECC logic self-test to complete and check the results.</p>
<p>14. Set up Flash module for the required wait states and pipelined mode (Section 2.11).</p>
<p>15. Set up Flash bank and pump power modes (Section 2.12).</p>
<p>16. Trim the LPO (Section 2.13).</p>
<p>17. Run the self-test on the SECDED logic embedded inside the Flash module (Section 2.14).</p>
<p>18. Wait for main PLL output to become valid.</p>
<p>19. Map the device clock domains to the desired clock sources (Section 2.15).</p>
<p>20. Reduce the values of the R-dividers in steps to attain the target PLL output frequency for both PLL1</p>
<p>and PLL2.</p>
<p>21. Run a diagnostic check on the CPU self-test controller (Section 2.16). A CPU reset is asserted upon</p>
<p>completion of the CPU self-test. Therefore, the initialization steps leading up to the reset handler will</p>
<p>be repeated.</p>
<p>22. Run the built-in self-test for the CPU (LBIST) (Section 2.17). A CPU reset is asserted upon completion</p>
<p>of the CPU self-test. Therefore, the initialization steps leading up to the reset handler will</p>
<p>be repeated.</p>
<p>23. Run a diagnostic check on the CPU compare module (CCM-R4F) (Section 2.18).</p>
<p>24. Run a diagnostic check on the memory self-test controller (Section 2.19).</p>
<p>25. Start a self-test on the CPU RAM using the programmable built-in self-test (PBIST) controller and wait</p>
<p>for this self-test to complete and pass (Section 2.20).</p>
<p>26. Initialize the CPU RAM using the system module hardware initialization mechanism so that the ECC</p>
<p>region for the CPU RAM is also initialized (Section 2.21).</p>
<p>27. Enable the CPU's Single-Error-Correction Double-Error-Detection (SECDED) logic for accesses to</p>
<p>CPU RAM memory (CPU's B0TCM and B1TCM interfaces) (Section 2.22).</p>
<p>3</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p>www.ti.com</p>
<p>28. Start a self-test on all</p>
<p>on-chip dual-port SRAMs using the PBIST controller (Section 2.23).</p>
<p>29. Run the self-test on the CPU's SECDED logic for accesses to main data RAM (B0TCM and B1TCM)</p>
<p>(Section 2.24).</p>
<p>30. Run the self-test on the CPU's SECDED logic for accesses to the main Flash memory (ATCM)</p>
<p>(Section 2.25).</p>
<p>31. Wait for self-test to complete and pass on all</p>
<p>on-chip dual-port SRAMs.</p>
<p>32. Start a self-test on all</p>
<p>on-chip single-port SRAMs excluding the CPU RAM using the PBIST controller</p>
<p>(Section 2.26).</p>
<p>33. Wait for self-test to complete and pass on all</p>
<p>on-chip single-port SRAMs.</p>
<p>34. Start auto-initialization for all</p>
<p>other on-chip SRAMs (Section 2.27).</p>
<p>35. Check if the auto-initialization process for all</p>
<p>RAMs is completed; wait here if it has not completed.</p>
<p>36. Check the parity error detection mechanism for all</p>
<p>peripheral</p>
<p>memories (Section 2.28).</p>
<p>37. Enable the CPU’s dedicated vectored interrupt controller (VIC) port (Section 2.29).</p>
<p>38. Program all</p>
<p>interrupt service routine addresses in the vectored interrupt manager (VIM) memory</p>
<p>(Section 2.30).</p>
<p>39. Configure IRQ / FIQ interrupt priorities for all</p>
<p>interrupt channels (Section 2.30.1).</p>
<p>40. Enable the desired interrupts (IRQ and/or FIQ) inside the CPU (Section 2.31).</p>
<p>41. Enable the desired interrupts in the VIM control</p>
<p>registers (Section 2.30.2).</p>
<p>42. Set up the application responses to inputs to the error signaling module (ESM) (Section 2.32).</p>
<p>43. Initialize copy table, global</p>
<p>variables, and constructors (Section 2.33).</p>
<p>44. Verify that the dual-clock-comparator (DCC) module can actually detect and flag a frequency error.</p>
<p>45. Configure the DCC module to continuously monitor the PLL output.</p>
<p>46. Verify that a memory protection unit (MPU) violation for all</p>
<p>bus masters is flagged as an error to the</p>
<p>ESM.</p>
<p>47. Run a background check on entire Flash using CRC and DMA.</p>
<p>48. Run the offset error calibration routine for the ADC.</p>
<p>49. Run a self-test on the analog-to-digital</p>
<p>converter (ADC) analog input channels.</p>
<p>50. Check I/O loop-back for all</p>
<p>peripherals.</p>
<p>51. Set up the MPU for the bus masters.</p>
<p>52. Set up the digital</p>
<p>windowed watchdog (DWWD) module service window size and the module response</p>
<p>on a violation (reset or NMI).</p>
<p>53. Configure the N2HET1-to-N2HET2 monitoring functionality.</p>
<p>54. Configure desired access permissions for peripherals using the Peripheral</p>
<p>Central</p>
<p>Resource (PCR)</p>
<p>controller registers.</p>
<p>55. Configure external</p>
<p>safety companion, e.g., TI TPS6538x, for online diagnostic operation.</p>
<p>56. Set up the real-time interrupt (RTI) module for generating periodic interrupts as required by the</p>
<p>application.</p>
<p>57. Call</p>
<p>the main application (Section 2.35).</p>
<p>4</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p>SPNA106A– January 2012</p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>www.ti.com</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p><i><b>2.1</b></i></p>
<p><i><b>Enable Floating-Point Coprocessor (FPU)</b></i></p>
<p>The floating-point coprocessor is disabled upon a CPU reset and must be enabled if the application</p>
<p>requires floating-point calculations. If a floating-point instruction is executed with the FPU disabled, an</p>
<p>undefined instruction exception is generated.</p>
<p><i><b>2.2</b></i></p>
<p><i><b>Initialize Cortex-R4F Registers</b></i></p>
<p>The Hercules series of microcontrollers include dual</p>
<p>Cortex-R4F CPUs running in a lock-step operation</p>
<p>mode. A core compare module (CCM-R4) compares the output signals from each R4F CPU. Any</p>
<p>difference in the two CPUs’</p>
<p>outputs is flagged as a fault of a high-severity level. The CPU internal</p>
<p>registers are not guaranteed to power up in the same state for both the CPUs. The CPU pushes the</p>
<p>internal</p>
<p>registers on to the stack on a function call, which could lead to the detection of a core compare</p>
<p>error. Therefore, the CPU internal</p>
<p>core registers need to be initialized to a predefined state before any</p>
<p>function call</p>
<p>is made.</p>
<p>The CPU’s call-return stack consists of a 4-entry circular buffer. When the CPU pre-fetch unit (PFU)</p>
<p>detects a taken procedure call</p>
<p>instruction, the PFU pushes the return address onto the call-return stack.</p>
<p>The instructions that the PFU recognizes as procedure calls are, in both the ARM and Thumb instruction</p>
<p>sets:</p>
<p>→ BL immediate</p>
<p>→ BLX immediate</p>
<p>→ BLX Rm</p>
<p>When the return stack detects a taken return instruction, the PFU issues an instruction fetch from the</p>
<p>location at the top of the return stack, and pops the return stack. The instructions that the PFU recognizes</p>
<p>as procedure returns are, in both the ARM and Thumb instruction sets:</p>
<p>→ LDMIA Rn{!}, {..,pc}</p>
<p>→ POP {..,pc}</p>
<p>→ LDMIB Rn{!}, {..,pc}</p>
<p>→ LDMDA Rn{!}, {..,pc}</p>
<p>→ LDMDB Rn{!}, {..,pc}</p>
<p>→ LDR pc, [sp], #4</p>
<p>→ BX Rm</p>
<p><i><b>2.3</b></i></p>
<p><i><b>Enable Response to ECC Errors in Flash Interface Module</b></i></p>
<p>The Flash module has a Flash Error Detection and Correction Control</p>
<p>Register 1 (FEDACCTRL1) at</p>
<p>address 0xFFF87008. This register controls the ECC functionality implemented inside the Flash module,</p>
<p>including support for the SECDED logic inside the Cortex-R4F CPU. The bits 3–0 of this register make up</p>
<p>the EDACEN field. EDACEN is configured to 0x5 by default. The application must configure EDACEN to</p>
<p>0xA in order to enable the flash module's support for the CPU's SECDED logic.</p>
<p><i><b>2.4</b></i></p>
<p><i><b>Enable the Cortex-R4F CPU</b></i>’<i><b>s Event Signaling Mechanism</b></i></p>
<p>The Cortex-R4F CPU has a dedicated event bus that is used to indicate that an event had occurred. This</p>
<p>event signaling is disabled upon reset and must be enabled. The Flash module and the RAM module</p>
<p>interfaces capture the ECC error events signaled by the CPU. This allows the application to further debug</p>
<p>the exact address, which caused the ECC error.</p>
<p>The CPU event signaling can be enabled by clearing the “X” bit of the performance monitoring unit’s</p>
<p>“Performance monitor control</p>
<p>register, c9”.</p>
<p>5</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>OSCIN</p>
<p>/NR</p>
<p>/1 to /64</p>
<p>INTCLK</p>
<p>PLL</p>
<p>/NF</p>
<p>/1 to /256</p>
<p>VCOCLK</p>
<p>/OD</p>
<p>/1 to /8</p>
<p>post_ODCLK</p>
<p>/R</p>
<p>/1 to /32</p>
<p>PLLCLK</p>
<p>f</p>
<p>= (f</p>
<p>/ NR) * NF / (OD * R)</p>
<p>PLLCLK</p>
<p>OSCIN</p>
<p>f</p>
<p>= (f</p>
<p>/ NR2) * NF2 / (OD2 * R2)</p>
<p>PLL2CLK</p>
<p>OSCIN</p>
<p>PLL2CLK</p>
<p>/R2</p>
<p>/1 to /32</p>
<p>post_ODCLK2</p>
<p>/OD2</p>
<p>/1 to /8</p>
<p>VCOCLK2</p>
<p>INTCLK2</p>
<p>OSCIN</p>
<p>/NR2</p>
<p>/1 to /64</p>
<p>PLL#2</p>
<p>/NF2</p>
<p>/1 to /256</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p>www.ti.com</p>
<p><i><b>2.5</b></i></p>
<p><i><b>Enable the Cortex-R4F CPU</b></i>’<i><b>s ECC Checking for ATCM Interface</b></i></p>
<p>The CPU has internal</p>
<p>ECC logic that protects all</p>
<p>CPU accesses to the ATCM (Flash) interface. This logic</p>
<p>is not used by default and must be enabled by setting the ATCMPCEN bit of the System control</p>
<p>coprocessor’s Auxiliary control</p>
<p>register, c1.</p>
<p><i><b>2.6</b></i></p>
<p><i><b>Handle the Cause of Reset</b></i></p>
<p>Each application has different levels of tolerance for different reset conditions. A typical</p>
<p>reset handler is</p>
<p>presented in the accompanying example code project, which identifies all</p>
<p>the causes of a reset condition</p>
<p>on the Hercules MCUs.</p>
<p><i><b>2.7</b></i></p>
<p><i><b>Configure PLLs</b></i></p>
<p>The Hercules microcontrollers contain a frequency-modulated phase-locked loop (FMPLL) macro that</p>
<p>allows the input oscillator frequency to be multiplied to a higher frequency than can be conveniently</p>
<p>achieved with an external</p>
<p>resonator or crystal. Additionally, the FMPLL allows the flexibility to generate</p>
<p>many different frequency options from a fixed crystal</p>
<p>or resonator.</p>
<p>The FMPLL allows the application to superimpose a “modulation frequency” signal</p>
<p>on the selected base</p>
<p>frequency signal</p>
<p>output from the FMPLL. This reduces the electromagnetic energy of the output signal</p>
<p>by</p>
<p>spreading it across a controlled frequency range around the base frequency. This mode is disabled by</p>
<p>default, and the application can enable it in applications sensitive to noise emissions.</p>
<p>The Hercules microcontrollers also contain a second non-modulating PLL macro. This PLL#2 can be</p>
<p>independently configured to generate a second high-frequency clock source for specific uses, e.g.,</p>
<p>FlexRay communication clock source of 80 MHz.</p>
<p><b>2.7.1</b></p>
<p><b>FMPLL Block Diagram</b></p>
<p>Figure 3 shows a high-level</p>
<p>block diagram of the FMPLL macro.</p>
<p><b>Figure 3. FMPLL Block Diagram</b></p>
<p>The parameters f</p>
<p>OSCIN</p>
<p>, f</p>
<p>post_ODCLK</p>
<p>and f</p>
<p>HCLK</p>
<p>are data sheet specifications. To identify the min/max limits on</p>
<p>these frequencies, see the device-specific data sheet.</p>
<p><b>NOTE:</b></p>
<p>The FMPLL takes (127 + 1024*NR) oscillator cycles to acquire lock to the target frequency,</p>
<p>hence it is recommended to configure the FMPLL(s) and enable them as soon as possible in</p>
<p>the device initialization.</p>
<p>6</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p>SPNA106A– January 2012</p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>www.ti.com</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p><b>2.7.2</b></p>
<p><b>FMPLL Configuration</b></p>
<p>PLL1 is configured using two control</p>
<p>registers, PLL Control</p>
<p>1 Register (PLLCTL1) and PLL Control</p>
<p>2</p>
<p>Register (PLLCTL2), located within the System module on the Hercules microcontrollers.</p>
<p>PLL2 is configured using a single PLL Control</p>
<p>3 Register (PLLCTL3) in the System module.</p>
<p><i><b>2.8</b></i></p>
<p><i><b>Enable Clock Sources</b></i></p>
<p><b>2.8.1</b></p>
<p><b>Available Clock Sources on Hercules Microcontrollers</b></p>
<p>The Hercules microcontrollers support seven different clock sources, as listed in Table 1.</p>
<p><b>Table 1. Clock Sources on Hercules Microcontrollers</b></p>
<p><b>Clock</b></p>
<p><b>Source</b></p>
<p><b>Number</b></p>
<p><b>Clock Source Name</b></p>
<p><b>Description</b></p>
<p>This is the primary oscillator, typically driven by an external</p>
<p>resonator or crystal. This</p>
<p>0</p>
<p>OSCIN</p>
<p>is the only available input to the FMPLL and the FMPLL2 macros. The OSCIN</p>
<p>frequency must be between 5 MHz and 20 MHz.</p>
<p>This is the output of the FMPLL, which is generated using the OSCIN as the input</p>
<p>clock. The FMPLL output clock frequency must not exceed the maximum device</p>
<p>1</p>
<p>FMPLL#1 output</p>
<p>frequency specified in the device-specific data sheet. The FMPLL features a</p>
<p>modulation mode where a modulation frequency is superimposed on the FMPLL</p>
<p>output signal.</p>
<p>No clock signal</p>
<p>is connected to source #2. This clock source must not be enabled or</p>
<p>2</p>
<p>Not implemented</p>
<p>chosen for any clock domain.</p>
<p>External</p>
<p>clock input #1. This clock source must only be enabled if there is an actual</p>
<p>3</p>
<p>EXTCLKIN1</p>
<p>external</p>
<p>clock source connected to the identified device terminal</p>
<p>for EXTCLKIN1. For</p>
<p>more information, see the device-specific data sheet.</p>
<p>This is the low-frequency output of the internal</p>
<p>reference oscillator. The LF LPO is</p>
<p>4</p>
<p>LF LPO</p>
<p>typically an 80 KHz signal, and is generally used for low-power mode use cases.</p>
<p>This is the high-frequency output of the internal</p>
<p>reference oscillator. The HF LPO is</p>
<p>5</p>
<p>HF LPO</p>
<p>typically a 10 MHz signal, and is used as a reference clock for monitoring the main</p>
<p>oscillator.</p>
<p>This is the output of the secondary FMPLL, which is generated using the OSCIN as</p>
<p>6</p>
<p>FMPLL#2 output</p>
<p>the input clock. The FMPLL output clock frequency must not exceed the maximum</p>
<p>device frequency specified in the device-specific data sheet.</p>
<p>External</p>
<p>clock input #2. This clock source must only be enabled if there is an actual</p>
<p>7</p>
<p>EXTCLKIN2</p>
<p>external</p>
<p>clock source connected to the identified device terminal</p>
<p>for EXTCLKIN2. For</p>
<p>more information, see the device-specific data sheet.</p>
<p><b>2.8.2</b></p>
<p><b>Control Registers for Enabling and Disabling Clock Sources</b></p>
<p>There are seven available clock sources on the Hercules microcontrollers:</p>
<p>•</p>
<p>Clock sources 0, 4 and 5 are enabled, while clock sources 1, 3, 6 and 7 are disabled upon any system</p>
<p>reset.</p>
<p>•</p>
<p>Clock source 2 is not implemented and must not be enabled in the application.</p>
<p>•</p>
<p>Each bit of the system module Clock Source Disable Register (CSDIS) controls the clock source of the</p>
<p>same number: bit 0 controls clock source 0, bit 1 controls clock source 1, and so on.</p>
<p>•</p>
<p>There are also dedicated Clock Source Disable Set (CSDISSET) and Clock Source Disable Clear</p>
<p>(CSDISCLR) registers to allow the application to avoid using read-modify-write operations.</p>
<p>•</p>
<p>Setting any bit commands, the corresponding clock source to be disabled.</p>
<p>–</p>
<p>The clock source can only be disabled once there is no clock domain or secondary clock source</p>
<p>(FMPLL, FMPLL#2) using the clock source to be disabled.</p>
<p>7</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p>www.ti.com</p>
<p><b>2.8.3</b></p>
<p><b>Example Clock Source Configuration</b></p>
<p>systemREG1-&gt;CSDISCLR = 0x00000000U</p>
<p>| 0x00000001U</p>
<p>// Enable clock source 0</p>
<p>| 0x00000002U</p>
<p>// Enable clock source 1</p>
<p>| 0x00000010U</p>
<p>// Enable clock source 4</p>
<p>| 0x00000020U</p>
<p>// Enable clock source 5</p>
<p>| 0x00000040U;</p>
<p>// Enable clock source 6</p>
<p>The above configuration enables clock sources 0, 1, 4, 5, and 6.</p>
<p>Of the clock sources that are enabled, number 0, 4 and 5 are enabled by default and will</p>
<p>have become</p>
<p>valid by the time the processor is released from reset upon a power-up. These are the main oscillator and</p>
<p>the two outputs from the internal</p>
<p>reference oscillator.</p>
<p>Clock source 1 and 6 are the two PLL outputs. The FMPLL as well</p>
<p>as the FMPLL#2 have a defined</p>
<p>start-up time, and their outputs are not available for use until</p>
<p>this time. The application must wait for the</p>
<p>valid status flags for these clock sources to be set before using the PLL outputs for any clock domain. The</p>
<p>example initialization sequence makes use of this PLL lock time to perform all</p>
<p>initialization actions that</p>
<p>don'e have to be done at the maximum operating frequency chosen for the application.</p>
<p><i><b>2.9</b></i></p>
<p><i><b>Run Self-Test on the eFuse Controller SECDED Logic</b></i></p>
<p>Electrically programmable fuses (eFuses) are used to configure the part after de-assertion of power-on</p>
<p>reset (nPORRST). The eFuse values are read and loaded into internal</p>
<p>registers as part of the</p>
<p>power-on-reset sequence. This is called the eFuse autoload. The eFuse values are protected with</p>
<p>single-bit error-correction, double-bit error-detection (SECDED) codes. These fuses are programmed</p>
<p>during the initial</p>
<p>factory test of the device. The eFuse controller is designed so that the state of the eFuses</p>
<p>cannot be changed once the device is packaged.</p>
<p>For safety critical</p>
<p>systems, it is important for the application to check the status of the eFuse controller</p>
<p>after a device reset. For more details on eFuse controller errors and the application sequence to check for</p>
<p>these errors, see the<i> eFuse Controller</i> chapter of the device-specific technical</p>
<p>reference manual.</p>
<p><i><b>2.10</b></i></p>
<p><i><b>Release Reset and Clocks to Peripherals</b></i></p>
<p>The peripherals are kept under reset, and need to be explicitly brought out of reset by the application. This</p>
<p>can be done by setting the peripheral</p>
<p>enable (PENA) bit of the Clock Control</p>
<p>Register (CLKCNTL).</p>
<p>The clocks to the peripheral</p>
<p>modules are also disabled upon any system reset and need to be explicitly</p>
<p>enabled by the application. This can be done by setting the bits corresponding to the peripheral</p>
<p>select</p>
<p>quadrant occupied by the peripheral</p>
<p>module in the Peripheral</p>
<p>Central</p>
<p>Resource (PCR) Control</p>
<p>Registers</p>
<p>for clearing the power down states of peripheral</p>
<p>modules (Peripheral</p>
<p>Power-Down Clear Register [0:3]</p>
<p>(PSPWRDWNCLRx)). For information on the peripheral</p>
<p>select quadrants for each peripheral, see the</p>
<p>device-specific data sheet.</p>
<p><i><b>2.11</b></i></p>
<p><i><b>Configure Flash Access</b></i></p>
<p>The Flash memory on the Hercules series microcontrollers is a non-volatile electrically erasable and</p>
<p>programmable memory.</p>
<p>The Hercules microcontrollers contain a digital</p>
<p>module that manages all</p>
<p>accesses to the Flash memory. A</p>
<p>Flash access can be completed without any wait states required for bus master clock speeds up to 45</p>
<p>MHz. If the bus clock is faster than 45 MHz, then any Flash access requires the appropriate number of</p>
<p>wait states depending on the bus clock speed. The Hercules series microcontrollers support clock speeds</p>
<p>up to 180 MHz. For the actual</p>
<p>maximum allowed speed and the number of corresponding address and</p>
<p>data wait states, see the device-specific data sheet.</p>
<p>Suppose that the application requires a CPU clock speed of 180 MHz. This requires 1 address wait state</p>
<p>and 3 data wait states for any access to the Flash memory. These wait states need to be configured in the</p>
<p>Flash module registers.</p>
<p>8</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p>SPNA106A– January 2012</p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>www.ti.com</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p>The Flash module also features a pipelined mode of operation. When this mode is enabled, the module</p>
<p>reads 128 bits from the Flash memory and holds them in buffers that the CPU can read from without any</p>
<p>wait state. The CPU can read 32 or 64 bits of instructions or data from the pipeline buffers.</p>
<p>The Flash Read Control</p>
<p>Register (FRDCNTL) inside the Flash module controls the wait states and the</p>
<p>pipeline mode.</p>
<p>The Hercules MCUs also have a separate Flash bank (bank #7) that is dedicated for data storage. This</p>
<p>bank can be used to emulate an EEPROM. Accesses to this Flash bank are configured via a separate</p>
<p>EEPROM Emulation Configuration Register (EEPROM_CONFIG) in the Flash module. A write operation</p>
<p>to the EEPROM_CONFIG register must first be enabled by configuring the Flash State Machine Write</p>
<p>Enable Control</p>
<p>Register (FSM_WR_ENA).</p>
<p>Once the access to the FSM control</p>
<p>registers is enabled, the read access to the Flash bank 7 can be</p>
<p>configured.</p>
<p><i><b>2.12</b></i></p>
<p><i><b>Configure Flash Bank and Pump Power Modes</b></i></p>
<p>The Flash banks and pump used on the Hercules series microcontrollers support three different operating</p>
<p>modes to optimize power consumption.</p>
<p>•</p>
<p>Active mode</p>
<p>–</p>
<p>Flash bank sense amplifiers and sense reference are enabled</p>
<p>–</p>
<p>All</p>
<p>circuits of Flash charge pump are enabled</p>
<p>•</p>
<p>Standby mode (only for Flash banks)</p>
<p>–</p>
<p>Flash bank sense reference is enabled but sense amplifiers are disabled</p>
<p>•</p>
<p>Sleep Mode</p>
<p>–</p>
<p>Flash bank sense amplifiers and sense reference are disabled</p>
<p>–</p>
<p>All</p>
<p>circuits of Flash charge pump are disabled</p>
<p>The Flash banks and charge pump are in the active state by default and after any system reset. The Flash</p>
<p>module allows the application to configure “fall</p>
<p>back” power states for the Flash banks and charge pump.</p>
<p>The Flash banks and pump automatically switch the power mode to the selected fall</p>
<p>back state when</p>
<p>there is no access to the Flash banks detected within a user-configurable time.</p>
<p>The Flash module also contains special</p>
<p>timers to automatically sequence the Flash banks and pump</p>
<p>between the active and the selected fall-back states. A read access to any Flash bank that is in a</p>
<p>non-active power state “wakes up” both the selected bank and the charge pump to active power state.</p>
<p>Programming and erase operations are only allowed on banks in active state.</p>
<p>The Flash Bank Access Control</p>
<p>Register (FBAC) controls the Flash banks’</p>
<p>power states.</p>
<p>The Flash Pump Access Control</p>
<p>Registers (FPAC1, FPAC2) control</p>
<p>the Flash pump's power states.</p>
<p><i><b>2.13</b></i></p>
<p><i><b>Configure Oscillator Monitor</b></i></p>
<p>The HF LPO clock source is used as a reference clock for monitoring the main oscillator. A failure is</p>
<p>detected if the oscillator frequency falls outside the range: {f</p>
<p>HFLPO</p>
<p>/ 4, f</p>
<p>HFLPO</p>
<p>*4}.</p>
<p>The HF LPO frequency varies significantly over process corners as well</p>
<p>as with changes in the core</p>
<p>supply (VCC) and temperature. The Hercules microcontrollers allow the application to trim the HF LPO</p>
<p>such that the application can choose the operating frequency point of the HF LPO. This in turn determines</p>
<p>the valid range of oscillator frequency.</p>
<p>During device test, a trim value is written into the one-time programmable section of the Flash memory</p>
<p>(OTP), address 0xF008_01B4. Bits 31:16 of this OTP word contain a 16-bit value that may be</p>
<p>programmed into Low Power Oscillator Monitor Control</p>
<p>Register (LPOMONCTL) in order to initialize the</p>
<p>trim for HF LPO.</p>
<p>9</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p>www.ti.com</p>
<p>Alternatively, the application can use the dual-clock compare (DCC) module to determine the trim setting</p>
<p>for the HF LPO. The DCC module allows for comparison of two clock frequencies. Once the HF LPO is</p>
<p>determined to be in-range with the initial</p>
<p>HFTRIM setting from the OTP, the crystal</p>
<p>oscillator may be used</p>
<p>as a reference against which the HF LPO and LF LPO may be further adjusted. For more details, see the</p>
<p>device-specific technical</p>
<p>reference manual.</p>
<p><i><b>2.14</b></i></p>
<p><i><b>Run Self-Test on the Flash Module SECDED Logic</b></i></p>
<p>The Flash module reads the “reset configuration vector” from address 0xF0080140 in the TI OTP region of</p>
<p>Flash bank 0. This is a 64-bit value that is used to configure the device power domains, etc. The Flash</p>
<p>module has built-in SECDED logic to correct any single-bit error in this vector or detect and flag and</p>
<p>double-bit error in this vector. If a double-bit error is detected during this read from the OTP, an ESM</p>
<p>group3 error condition is flagged and the nERROR signal</p>
<p>is asserted low. If a single-bit error is detected</p>
<p>during the read from the OTP, this error is corrected by the SECDED logic – no flag is set and no error</p>
<p>signal</p>
<p>is sent to the ESM.</p>
<p>There are dedicated locations within the TI OTP sector of Flash bank 0 that are programmed to have</p>
<p>single-bit and double-bit errors. Specifically, a 32-bit or 64-bit read from the address 0xF00803F0 results</p>
<p>in a single-bit error indication, and a 32-bit or 64-bit read from the address 0xF00803F8 results in a</p>
<p>double-bit error indication. These locations can be read by the application to ensure that the Flash</p>
<p>interface module is capable of detecting single-bit and double-bit errors upon reads from the OTP.</p>
<p><i><b>2.15</b></i></p>
<p><i><b>Clock Domains</b></i></p>
<p>All</p>
<p>further initializatio steps are now required to be performed at the max operating frequency for the</p>
<p>application. The application must now wait for the PLLs to lock to their target frequencies, and then map</p>
<p>the device clock domains to the desired clock sources. There are multiple clock domains on the Hercules</p>
<p>microcontrollers to ease the configuration and controllability of the different modules using these clock</p>
<p>domains (see Table 2).</p>
<p><b>Table 2. Clock Domains on Hercules Microcontrollers</b></p>
<p><b>Domain Name</b></p>
<p><b>Clock Name</b></p>
<p><b>Comments</b></p>
<p>GCLK controls all</p>
<p>the CPU sub-systems, including the floating point</p>
<p>CPU clock domain</p>
<p>GCLK</p>
<p>unit (FPU), and the memory protection unit (MPU)</p>
<p>HCLK shares the same clock source as GCLK, and is always the</p>
<p>System bus clock domain</p>
<p>HCLK</p>
<p>same frequency as HCLK.</p>
<p>VCLK_sys is used for the system modules such as VIM, ESM, SYS,</p>
<p>System peripheral</p>
<p>clock domain</p>
<p>VCLK_sys</p>
<p>etc. VCLK_sys is divided down from HCLK by a programmable</p>
<p>divider from 1 to 16.</p>
<p>VCLK is the primary peripheral</p>
<p>clock, and is synchronous with</p>
<p>VCLK_sys. VCLK2 is a secondary peripheral</p>
<p>clock and is reserved</p>
<p>for use by the enhanced timer module (NHET) and the associated</p>
<p>transfer unit (HTU). VCLK2 is also divided down from HCLK by a</p>
<p>Peripheral</p>
<p>clock domains</p>
<p>VCLK, VCLK2, VCLK3</p>
<p>programmable divider from 1 to 16. f</p>
<p>HCLK</p>
<p>must be an integer multiple</p>
<p>of f</p>
<p>VCLK2</p>
<p>, f</p>
<p>VCLK2</p>
<p>must be an integer multiple of f</p>
<p>VCLK</p>
<p>. VCLK3 is also</p>
<p>divided down from HCLK by a programmable divider from 1 to 16,</p>
<p>and is used for the Ethernet and EMIF modules on the TMS570LS3x</p>
<p>microcontrollers.</p>
<p>These clock domains are reserved for use by special</p>
<p>communication</p>
<p>modules that have strict jitter constraints. The protocols for these</p>
<p>VCLKA1, VCLKA2, and</p>
<p>communication modules (e.g., CAN, FlexRay, Ethernet) do not allow</p>
<p>Asynchronous clock domains</p>
<p>VCLKA4</p>
<p>modulated clocks to be used for the baud rate generation. The</p>
<p>asynchronous clocks allow the clock sources for the baud clocks to</p>
<p>be decoupled from the GCLK, HCLK and VCLKx clock domains.</p>
<p>This clock is used for generating the periodic interrupts by the RTI</p>
<p>Real-time Interrupt clock domains</p>
<p>RTI1CLK</p>
<p>module.</p>
<p>10</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p>SPNA106A– January 2012</p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>www.ti.com</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p><b>2.15.1</b></p>
<p><b>Mapping Clock Domains to Clock Sources</b></p>
<p>The system module on the Hercules microcontrollers contains registers that allow the clock domains to be</p>
<p>mapped to any of the available clock sources.</p>
<p>The clock source for the GCLK, HCLK , and VCLKx domains is selected by the GCLK, HCLK, VCLK, and</p>
<p>VCLK2 Source Register (GHVSRC).</p>
<p>The clock sources for the VCLKA1 and VCLKA2 domains are selected via the Peripheral</p>
<p>Asynchronous</p>
<p>Clock Source Register (VCLKASRC).</p>
<p>The clock sources for the VCLKA3 and VCLKA4 domains are selected via the Peripheral</p>
<p>Asynchronous</p>
<p>Clock Configuration 1 Register (VCLKACON1).</p>
<p>The clock source for the RTI1CLK domain is selected via the RTI Clock Source Register (RCLKSRC).</p>
<p><b>2.15.2</b></p>
<p><b>Example Clock Domain Mapping</b></p>
<p>systemREG1-&gt;GHVSRC</p>
<p>= (0U &lt;&lt; 24U)</p>
<p>// Use main oscillator as wake up source for GHV CLK</p>
<p>| (0U &lt;&lt; 16U)</p>
<p>// Use main oscillator for HV CLK when GCLK is off</p>
<p>| (1U);</p>
<p>// Use FMPLL as current source for GHV CLK</p>
<p>systemREG1-&gt;VCLKASRC = (6U &lt;&lt; 8U)</p>
<p>// Use second PLL output for FlexRay bit timing</p>
<p>| (0U);</p>
<p>// Use main oscillator for DCANx bit timings</p>
<p>systemREG1-&gt;RCLKSRC</p>
<p>= (1U &lt;&lt; 8U)</p>
<p>// Set the RTI1CLK divider to divide-by-2</p>
<p>| (0U);</p>
<p>// Use FMPLL as source for RTI1CLK</p>
<p><b>2.15.3</b></p>
<p><b>Configuring VCLK , VCLK2 and VCLK3 Frequencies</b></p>
<p>The VCLK and VCLK2 clock signals are divided down from the HCLK clock signal. These are independent</p>
<p>dividers that can be configured via the system module clock control</p>
<p>register (CLKCNTL).</p>
<p><b>NOTE:</b></p>
<p>•</p>
<p>VCLK2 frequency must also be an integer multiple of VCLK frequency.</p>
<p>•</p>
<p>There must be some delay between configuring the divide ratios for VCLK2 and VCLK.</p>
<p>The VCLK3 clock signal</p>
<p>is also divided down from the HCLK clock signal. This divider is in the Clock</p>
<p>Control</p>
<p>Register 2 (CLK2CNTL).</p>
<p><i><b>2.16</b></i></p>
<p><i><b>Run a Diagnostic Check on CPU Self-Test Controller (STC)</b></i></p>
<p>This involves running one CPU self-test interval</p>
<p>in STC check mode. The STC self-check mode causes a</p>
<p>stuck-at-0 fault to be introduced inside one of the two CPUs for there to be an STC failure. If no STC</p>
<p>failure is indicated, this would mean that the STC is not capable of detecting a fault inside the CPU, and</p>
<p>device operation is not reliable. For information on the configuration and execution of the STC self-test,</p>
<p>see the device-specific technical</p>
<p>reference manual. The CPU will</p>
<p>be reset once the STC self-test is</p>
<p>completed. The reset handler routine can resume the device initialization from the next step in the</p>
<p>sequence.</p>
<p><i><b>2.17</b></i></p>
<p><i><b>Run CPU Self-Test (LBIST)</b></i></p>
<p>For information on the configuration and execution of the CPU self-test, see the device-specific technical</p>
<p>reference manual. The CPU will</p>
<p>be reset once the self-test is completed. The reset handler routine can</p>
<p>resume the device initialization from the next step in the sequence.</p>
<p>11</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p>www.ti.com</p>
<p><i><b>2.18</b></i></p>
<p><i><b>Run a Diagnostic Check on the CPU Compare Module (CCM-R4F)</b></i></p>
<p>The CCM-R4F compares the dual</p>
<p>Cortex-R4F CPU outputs on each CPU clock cycle. Any mismatch is</p>
<p>indicated as an ESM group2 error. This ensures that the two CPUs are indeed operating in a lock-step</p>
<p>mode. The CCM-R4F module also allows the application to test the different error conditions using built-in</p>
<p>self-test routines. For information on how to configure the CCM-R4F in a self-test mode, see the</p>
<p>device-specific technical</p>
<p>reference manual.</p>
<p><i><b>2.19</b></i></p>
<p><i><b>Run a Diagnostic Check on the Programmable Built-In Self-Test (PBIST) Controller</b></i></p>
<p>The PBIST engine is used to run memory test routines on all</p>
<p>on-chip memories. It is critical</p>
<p>for the</p>
<p>application to rely on this engine being able to detect and report a memory fault condition. Therefore it is</p>
<p>necessary for the application to test this error detection and reporting mechanism before actually using it</p>
<p>to test the on-chip memories. This is done by choosing to run a RAM test routine on a ROM memory. This</p>
<p>test must generate a memory test failure. The application can look for the error flag to ensure that the</p>
<p>PBIST controller can indeed detect and report a memory test failure. For information on how to configure</p>
<p>the PBIST controller for executing specific memory test algorithms on selected on-cip memories, see the</p>
<p>device-specific technical</p>
<p>reference manual</p>
<p>.</p>
<p><i><b>2.20</b></i></p>
<p><i><b>Start a Self-Test on the CPU RAM Using the PBIST Controller</b></i></p>
<p>The CPU RAM is tested first, so that the application can continue to execute while other memories are</p>
<p>being tested later. For information on configuring the PBIST controller, see the device-specific technical</p>
<p>reference manual.</p>
<p><i><b>2.21</b></i></p>
<p><i><b>Initialize the CPU RAM</b></i></p>
<p>The system module hardware for auto-initialization of on-chip memories also initializes the associated</p>
<p>ECC or parity locations. This mechanism is now used to initialize the CPU RAM. This process clears the</p>
<p>CPU RAM to all</p>
<p>zeros and also programs the corresponding ECC locations.</p>
<p><i><b>2.22</b></i></p>
<p><i><b>Enable the Cortex-R4F CPU</b></i>’<i><b>s ECC Checking for BxTCM Interface</b></i></p>
<p>The CPU has internal</p>
<p>ECC logic that protects all</p>
<p>CPU accesses to the BTCM (RAM) interfaces. This logic</p>
<p>is not used by default and must be enabled by setting the B1TCMPCEN and B0TCMPCEN bits of the</p>
<p>System control</p>
<p>coprocessor’s Auxiliary control</p>
<p>register, c1.</p>
<p><i><b>2.23</b></i></p>
<p><i><b>Start a Self-Test on All Dual-Port Memories</b></i>’</p>
<p><i><b>Using the PBIST Controller</b></i></p>
<p>Separate algorithms are used for testing single-port versus dual-port on-chip SRAMs. For information on</p>
<p>executing the self-test on the on-chip memories using the programmable BIST (PBIST) engine, see the</p>
<p>device-specific technical</p>
<p>reference manual.</p>
<p><i><b>2.24</b></i></p>
<p><i><b>Run a Self-Test on CPU</b></i>'<i><b>s ECC Logic for Accesses to TCRAM</b></i></p>
<p>The CPU TCRAM was initialized earlier, so that all</p>
<p>TCRAM is cleared to zeros and the corresponding</p>
<p>correct ECC locations are programmed. The test of the CPU's ECC logic for accesses to TCRAM involves</p>
<p>corrupting the ECC locations to create single-bit and two-bit ECC errors. For the sequence to test the</p>
<p>CPU's ECC logic for accesses to TCRAM, see the device-specific technical</p>
<p>reference manual</p>
<p>or the</p>
<p>initialization example project. Note that reading from a TCRAM location with a double-bit ECC error</p>
<p>causes the CPU to take a data abort exception. The initialization example project also includes an</p>
<p>example data abort handler.</p>
<p><i><b>2.25</b></i></p>
<p><i><b>Run a Self-Test on CPU</b></i>'<i><b>s ECC Logic for Accesses to Program Flash</b></i></p>
<p>The Flash interface module supports a diagnostic mode (mode 7) that allows the application to test the</p>
<p>CPU's ECC logic for accesses to program Flash. For the sequence to test the CPU's ECC logic for</p>
<p>accesses to program Flash, see the device-specific technical</p>
<p>reference manual</p>
<p>or the initialization</p>
<p>example project. Note that reading from a program Flash location with a double-bit ECC error causes the</p>
<p>CPU to take a data abort exception. The initialization example project also includes an example data abort</p>
<p>handler.</p>
<p>12</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p>SPNA106A– January 2012</p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>www.ti.com</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p><i><b>2.26</b></i></p>
<p><i><b>Start a Self-Test on All Single-Port Memories</b></i>’</p>
<p><i><b>Using the PBIST Controller</b></i></p>
<p>The CPU RAM can be excluded from this testing as it has already been verified before. For information on</p>
<p>executing the self-test on the on-chip memories using the programmable BIST (PBIST) engine, see the</p>
<p>device-specific technical</p>
<p>reference manual.</p>
<p><i><b>2.27</b></i></p>
<p><i><b>On-Chip SRAM Auto-Initialization</b></i></p>
<p>The system module on the Hercules microcontroller allows all</p>
<p>on-chip SRAMs to be initialized in hardware.</p>
<p>This is especially essential</p>
<p>since all</p>
<p>the on-chip memories support some form of error detection. The CPU</p>
<p>data RAM supports ECC while the peripheral</p>
<p>memories support parity error detection. The</p>
<p>auto-initialization mechanism also initializes the ECC or parity memories, as required.</p>
<p><i><b>2.28</b></i></p>
<p><i><b>Run a Self-Test on All Peripheral RAMs</b></i>'</p>
<p><i><b>Parity Protection Mechanism</b></i></p>
<p>Accesses to most peripheral</p>
<p>RAMs on this microcontroller are protected by parity error detection. Each of</p>
<p>the peripherals with the parity error detection for its associated memory also includes a self-test mode to</p>
<p>ensure that it is indeed capable of detecting and reporting a parity error on an access to the peripheral</p>
<p>RAM. These self-test mechanisms can be used by the application before enabling use of the concerned</p>
<p>peripheral.</p>
<p><i><b>2.29</b></i></p>
<p><i><b>Enable the Cortex-R4F CPU</b></i>’<i><b>s Vectored Interrupt Controller (VIC) Port</b></i></p>
<p>The CPU has a dedicated port that enables the VIM module to supply the address of an interrupt service</p>
<p>routine along with the interrupt (IRQ) signal. This provides faster entry into the interrupt service routine</p>
<p>versus the CPU having to decode the pending interrupts and identify the highest priority interrupt to be</p>
<p>serviced first.</p>
<p>The VIC port is disabled upon any CPU reset and must be enabled by the application. The VIC is enabled</p>
<p>by setting the VE bit in the CPU’s System Control</p>
<p>Register (SYS).</p>
<p><i><b>2.30</b></i></p>
<p><i><b>Vectored Interrupt Manager (VIM) Configuration</b></i></p>
<p>The VIM module on the Hercules microcontrollers supports flexible mapping of interrupt request channels</p>
<p>and the interrupt generating sources. The default mapping between the channel</p>
<p>number and the</p>
<p>interrupting module is defined in the device-specific data sheet. The interrupt channel</p>
<p>number also defines</p>
<p>the inherent priority between the channels, with the lower numbered channel</p>
<p>having the higher priority.</p>
<p>That is, the priority decreases in the following order: channel</p>
<p>0 → channel</p>
<p>1 → channel</p>
<p>2 → … channel</p>
<p>95.</p>
<p>For this application report, assume that the application prefers to keep the default priority order between</p>
<p>the channels. For details on the control</p>
<p>registers for changing the mapping between interrupt channels</p>
<p>and sources, see the device-specific technical</p>
<p>reference manual.</p>
<p>The VIM module contains a memory that holds the starting addresses of the interrupt service routines for</p>
<p>each interrupt enabled in the application. This memory starts at base address 0xFFF82000 on the</p>
<p>Hercules microcontrollers. It is organized in 97 words of 32 bits. The VIM address memory map is shown</p>
<p>in Figure 4.</p>
<p>13</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>Interrupt vector table address space</p>
<p>0xFFF82000</p>
<p>0xFFF82004</p>
<p>0xFFF82008</p>
<p>Phantom Vector</p>
<p>Channel 0 Vector</p>
<p>Channel 1 Vector</p>
<p>Channel 93 Vector</p>
<p>Channel 94 Vector</p>
<p>0xFFF82178</p>
<p>0xFFF8217C</p>
<p><i>Standard Initialization Sequence for Hercules Microcontrollers</i></p>
<p>www.ti.com</p>
<p><b>Figure 4. VIM Interrupt Address Memory Map</b></p>
<p><b>2.30.1</b></p>
<p><b>Configure Interrupts to be Fast Interrupts or Normal Interrupts</b></p>
<p>Each interrupt request to the VIM can be configured to be forwarded to the CPU as a fast interupt request</p>
<p>(FIQ) or a normal</p>
<p>interrupt request (IRQ). The FIQ/IRQ Program Control</p>
<p>Registers (FIRQPRx) allow this</p>
<p>selection.</p>
<p>Interrupt requests 0 and 1 are always FIQ. All</p>
<p>others are IRQ interrupts by default.</p>
<p><b>NOTE:</b></p>
<p>An interrupt request mapped to FIQ cannot use the CPU’s VIC port.</p>
<p><b>2.30.2</b></p>
<p><b>Enabling and Disabling Interrupts</b></p>
<p>Each interrupt request can be enabled or disabled using the Interrupt Enable Set (REQENASETx) and</p>
<p>Interrupt Enable Clear (REQENACLRx) registers. The interrupt requests 0 and 1 are always enabled and</p>
<p>cannot be disabled. When an interrupt is disabled, it does not prevent the interrupt flag to get set when the</p>
<p>interrupt condition is generated but no IRQ or FIR exception is generated for the Cortex-R4F CPU.</p>
<p><i><b>2.31</b></i></p>
<p><i><b>Enable Interrupts in the Cortex-R4F CPU</b></i></p>
<p>Interrupts (IRQ and FIQ) are disabled inside the Cortex-R4F CPU by default and after a CPU reset. The</p>
<p>normal</p>
<p>interrupt can be enabled by clearing the &quot;I&quot; bit of the Current Program Status Register (CPSR)</p>
<p>inside the Cortex-R4F CPU, while the fast interrupt (FIQ) can be enabled by clearing the &quot;F&quot; bit of the</p>
<p>CPSR.</p>
<p><i><b>2.32</b></i></p>
<p><i><b>Setup the Error Signaling Module (ESM) Responses to Group1 Errors</b></i></p>
<p>The ESM allows the application to choose the module response to errors in the Group1 classification.</p>
<p>These are errors of the lowest severity and can be handled by the application by generating an interrupt to</p>
<p>the CPU. The ESM also offers the capability to indicate any group1 errors on the external</p>
<p>nERROR pin.</p>
<p><i><b>2.33</b></i></p>
<p><i><b>Additional Initializations Required by Compiler</b></i></p>
<p>If the source program is written using C or C++, the TI compiler requires the creation of the C/C++</p>
<p>run-time environment. This includes:</p>
<p>•</p>
<p>Initialization of copy table, if required</p>
<p>14</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p>SPNA106A– January 2012</p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p>www.ti.com</p>
<p><i>References</i></p>
<p>•</p>
<p>Initialization of global</p>
<p>and static variables defines in C/C++</p>
<p>•</p>
<p>Initialization of global</p>
<p>constructors</p>
<p>•</p>
<p>Make a function call</p>
<p>to branch to the main application</p>
<p>These requirements could be different for each compiler. The compiler reference manual</p>
<p>must be referred</p>
<p>to identify the specific requirements for the compiler being used.</p>
<p><i><b>2.34</b></i></p>
<p><i><b>Other Initialization Steps Not Described in this Document</b></i></p>
<p>The following is an additional</p>
<p>list of operations that an application can perform during the device</p>
<p>initialization.</p>
<p>•</p>
<p>Verify that the DCC module can detect and report a frequency mismatch error.</p>
<p>•</p>
<p>Configure the DCC module to continuously monitor the PLL output frequency.</p>
<p>•</p>
<p>Several</p>
<p>bus masters on this microcontroller include their own memory protection units to protect</p>
<p>against accesses to certain parts of the memory map. It is recommended to ensure that violations of</p>
<p>these MPU restrictions are detected and flagged as ESM errors.</p>
<p>•</p>
<p>Configure the MPU for each bus masters.</p>
<p>•</p>
<p>Run a background check on the program Flash memory using CRC and DMA.</p>
<p>•</p>
<p>Calibrate the embedded ADC module for any offset error.</p>
<p>•</p>
<p>Run a self-test on all</p>
<p>ADC inputs to ensure that they are not open or shorted to power or ground.</p>
<p>•</p>
<p>Run an I/O loop-back check on all</p>
<p>peripheral</p>
<p>signals.</p>
<p>•</p>
<p>Configure the windowed watchdog module service window size as well</p>
<p>as the module response to a</p>
<p>window violation.</p>
<p>•</p>
<p>Configure the N2HET1/N2HET2 monitoring capability.</p>
<p>•</p>
<p>Setup the RTI module to generate periodic interrupts as necessary.</p>
<p>•</p>
<p>Configure desired access permissions for peripherals using the PCR registers.</p>
<p>•</p>
<p>Configure any external</p>
<p>safety companion chip, e.g., TI TPS6538x, for online diagnostic operation.</p>
<p><i><b>2.35</b></i></p>
<p><i><b>Call the Main Application</b></i></p>
<p>This is a normal</p>
<p>function call</p>
<p>when using C/C++. It could be a branch or branch-link to the name of the</p>
<p>routine that executes the application.</p>
<p>For example:</p>
<p>main();</p>
<p>exit();</p>
<p><b>3</b></p>
<p><b>References</b></p>
<p>•</p>
<p><i>TMS570LSxxx7 16/32-Bit Risc Flash Microcontroller Data Sheet</i> (SPNS162)</p>
<p>•</p>
<p><i>TMS570LSxxx5 16/32-Bit Risc Flash Microcontroller Data Sheet</i> (SPNS164)</p>
<p>•</p>
<p><i>TMS570LSxxx4 16/32-Bit Risc Flash Microcontroller Data Sheet</i> (SPNS165)</p>
<p>•</p>
<p><i>RM48Lx50 16/32-Bit Risc Flash Microcontroller Data Sheet</i> (SPNS174)</p>
<p>•</p>
<p><i>RM48Lx40 16/32-Bit Risc Flash Microcontroller Data Sheet</i> (SPNS175)</p>
<p>•</p>
<p><i>RM48Lx30 16/32-Bit Risc Flash Microcontroller Data Sheet</i> (SPNS176)</p>
<p>•</p>
<p><i>TMS570LS31/21 16/32-Bit RISC Flash Microcontroller Technical</i></p>
<p><i>Reference Manual</i></p>
<p>(SPNU499)</p>
<p>•</p>
<p><i>RM48 16/32-Bit RISC Flash Microcontroller Technical</i></p>
<p><i>Reference Manual</i></p>
<p>(SPNU503)</p>
<p>15</p>
<p>SPNA106A– January 2012</p>
<p><i>Initialization of Hercules</i>™<i> ARM</i></p>
<p>®</p>
<p><i>Cortex</i>™<i>-R4F Microcontrollers</i></p>
<p><i>Submit Documentation Feedback</i></p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
<h1 style="page-break-before:always; "></h1>
<p><b>IMPORTANT NOTICE</b></p>
<p>Texas Instruments Incorporated and its subsidiaries (TI) reserve the right to make corrections, modifications, enhancements, improvements,</p>
<p>and other changes to its products and services at any time and to discontinue any product or service without notice. Customers should</p>
<p>obtain the latest relevant information before placing orders and should verify that such information is current and complete. All</p>
<p>products are</p>
<p>sold subject to TI’s terms and conditions of sale supplied at the time of order acknowledgment.</p>
<p>TI warrants performance of its hardware products to the specifications applicable at the time of sale in accordance with TI’s standard</p>
<p>warranty. Testing and other quality control</p>
<p>techniques are used to the extent TI deems necessary to support this warranty. Except where</p>
<p>mandated by government requirements, testing of all</p>
<p>parameters of each product is not necessarily performed.</p>
<p>TI assumes no liability for applications assistance or customer product design. Customers are responsible for their products and</p>
<p>applications using TI components. To minimize the risks associated with customer products and applications, customers should provide</p>
<p>adequate design and operating safeguards.</p>
<p>TI does not warrant or represent that any license, either express or implied, is granted under any TI patent right, copyright, mask work right,</p>
<p>or other TI intellectual</p>
<p>property right relating to any combination, machine, or process in which TI products or services are used. Information</p>
<p>published by TI regarding third-party products or services does not constitute a license from TI to use such products or services or a</p>
<p>warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual</p>
<p>property of the third party, or a license from TI under the patents or other intellectual</p>
<p>property of TI.</p>
<p>Reproduction of TI information in TI data books or data sheets is permissible only if reproduction is without alteration and is accompanied</p>
<p>by all</p>
<p>associated warranties, conditions, limitations, and notices. Reproduction of this information with alteration is an unfair and deceptive</p>
<p>business practice. TI is not responsible or liable for such altered documentation. Information of third parties may be subject to additional</p>
<p>restrictions.</p>
<p>Resale of TI products or services with statements different from or beyond the parameters stated by TI for that product or service voids all</p>
<p>express and any implied warranties for the associated TI product or service and is an unfair and deceptive business practice. TI is not</p>
<p>responsible or liable for any such statements.</p>
<p>TI products are not authorized for use in safety-critical</p>
<p>applications (such as life support) where a failure of the TI product would reasonably</p>
<p>be expected to cause severe personal</p>
<p>injury or death, unless officers of the parties have executed an agreement specifically governing</p>
<p>such use. Buyers represent that they have all</p>
<p>necessary expertise in the safety and regulatory ramifications of their applications, and</p>
<p>acknowledge and agree that they are solely responsible for all</p>
<p>legal, regulatory and safety-related requirements concerning their products</p>
<p>and any use of TI products in such safety-critical</p>
<p>applications, notwithstanding any applications-related information or support that may be</p>
<p>provided by TI. Further, Buyers must fully indemnify TI and its representatives against any damages arising out of the use of TI products in</p>
<p>such safety-critical</p>
<p>applications.</p>
<p>TI products are neither designed nor intended for use in military/aerospace applications or environments unless the TI products are</p>
<p>specifically designated by TI as military-grade or &quot;enhanced plastic.&quot; Only products designated by TI as military-grade meet military</p>
<p>specifications. Buyers acknowledge and agree that any such use of TI products which TI has not designated as military-grade is solely at</p>
<p>the Buyer's risk, and that they are solely responsible for compliance with all</p>
<p>legal</p>
<p>and regulatory requirements in connection with such use.</p>
<p>TI products are neither designed nor intended for use in automotive applications or environments unless the specific TI products are</p>
<p>designated by TI as compliant with ISO/TS 16949 requirements. Buyers acknowledge and agree that, if they use any non-designated</p>
<p>products in automotive applications, TI will</p>
<p>not be responsible for any failure to meet such requirements.</p>
<p>Following are URLs where you can obtain information on other Texas Instruments products and application solutions:</p>
<p><b>Products</b></p>
<p><b>Applications</b></p>
<p>Audio</p>
<p>www.ti.com/audio</p>
<p>Automotive and Transportation</p>
<p>www.ti.com/automotive</p>
<p>Amplifiers</p>
<p>amplifier.ti.com</p>
<p>Communications and Telecom www.ti.com/communications</p>
<p>Data Converters</p>
<p>dataconverter.ti.com</p>
<p>Computers and Peripherals</p>
<p>www.ti.com/computers</p>
<p>DLP® Products</p>
<p>www.dlp.com</p>
<p>Consumer Electronics</p>
<p>www.ti.com/consumer-apps</p>
<p>DSP</p>
<p>dsp.ti.com</p>
<p>Energy and Lighting</p>
<p>www.ti.com/energy</p>
<p>Clocks and Timers</p>
<p>www.ti.com/clocks</p>
<p>Industrial</p>
<p>www.ti.com/industrial</p>
<p>Interface</p>
<p>interface.ti.com</p>
<p>Medical</p>
<p>www.ti.com/medical</p>
<p>Logic</p>
<p>logic.ti.com</p>
<p>Security</p>
<p>www.ti.com/security</p>
<p>Power Mgmt</p>
<p>power.ti.com</p>
<p>Space, Avionics and Defense</p>
<p>www.ti.com/space-avionics-defense</p>
<p>Microcontrollers</p>
<p>microcontroller.ti.com</p>
<p>Video and Imaging</p>
<p>www.ti.com/video</p>
<p>RFID</p>
<p>www.ti-rfid.com</p>
<p>OMAP Mobile Processors</p>
<p>www.ti.com/omap</p>
<p>Wireless Connectivity</p>
<p>www.ti.com/wirelessconnectivity</p>
<p><b>TI E2E Community Home Page</b></p>
<p>e2e.ti.com</p>
<p>Mailing Address: Texas Instruments, Post Office Box 655303, Dallas, Texas 75265</p>
<p>Copyright © 2012, Texas Instruments Incorporated</p>
</body>
</html>
{% endraw %}