---
layout: default
title: TechnicalReference_Asr_Xcp
nav_order: 27
parent: Fiasa_326_327_EPS_TMS570
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>XCP Protocol Layer </b></p>
<p>Technical Reference </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Version 2.03.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Version: </b></p>
<p>2.03.00 </p>
<p><b>Status: </b></p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>2 / 109 </p>
<p><b>1 </b></p>
<p><b>History </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>2005-01-17 </p>
<p>1.00.00 </p>
<p>ESCAN00009143: Initial draft </p>
<p>Warning Text added </p>
<p>2005-06-22 </p>
<p>1.01.00 </p>
<p>FAQ extended: ESCAN00012356, ESCAN00012314 </p>
<p>ESCAN00012617: Add service to retrieve XCP state </p>
<p>2005-12-20 </p>
<p>1.02.00 </p>
<p>ESCAN00013883: Revise Resume Mode </p>
<p>2006-03-09 </p>
<p>1.03.00 </p>
<p>ESCAN00015608: Support command TRANSPORT_LAYER_CMD </p>
<p>ESCAN00015609: Support XCP on FlexRay Transport Layer </p>
<p>2006-04-24 </p>
<p>1.04.00 </p>
<p>ESCAN00015913: Correct filenames </p>
<p>Data page banking support of application callback template added </p>
<p>2006-05-08 </p>
<p>1.05.00 </p>
<p>ESCAN00016263: Describe support of reflected CRC16 CCITT </p>
<p>ESCAN00016159: Add demo disclaimer to XCP Basic </p>
<p>2006-05-29 </p>
<p>1.06.00 </p>
<p>ESCAN00016226: Support XCP on LIN Transport Layer </p>
<p>2006-07-20 </p>
<p>1.07.00 </p>
<p>ESCAN00012636: Add configuration with GENy </p>
<p>ESCAN00016956: Support AUTOSAR CRC module </p>
<p>2006-10-26 </p>
<p>1.08.00 </p>
<p>ESCAN00018115: DPRAM Support only available in XCP Basic </p>
<p>ESCAN00017948: Add paging support </p>
<p>ESCAN00017221: Documentation of reentrant capability of all </p>
<p>functions </p>
<p>2007-01-18 </p>
<p>1.09.00 </p>
<p>ESCAN00018809: Support data paging on Star12X / Cosmic </p>
<p>2007-05-07 </p>
<p>1.10.00 </p>
<p>Description of new features added </p>
<p>2007-09-14 </p>
<p>1.11.00 </p>
<p>Segment freeze mode now supported </p>
<p>2008-07-23 </p>
<p>1.12.00 </p>
<p>ESCAN00028586: Support of Program_Start callback </p>
<p>ESCAN00017955: Support MIN_ST_PGM </p>
<p>ESCAN00017952: Open Interface for command processing </p>
<p>2008-09-10 </p>
<p>1.13.00 </p>
<p>Additional pending return value of call backs added </p>
<p>MIN_ST configuration added </p>
<p>2008-12-01 </p>
<p>1.14.00 </p>
<p>ESCAN00018157: SERV_RESET is not supported </p>
<p>ESCAN00032344: Update of XCP Basic Limitations </p>
<p>2009-05-14 </p>
<p>1.15.00 </p>
<p>ESCAN00033909: New features implemented: Prog Write </p>
<p>Protection, Timestamps, Calibration activation </p>
<p>2009-07-30 </p>
<p>1.15.01 </p>
<p>Fixed some editorial errors </p>
<p>2009-11-13 </p>
<p>1.16.00 </p>
<p>Added AUTOSAR Compiler Abstraction </p>
<p>2010-04-30 </p>
<p>1.16.01 </p>
<p>Fixed some editorial errors </p>
<p>2010-07-27 </p>
<p>1.16.02 </p>
<p>Fixed some editorial errors </p>
<p>2010-08-19 </p>
<p>1.17.00 </p>
<p>ESCAN00044693: New callbacks XcpCalibrationWrite and </p>
<p>XcpCalibrationRead </p>
<p>ESCAN00042867: Support Multiple Transport Layers </p>
<p>2010-12-10 </p>
<p>1.18.00 </p>
<p>ESCAN00045981: Add support to read out FR Parameters </p>
<p>2011-07-20 </p>
<p>1.19.00 </p>
<p>ESCAN00049542: Describe IDT_VECTOR_MAPNAMES format in </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>3 / 109 </p>
<p>TechRef </p>
<p>ESCAN00043487: XCP shall support user selectable behaviour of </p>
<p>Send Queue overrun </p>
<p>2011-08-04 </p>
<p> </p>
<p>ESCAN00052564: Adapt ReadCcConfig Parameter to ASR3.2.1 </p>
<p>2012-02-20 </p>
<p>1.19.01 </p>
<p>ESCAN00055214: DAQ Lists can be extended after </p>
<p>START_STOP_SYNCH </p>
<p>2012-09-03 </p>
<p>1.19.02 </p>
<p>ESCAN00061159: Provide an API to detect XCP state and usage </p>
<p>2012-11-08 </p>
<p>1.19.03 </p>
<p>Added Option for AMD Runtime Measurement </p>
<p>2013-02-11 </p>
<p>2.01.01 </p>
<p>Editorial Changes </p>
<p>2013-07-08 </p>
<p>2.02.00 </p>
<p>ESCAN00070127: AR4-322/AR3_2552: Support of Vx1000 </p>
<p>System </p>
<p>ESCAN00070082: The API ApplXcpDaqResumeStore has a </p>
<p>wrong description </p>
<p>ESCAN00068639: Describe data consistency on ODT Level </p>
<p>ESCAN00063969: WRITE_DAQ_MULTIPLE: wrong required </p>
<p>MAX_CTO size </p>
<p>ESCAN00062625: Provide hint how to implement DAQ Timestamp </p>
<p>Callback </p>
<p>ESCAN00067332: Document the usage of the </p>
<p>Xcp_MainFunction/XcpBackground </p>
<p>2013-12-04 </p>
<p>2.03.00 </p>
<p>ESCAN00072401: Support custom CRC Cbk </p>
<p>ESCAN00072326: Support Generic GET_ID </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector’s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p> </p>
<p> </p>
<p><b>Note for XCP Basic </b></p>
<p>Please note, that the demo and example programs only show special aspects of the </p>
<p>software. With regard to the fact that these programs are meant for demonstration </p>
<p>purposes only, Vector Informatik’s liability shall be expressly excluded in cases of </p>
<p>ordinary negligence, to the extent admissible by law or statute. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>4 / 109 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>History ........................................................................................................................... 2</b></p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Overview ..................................................................................................................... 10</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Abbreviations and Items used in this paper ...................................................... 10</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Naming Conventions ........................................................................................ 12</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 13</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Overview of the Functional Scope .................................................................... 13</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Communication Mode Info ............................................................................... 13</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Block Transfer Communication Model (XCP Professional only) ....................... 13</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Slave Device Identification ............................................................................... 13</p>
<p> </p>
<p>3.4.1</p>
<p> </p>
<p>XCP Station Identifier ....................................................................... 13</p>
<p> </p>
<p>3.4.2</p>
<p> </p>
<p>Transferring of XCP MAP Filenames ................................................ 14</p>
<p> </p>
<p>3.4.3</p>
<p> </p>
<p>Identification of FlexRay Parameters ................................................ 14</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Seed &amp; Key ...................................................................................................... 14</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Checksum Calculation ..................................................................................... 16</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>Memory Protection (XCP Professional only) .................................................... 17</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>Memory Access by Application ......................................................................... 17</p>
<p> </p>
<p>3.9</p>
<p> </p>
<p>Event Codes .................................................................................................... 17</p>
<p> </p>
<p>3.10</p>
<p> </p>
<p>Service Request Messages (XCP Professional only) ....................................... 18</p>
<p> </p>
<p>3.11</p>
<p> </p>
<p>User Defined Command ................................................................................... 18</p>
<p> </p>
<p>3.12</p>
<p> </p>
<p>Transport Layer Command .............................................................................. 18</p>
<p> </p>
<p>3.13</p>
<p> </p>
<p>Synchronous Data Transfer ............................................................................. 19</p>
<p> </p>
<p>3.13.1</p>
<p> </p>
<p>Synchronous Data Acquisition (DAQ) ............................................... 19</p>
<p> </p>
<p>3.13.2</p>
<p> </p>
<p>DAQ Timestamp ............................................................................... 19</p>
<p> </p>
<p>3.13.3</p>
<p> </p>
<p>Power-Up Data Transfer (XCP Professional only) ............................ 20</p>
<p> </p>
<p>3.13.4</p>
<p> </p>
<p>Send Queue ..................................................................................... 20</p>
<p> </p>
<p>3.13.5</p>
<p> </p>
<p>Data Stimulation (STIM) (XCP Professional only)............................. 21</p>
<p> </p>
<p>3.13.6</p>
<p> </p>
<p>Bypassing (XCP Professional only) .................................................. 21</p>
<p> </p>
<p>3.13.7</p>
<p> </p>
<p>Data Acquisition Plug &amp; Play Mechanisms ....................................... 21</p>
<p> </p>
<p>3.13.8</p>
<p> </p>
<p>Event Channel Plug &amp; Play Mechanism ........................................... 21</p>
<p> </p>
<p>3.13.9</p>
<p> </p>
<p>Data consistency .............................................................................. 22</p>
<p> </p>
<p>3.14</p>
<p> </p>
<p>The Online Data Calibration Model .................................................................. 22</p>
<p> </p>
<p>3.14.1</p>
<p> </p>
<p>Page Switching ................................................................................ 22</p>
<p> </p>
<p>3.14.2</p>
<p> </p>
<p>Page Switching Plug &amp; Play Mechanism .......................................... 23</p>
<p> </p>
<p>3.14.3</p>
<p> </p>
<p>Calibration Data Page Copying ........................................................ 23</p>
<p> </p>
<p>3.14.4</p>
<p> </p>
<p>Freeze Mode Handling ..................................................................... 23</p>
<p> </p>
<p>3.15</p>
<p> </p>
<p>Flash Programming (XCP Professional only) ................................................... 23</p>
<p> </p>
<p>3.15.1</p>
<p> </p>
<p>Flash Programming by the ECU’s Application .................................. 23</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>5 / 109 </p>
<p>3.15.2</p>
<p> </p>
<p>Flash Programming with a Flash Kernel ........................................... 24</p>
<p> </p>
<p>3.15.3</p>
<p> </p>
<p>Flash Programming Write Protection ................................................ 25</p>
<p> </p>
<p>3.16</p>
<p> </p>
<p>EEPROM Access (XCP Professional only) ....................................................... 25</p>
<p> </p>
<p>3.17</p>
<p> </p>
<p>Parameter Check ............................................................................................. 25</p>
<p> </p>
<p>3.18</p>
<p> </p>
<p>Performance Optimizations .............................................................................. 26</p>
<p> </p>
<p>3.19</p>
<p> </p>
<p>Interrupt Locks / Exclusive Areas ..................................................................... 26</p>
<p> </p>
<p>3.20</p>
<p> </p>
<p>Accessing internal data .................................................................................... 26</p>
<p> </p>
<p>3.21</p>
<p> </p>
<p>En- / Disabling the XCP module ....................................................................... 27</p>
<p> </p>
<p>3.22</p>
<p> </p>
<p>XCP measurement during the follow up time ................................................... 27</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Integration into the Application ................................................................................. 28</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Files of XCP Professional ................................................................................ 28</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Files of XCP Basic ........................................................................................... 28</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Version changes .............................................................................................. 29</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Integration of XCP into the Application ............................................................. 29</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>Integration of XCP on CAN (XCP Professional only) ........................ 29</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>Integration with a Proprietary XCP Transport Layer .......................... 30</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>Motorola HC12 with CAN Transport Layer ....................................... 32</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping ..................................................... 32</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>Support of Vx1000 Integration.......................................................................... 32</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Feature List ................................................................................................................. 33</b></p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Description of the API ................................................................................................ 35</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Version of the Source Code ............................................................................. 35</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>XCP Services called by the Application ............................................................ 36</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>XcpInitMemory: Initialization of the XCP Protocol Layer Memory ..... 36</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>XcpInit: Initialization of the XCP Protocol Layer ................................ 36</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>XcpEvent: Handling of a data acquisition event channel .................. 37</p>
<p> </p>
<p>6.2.4</p>
<p> </p>
<p>XcpStimEventStatus: Check data stimulation events ....................... 38</p>
<p> </p>
<p>6.2.5</p>
<p> </p>
<p>XcpBackground: Background calculation of checksum .................... 38</p>
<p> </p>
<p>6.2.6</p>
<p> </p>
<p>XcpSendEvent: Transmission of event codes................................... 39</p>
<p> </p>
<p>6.2.7</p>
<p> </p>
<p>XcpPutchar: Put a char into a service request packet ...................... 39</p>
<p> </p>
<p>6.2.8</p>
<p> </p>
<p>XcpPrint: Transmission of a service request packet ......................... 40</p>
<p> </p>
<p>6.2.9</p>
<p> </p>
<p>XcpDisconnect: Disconnect from XCP master .................................. 40</p>
<p> </p>
<p>6.2.10</p>
<p> </p>
<p>XcpSendCrm: Transmit response or error packet ............................. 41</p>
<p> </p>
<p>6.2.11</p>
<p> </p>
<p>XcpGetXcpDataPointer: Request internal data pointer ..................... 42</p>
<p> </p>
<p>6.2.12</p>
<p> </p>
<p>XcpControl: En- / Disable the XCP module ...................................... 42</p>
<p> </p>
<p>6.2.13</p>
<p> </p>
<p>XcpGetVersionInfo: Request module version information ................. 43</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>XCP Protocol Layer Functions, called by the XCP Transport Layer .................. 43</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>6 / 109 </p>
<p>6.3.1</p>
<p> </p>
<p>XcpCommand: Evaluation of XCP packets and command </p>
<p>interpreter ........................................................................................ 44</p>
<p> </p>
<p>6.3.2</p>
<p> </p>
<p>XcpSendCallBack: Confirmation of the successful transmission of </p>
<p>a XCP packet ................................................................................... 44</p>
<p> </p>
<p>6.3.3</p>
<p> </p>
<p>XcpGetSessionStatus: Get session state of XCP ............................. 45</p>
<p> </p>
<p>6.3.4</p>
<p> </p>
<p>XcpSetActiveTl: Set the active Transport Layer ................................ 46</p>
<p> </p>
<p>6.3.5</p>
<p> </p>
<p>XcpGetActiveTl: Set the active Transport Layer ............................... 46</p>
<p> </p>
<p>6.4</p>
<p> </p>
<p>XCP Transport Layer Services called by the XCP Protocol Layer .................... 47</p>
<p> </p>
<p>6.4.1</p>
<p> </p>
<p>&lt;Bus&gt;XcpSend: Request for the transmission of a DTO or CTO </p>
<p>message .......................................................................................... 47</p>
<p> </p>
<p>6.4.2</p>
<p> </p>
<p>&lt;Bus&gt;XcpSendFlush: Flush transmit buffer ..................................... 47</p>
<p> </p>
<p>6.4.3</p>
<p> </p>
<p>ApplXcpInterruptEnable: Enable interrupts ....................................... 48</p>
<p> </p>
<p>6.4.4</p>
<p> </p>
<p>ApplXcpInterruptDisable: Disable interrupts ..................................... 49</p>
<p> </p>
<p>6.4.5</p>
<p> </p>
<p>&lt;Bus&gt;XcpTLService: Transport Layer specific commands ............... 49</p>
<p> </p>
<p>6.5</p>
<p> </p>
<p>Application Services called by the XCP Protocol Layer .................................... 50</p>
<p> </p>
<p>6.5.1</p>
<p> </p>
<p>ApplXcpGetPointer: Pointer conversion ........................................... 50</p>
<p> </p>
<p>6.5.2</p>
<p> </p>
<p>ApplXcpGetIdData: Get MAP filenames ........................................... 51</p>
<p> </p>
<p>6.5.3</p>
<p> </p>
<p>ApplXcpGetSeed: Generate a seed ................................................. 51</p>
<p> </p>
<p>6.5.4</p>
<p> </p>
<p>ApplXcpUnlock: Valid key and unlock resource ................................ 52</p>
<p> </p>
<p>6.5.5</p>
<p> </p>
<p>ApplXcpCheckReadEEPROM: Check read access from EEPROM . 53</p>
<p> </p>
<p>6.5.6</p>
<p> </p>
<p>ApplXcpCheckWriteEEPROM: Check write access to the </p>
<p>EEPROM ......................................................................................... 53</p>
<p> </p>
<p>6.5.7</p>
<p> </p>
<p>ApplXcpCheckWriteAccess: Check address for valid write access ... 54</p>
<p> </p>
<p>6.5.8</p>
<p> </p>
<p>ApplXcpCheckReadAccess: Check address for valid read access ... 55</p>
<p> </p>
<p>6.5.9</p>
<p> </p>
<p>ApplXcpCheckDAQAccess: Check address for valid read or write </p>
<p>access.............................................................................................. 55</p>
<p> </p>
<p>6.5.10</p>
<p> </p>
<p>ApplXcpCheckProgramAccess: Check address for valid write </p>
<p>access.............................................................................................. 56</p>
<p> </p>
<p>6.5.11</p>
<p> </p>
<p>ApplXcpUserService: User defined command .................................. 57</p>
<p> </p>
<p>6.5.12</p>
<p> </p>
<p>ApplXcpOpenCmdIf: XCP command extension interface ................. 57</p>
<p> </p>
<p>6.5.13</p>
<p> </p>
<p>ApplXcpSendStall: Resolve a transmit stall condition ....................... 58</p>
<p> </p>
<p>6.5.14</p>
<p> </p>
<p>ApplXcpDisableNormalOperation: Disable normal operation of the </p>
<p>ECU ................................................................................................. 58</p>
<p> </p>
<p>6.5.15</p>
<p> </p>
<p>ApplXcpStartBootLoader: Start of boot loader .................................. 59</p>
<p> </p>
<p>6.5.16</p>
<p> </p>
<p>ApplXcpReset: Perform ECU reset .................................................. 59</p>
<p> </p>
<p>6.5.17</p>
<p> </p>
<p>ApplXcpProgramStart: Prepare flash programming .......................... 60</p>
<p> </p>
<p>6.5.18</p>
<p> </p>
<p>ApplXcpFlashClear: Clear flash memory .......................................... 60</p>
<p> </p>
<p>6.5.19</p>
<p> </p>
<p>ApplXcpFlashProgram: Program flash memory ................................ 61</p>
<p> </p>
<p>6.5.20</p>
<p> </p>
<p>ApplXcpDaqResume: Resume automatic data transfer .................... 62</p>
<p> </p>
<p>6.5.21</p>
<p> </p>
<p>ApplXcpDaqResumeStore: Store DAQ lists for resume mode .......... 62</p>
<p> </p>
<p>6.5.22</p>
<p> </p>
<p>ApplXcpDaqResumeClear: Clear stored DAQ lists .......................... 63</p>
<p> </p>
<p>6.5.23</p>
<p> </p>
<p>ApplXcpCalResumeStore: Store Calibration data for resume mode . 63</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>7 / 109 </p>
<p>6.5.24</p>
<p> </p>
<p>ApplXcpGetTimestamp: Returns the current timestamp ................... 64</p>
<p> </p>
<p>6.5.25</p>
<p> </p>
<p>ApplXcpGetCalPage: Get calibration page ....................................... 64</p>
<p> </p>
<p>6.5.26</p>
<p> </p>
<p>ApplXcpSetCalPage: Set calibration page ....................................... 65</p>
<p> </p>
<p>6.5.27</p>
<p> </p>
<p>ApplXcpCopyCalPage: Copying of calibration data pages ............... 66</p>
<p> </p>
<p>6.5.28</p>
<p> </p>
<p>ApplXcpSetFreezeMode: Setting the freeze mode of a segment...... 67</p>
<p> </p>
<p>6.5.29</p>
<p> </p>
<p>ApplXcpGetFreezeMode: Reading the freeze mode of a segment ... 67</p>
<p> </p>
<p>6.5.30</p>
<p> </p>
<p>ApplXcpRead: Read a single byte from memory .............................. 68</p>
<p> </p>
<p>6.5.31</p>
<p> </p>
<p>ApplXcpWrite: Write a single byte to RAM ........................................ 68</p>
<p> </p>
<p>6.5.32</p>
<p> </p>
<p>ApplXcpCalibrationRead: Read multiple bytes from memory ........... 69</p>
<p> </p>
<p>6.5.33</p>
<p> </p>
<p>ApplXcpCalibrationWrite: Write multiple bytes to memory ................ 69</p>
<p> </p>
<p>6.6</p>
<p> </p>
<p>XCP Protocol Layer Functions that can be overwritten ..................................... 71</p>
<p> </p>
<p>6.6.1</p>
<p> </p>
<p>XcpMemCpy: Copying of a memory range ....................................... 71</p>
<p> </p>
<p>6.6.2</p>
<p> </p>
<p>XcpMemSet: Initialization of a memory range .................................. 72</p>
<p> </p>
<p>6.6.3</p>
<p> </p>
<p>XcpMemClr: Clear a memory range ................................................. 72</p>
<p> </p>
<p>6.6.4</p>
<p> </p>
<p>XcpSendDto: Transmission of a data transfer object ........................ 73</p>
<p> </p>
<p>6.7</p>
<p> </p>
<p>AUTOSAR CRC Module Services called by the XCP Protocol Layer (XCP </p>
<p>Professional Only) ............................................................................................ 73</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Configuration of the XCP Protocol Layer .................................................................. 75</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Configuration with GENy (XCP Professional only) ........................................... 75</p>
<p> </p>
<p>7.1.1</p>
<p> </p>
<p>Component Selection ....................................................................... 75</p>
<p> </p>
<p>7.1.2</p>
<p> </p>
<p>Component Configuration ................................................................ 76</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Configuration without Generation Tool ............................................................. 88</p>
<p> </p>
<p>7.2.1</p>
<p> </p>
<p>Compiler Switches ........................................................................... 88</p>
<p> </p>
<p>7.2.2</p>
<p> </p>
<p>Configuration of Constant Definitions ............................................... 92</p>
<p> </p>
<p>7.2.3</p>
<p> </p>
<p>Configuration of the CPU Type ......................................................... 93</p>
<p> </p>
<p>7.2.4</p>
<p> </p>
<p>Configuration of Slave Device Identification ..................................... 94</p>
<p> </p>
<p>7.2.5</p>
<p> </p>
<p>Configuration of the Event Channel Plug &amp; Play Mechanism ........... 95</p>
<p> </p>
<p>7.2.6</p>
<p> </p>
<p>Configuration of the DAQ Time Stamped Mode ................................ 97</p>
<p> </p>
<p>7.2.7</p>
<p> </p>
<p>Configuration of the Flash Programming Plug &amp; Play Mechanism .... 97</p>
<p> </p>
<p>7.2.8</p>
<p> </p>
<p>Configuration of the Page Switching Plug &amp; Play Mechanism .......... 98</p>
<p> </p>
<p>7.2.9</p>
<p> </p>
<p>Configuration of the used Transport Layer ....................................... 98</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Resource Requirements........................................................................................... 100</b></p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Limitations ................................................................................................................ 101</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>General Limitations ........................................................................................ 101</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>Limitations of XCP Basic ................................................................................ 102</p>
<p> </p>
<p>9.3</p>
<p> </p>
<p>Limitations Regarding Platforms, Compilers and Memory Models .................. 103</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>FAQ ............................................................................................................................ 104</b></p>
<p> </p>
<p>10.1</p>
<p> </p>
<p>Connection to MCS Not Possible ................................................................... 104</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>8 / 109 </p>
<p>10.2</p>
<p> </p>
<p>Invalid Time Stamp Unit ................................................................................. 104</p>
<p> </p>
<p>10.3</p>
<p> </p>
<p>Support of small and medium memory model ................................................ 105</p>
<p> </p>
<p>10.4</p>
<p> </p>
<p>Small memory model on ST10 / XC16X / C16X with Tasking Compiler .......... 105</p>
<p> </p>
<p>10.5</p>
<p> </p>
<p>Data Page Banking on Star12X / Metrowerks ................................................ 106</p>
<p> </p>
<p>10.6</p>
<p> </p>
<p>Memory model banked on Star12X / Cosmic ................................................. 106</p>
<p> </p>
<p>10.7</p>
<p> </p>
<p>Reflected CRC16 CCITT Checksum Calculation Algorithm ............................ 107</p>
<p> </p>
<p><b>11</b></p>
<p> </p>
<p><b>Bibliography .............................................................................................................. 108</b></p>
<p> </p>
<p><b>12</b></p>
<p> </p>
<p><b>Contact ...................................................................................................................... 109</b></p>
<p> </p>
<p><i><b> </b></i></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>9 / 109 </p>
<p><b>Illustrations </b></p>
<p>Figure 4-1</p>
<p> </p>
<p>Integration of XCP on CAN into the application ......................................... 29</p>
<p> </p>
<p>Figure 4-2</p>
<p> </p>
<p>Integration of XCP with a proprietary XCP Transport Layer ...................... 30</p>
<p> </p>
<p>Figure 7-1</p>
<p> </p>
<p>Component selection in GENy .................................................................. 75</p>
<p> </p>
<p>Figure 7-2</p>
<p> </p>
<p>Component configuration – General settings ............................................ 76</p>
<p> </p>
<p>Figure 7-3</p>
<p> </p>
<p>Component configuration – Synchronous Data Acquisition ....................... 79</p>
<p> </p>
<p>Figure 7-4</p>
<p> </p>
<p>Component configuration – Standard Commands .................................... 82</p>
<p> </p>
<p>Figure 7-5</p>
<p> </p>
<p>Component configuration – Checksum ..................................................... 84</p>
<p> </p>
<p>Figure 7-6</p>
<p> </p>
<p>Component configuration – Page Switching ............................................. 85</p>
<p> </p>
<p>Figure 7-7</p>
<p> </p>
<p>Component configuration – Programming ................................................. 86</p>
<p> </p>
<p>Figure 7-8</p>
<p> </p>
<p>Component configuration – FlexRay Parameter ....................................... 87</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>10 / 109 </p>
<p><b>2 </b></p>
<p><b>Overview </b></p>
<p>This  document  describes  the  features,  API,  configuration  and  integration  of  the  XCP </p>
<p>Protocol Layer. Both XCP versions: XCP Professional and XCP Basic are covered by this </p>
<p>document. Chapters that are only relevant for XCP Professional are marked. </p>
<p>This document does not cover the XCP Transport Layers for CAN, FlexRay and LIN, which </p>
<p>are available at Vector Informatik.  </p>
<p>Please refer to [IV] for further information about XCP on CAN and the integration of XCP </p>
<p>on CAN with the Vector CANbedded software components. Further information about XCP </p>
<p>on  FlexRay  Transport  Layer  and  XCP  on  LIN  Transport  Layer  can  be  found  in  its </p>
<p>documentation. </p>
<p>Please </p>
<p>also </p>
<p>refer </p>
<p>to </p>
<p>“The </p>
<p>Universal </p>
<p>Measurement </p>
<p>and </p>
<p>Calibration </p>
<p>Protocol </p>
<p>Family” </p>
<p>specification by ASAM e.V. </p>
<p>The XCP Protocol Layer is a hardware independent protocol that can be ported to almost </p>
<p>any  hardware.  Due  to  there  are  numerous  combinations  of  micro  controllers,  compilers </p>
<p>and memory models it cannot be guaranteed that it will run properly on any of the above </p>
<p>mentioned combinations. </p>
<p>Please  note  that  in  this  document  the  term Application  is  not  used  strictly  for  the  user </p>
<p>software but also for any higher software layer, like e.g. a Communication Control Layer. </p>
<p>Therefore, Application refers to any of the software components using XCP. </p>
<p>The API of the functions is described in a separate chapter at the end of this document. </p>
<p>Referred functions are always shown in the single channel mode.  </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>The source code of the XCP Protocol Layer, configuration examples and </p>
<p>documentation are available on the Internet at www.vector-informatik.de in a </p>
<p>functional restricted form. </p>
<p> </p>
<p><b>2.1 </b></p>
<p><b>Abbreviations and Items used in this paper </b></p>
<p> </p>
<p><b>Abbreviations </b></p>
<p><b>Complete expression </b></p>
<p><b>A2L </b></p>
<p>File Extension for an <b>A</b>SAM <b>2</b>MC <b>L</b>anguage File </p>
<p><b>AML </b></p>
<p><b>A</b>SAM 2 <b>M</b>eta <b>L</b>anguage </p>
<p><b>API </b></p>
<p><b>A</b>pplication <b>P</b>rogramming <b>I</b>nterface </p>
<p><b>ASAM </b></p>
<p><b>A</b>ssociation for <b>S</b>tandardization of <b>A</b>utomation and <b>M</b>easuring Systems </p>
<p><b>BYP </b></p>
<p><b>BYP</b>assing </p>
<p><b>CAN </b></p>
<p><b>C</b>ontroller <b>A</b>rea <b>N</b>etwork </p>
<p><b>CAL </b></p>
<p><b>CAL</b>ibration </p>
<p><b>CANape </b></p>
<p>Calibration </p>
<p>and </p>
<p>Measurement </p>
<p>Data  Acquisition </p>
<p>for </p>
<p>Electronic </p>
<p>Control </p>
<p>Systems </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>11 / 109 </p>
<p><b>CMD </b></p>
<p><b>C</b>o<b>m</b>man<b>d </b></p>
<p><b>CTO </b></p>
<p><b>C</b>ommand <b>T</b>ransfer <b>O</b>bject </p>
<p><b>DAQ </b></p>
<p>Synchronous <b>D</b>ata <b>A</b>c<b>q</b>uistion </p>
<p><b>DLC </b></p>
<p><b>D</b>ata <b>L</b>ength <b>C</b>ode ( Number of data bytes of a CAN message ) </p>
<p><b>DLL </b></p>
<p><b>D</b>ata <b>l</b>ink <b>l</b>ayer </p>
<p><b>DTO </b></p>
<p><b>D</b>ata <b>T</b>ransfer <b>O</b>bject </p>
<p><b>ECU </b></p>
<p><b>E</b>lectronic <b>C</b>ontrol <b>U</b>nit </p>
<p><b>ERR </b></p>
<p><b>Err</b>or Packet </p>
<p><b>EV </b></p>
<p><b>Ev</b>ent packet </p>
<p><b>ID </b></p>
<p><b>Id</b>entifier (of a CAN message) </p>
<p><b>Identifier </b></p>
<p>Identifies a CAN message </p>
<p><b>ISR </b></p>
<p><b>I</b>nterrupt <b>S</b>ervice <b>R</b>outine </p>
<p><b>MCS </b></p>
<p><b>M</b>aster <b>C</b>alibration <b>S</b>ystem </p>
<p><b>Message </b></p>
<p>One or more signals are assigned to each message. </p>
<p><b>ODT </b></p>
<p><b>O</b>bject <b>D</b>escriptor <b>T</b>able </p>
<p><b>OEM </b></p>
<p><b>O</b>riginal <b>e</b>quipment <b>m</b>anufacturer (vehicle manufacturer) </p>
<p><b>PAG </b></p>
<p><b>PAG</b>ing </p>
<p><b>PID </b></p>
<p><b>P</b>acket <b>Id</b>entifier </p>
<p><b>PGM </b></p>
<p><b>P</b>ro<b>g</b>ra<b>m</b>ming </p>
<p><b>RAM </b></p>
<p><b>R</b>andom <b>A</b>ccess <b>M</b>emory </p>
<p><b>RES </b></p>
<p>Command <b>Res</b>ponse Packet </p>
<p><b>ROM </b></p>
<p><b>R</b>ead <b>O</b>nly <b>M</b>emory </p>
<p><b>SERV </b></p>
<p><b>Ser</b>vice Request Packet </p>
<p><b>STIM </b></p>
<p><b>Stim</b>ulation </p>
<p><b>TCP/IP </b></p>
<p><b>T</b>ransfer <b>C</b>ontrol <b>P</b>rotocol / <b>I</b>nternet <b>P</b>rotocol </p>
<p><b>UDP/IP </b></p>
<p><b>U</b>nified <b>D</b>ata <b>P</b>rotocol / <b>I</b>nternet <b>P</b>rotocol </p>
<p><b>USB </b></p>
<p><b>U</b>niversal <b>S</b>erial <b>B</b>us </p>
<p><b>XCP </b></p>
<p>Universal Measurement and <b>C</b>alibration <b>P</b>rotocol </p>
<p><b>VI </b></p>
<p><b>V</b>ector <b>I</b>nformatik GmbH </p>
<p> </p>
<p>Also refer to ‘AN-AND-1-108 Glossary of CAN Protocol Terminology.pdf’, which can be </p>
<p>found in the download area of http://www.vector-informatik.de. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>12 / 109 </p>
<p><b>2.2 </b></p>
<p><b>Naming Conventions </b></p>
<p>The names of the access functions provided by the XCP Protocol Layer always start with a </p>
<p>prefix  that  includes  the  characters </p>
<p>Xcp</p>
<p>.  The  characters </p>
<p>Xcp</p>
<p>  are  surrounded  by  an </p>
<p>abbreviation which refers to the service or to the layer which requests a XCP service. The </p>
<p>designation of the main services is listed below: </p>
<p> </p>
<p><b>Naming conventions </b></p>
<p>Xcp</p>
<p>… </p>
<p>It is mandatory to use all functions beginning with Xcp… </p>
<p>These services are called by either the data link layer or the application. </p>
<p>They are e.g. used for the initialization of the XCP Protocol Layer and for the </p>
<p>cyclic background task. </p>
<p>ApplXcp</p>
<p>... </p>
<p>The  functions,  starting  with </p>
<p>ApplXcp</p>
<p>…  are  functions  that  are  provided </p>
<p>either by any XCP Transport Layer or the application and are called by the </p>
<p>XCP Protocol Layer. </p>
<p>These services are user callback functions that are application specific and have </p>
<p>to be implemented depending on the application. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>13 / 109 </p>
<p><b>3 </b></p>
<p><b>Functional Description </b></p>
<p><b>3.1 </b></p>
<p><b>Overview of the Functional Scope </b></p>
<p>The  Universal  Measurement </p>
<p>and  Calibration  Protocol  (XCP)  is  standardized  by  the </p>
<p>European ASAM  working  committee  for  standardization  of  interfaces  used  in  calibration </p>
<p>and measurement data acquisition. XCP is a higher level protocol used for communication </p>
<p>between  a  measurement  and  calibration  system  (MCS,  i.e.  CANape)  and  an  electronic </p>
<p>control unit (ECU). </p>
<p><b>3.2 </b></p>
<p><b>Communication Mode Info </b></p>
<p>In order to gather information about the XCP Slave device, e.g. the implementation version </p>
<p>number </p>
<p>of </p>
<p>the </p>
<p>XCP </p>
<p>Protocol </p>
<p>Layer </p>
<p>and </p>
<p>supported </p>
<p>communications </p>
<p>models, </p>
<p>the </p>
<p>communication mode info can be enabled by the switch </p>
<p>XCP_ENABLE_COMM_MODE_INFO</p>
<p>. </p>
<p><b>3.3 </b></p>
<p><b>Block Transfer Communication Model (XCP Professional only) </b></p>
<p>In  the  standard  communication  model,  each  request  packet  is  responded  by  a  single </p>
<p>response packet or an error packet. To speed up memory uploads, downloads and flash </p>
<p>programming  the  XCP  commands  UPLOAD,  DOWNLOAD  and  PROGRAM  support  a </p>
<p>block transfer mode similar to ISO/DIS 15765-2. </p>
<p>In  the  Master  Block  Transfer  Mode  can  the  master  transmit  subsequent  (up  to  the </p>
<p>maximum block size MAX_BS) request packets to the slave without getting any response </p>
<p>in between. The slave responds after transmission of the last request packet of the block. </p>
<p>In Slave Block Transfer Mode the slave can respond subsequent (there is no limitation) to </p>
<p>a request without additional requests in between. </p>
<p>Refer to chapter 7.2.1 for configuration details. </p>
<p><b>3.4 </b></p>
<p><b>Slave Device Identification </b></p>
<p><b>3.4.1 </b></p>
<p><b>XCP Station Identifier </b></p>
<p>The  XCP  station  identifier  is  an ASCII  string  that  identifies  the  ECU’s  software  program </p>
<p>version. </p>
<p>The  MCS  can  interpret  this  identifier  as  file  name  for  the  ECU  database.  The  ECU </p>
<p>developer should change the XCP station identifier with each program change. This will </p>
<p>prevent database mix-ups and grant the correct access of measurement and calibration </p>
<p>objects  from  the  MCS  to  the  ECU.  Another  benefit  of  the  usage  of  the  XCP  station </p>
<p>identifier is the automatic assignment of the correct ECU database at program start of the </p>
<p>MCS via the plug &amp; play mechanism. The plug &amp; play mechanism prevents the user from </p>
<p>selecting the wrong ECU database. </p>
<p>Refer </p>
<p>to </p>
<p>chapter </p>
<p>7.2.4.1 </p>
<p>(Identification </p>
<p>by </p>
<p>ASAM-MC2 </p>
<p>Filename </p>
<p>without </p>
<p>Path </p>
<p>and </p>
<p>Extension) for configuration details. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>14 / 109 </p>
<p><b>3.4.2 </b></p>
<p><b>XCP Generic Identification </b></p>
<p>The XCP provides a generic mechanism for identification by the GET_ID command. For </p>
<p>this  purpose  a  call-back  exist  which  can  be  implemented  by  the  user  to  provide  the </p>
<p>requested information. The following function  </p>
<p>uint32 <b>ApplXcpGetIdData</b>( MTABYTEPTR *pData, uint8 id )</p>
<p> </p>
<p>(6.5.2)</p>
<p> </p>
<p>has to set a pointer to the identification information based on the requested id and return </p>
<p>the length of this information. </p>
<p>Refer to chapter 7.2.4.2 for an example implementation. </p>
<p> </p>
<p><b>3.4.3 </b></p>
<p><b>Identification of FlexRay Parameters </b></p>
<p>If the “Virtual FlexRay Parameters” feature is enabled, the parameters can be read out in a </p>
<p>platform independent way. They will be provided as virtual measurement values that can </p>
<p>be read at fixed memory locations with a configurable Address Extension. </p>
<p>To calculate the memory address for each parameter please read the Technical Reference </p>
<p>and the AUTOSAR specification of the FlexRay Driver. Each FlexRay parameter is defined </p>
<p>with a unique ID to be used as parameter for the API call. Use this ID and multiply it with </p>
<p>four to get the address where this variable can be measured at. </p>
<p>If this parameter is enabled the API: </p>
<p> </p>
<p>Std_ReturnType </p>
<p><b>FrIf_ReadCCConfig</b>( </p>
<p>uint8 </p>
<p>ClusterIdx, </p>
<p>uint8 </p>
<p>FrIf_CCLLParamIndex,  P2VAR(uint32,  AUTOMATIC,  FRIF_APPL_DATA) </p>
<p>FrIf_CCLLParamValue )</p>
<p> </p>
<p>will be called. The FlexRay parameters can be measured from CAN and FlexRay but the </p>
<p>API is only provided if the FlexRay Interface is present. </p>
<p><b>3.5 </b></p>
<p><b>Seed &amp; Key </b></p>
<p>The </p>
<p>seed </p>
<p>and </p>
<p>key </p>
<p>feature </p>
<p>allows </p>
<p>individual </p>
<p>access </p>
<p>protection </p>
<p>for </p>
<p>calibration, </p>
<p>flash </p>
<p>programming,  synchronous  data  acquisition  and  data  stimulation.  The  MCS  requests  a </p>
<p>seed  (a  few  data  bytes)  from  the  ECU  and  calculates  a  key  based  on  a  proprietary </p>
<p>algorithm and sends it back to the ECU. </p>
<p>The seed &amp; key functionality can be enabled with the switch </p>
<p>XCP_ENABLE_SEED_KEY</p>
<p> and </p>
<p>disabled </p>
<p>XCP_DISABLE_SEED_KEY</p>
<p> in order to save ROM. Also refer to chapter 7.2.1. </p>
<p>The application callback function </p>
<p>uint8 <b> ApplXcpGetSeed</b>(  MEMORY_ROM  uint8  resourceMask,  BYTEPTR </p>
<p>seed ) </p>
<p>(6.5.3) </p>
<p>returns a seed that is transferred to the MCS. The callback function </p>
<p>uint8 <b> ApplXcpUnlock</b>(  MEMORY_ROM  uint8  *key,  MEMORY_ROM  uint8 </p>
<p>length ) </p>
<p>(6.5.4) </p>
<p>has to verify a received key and if appropriate return the resource that shall be unlocked. </p>
<p>Annotation for the usage of CANape </p>
<p>The calculation of the key is done in a DLL named SEEDKEY1.DLL, which is developed by </p>
<p>the  ECU  manufacturer  and  which  must  be  located  in  the  EXEC  directory  of  CANape. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>15 / 109 </p>
<p>CANape can access the ECU only if the ECU accepts the key. If the key is not valid, the </p>
<p>ECU stays locked. </p>
<p>Example Implementation for SEEDKEY1.DLL </p>
<p>The function call of ASAP1A_XCP_ComputeKeyFromSeed() is standardized by the ASAM </p>
<p>committee. </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p>FILE SEEDKEY1.H </p>
<p>#ifndef _SEEDKEY_H_ </p>
<p> </p>
<p>#define _SEEDKEY_H_ </p>
<p>#ifndef DllImport </p>
<p>#define DllImport  __declspec(dllimport) </p>
<p>#endif </p>
<p>#ifndef DllExport </p>
<p>#define DllExport  __declspec(dllexport) </p>
<p>#endif </p>
<p>#ifdef SEEDKEYAPI_IMPL </p>
<p>#define SEEDKEYAPI DllExport __cdecl </p>
<p>#else </p>
<p>#define SEEDKEYAPI DllImport __cdecl </p>
<p>#endif </p>
<p>#ifdef __cplusplus </p>
<p>extern &quot;C&quot; { </p>
<p>#endif </p>
<p> </p>
<p>BOOL SEEDKEYAPI ASAP1A_XCP_ComputeKeyFromSeed( BYTE *seed, </p>
<p>  unsigned short sizeSeed, </p>
<p>  BYTE *key, </p>
<p>  unsigned short maxSizeKey, </p>
<p>  unsigned short *sizeKey </p>
<p>  ); </p>
<p>#ifdef __cplusplus </p>
<p>} </p>
<p>#endif </p>
<p>#endif </p>
<p> </p>
<p>FILE SEEDKEY1.C </p>
<p>#include &lt;windows.h&gt; </p>
<p>#define SEEDKEYAPI_IMPL </p>
<p>#include &quot;SeedKey1.h&quot; </p>
<p> </p>
<p>extern &quot;C&quot; { </p>
<p>BOOL SEEDKEYAPI ASAP1A_XCP_ComputeKeyFromSeed( BYTE *seed, </p>
<p>  unsigned short sizeSeed, </p>
<p>  BYTE *key, </p>
<p>  unsigned short maxSizeKey, </p>
<p>  unsigned short *sizeKey </p>
<p>  ) </p>
<p>{  // in that example sizeSeed == 4 is expected only </p>
<p>  if( sizeSeed != 4 ) return FALSE; </p>
<p>    if( maxSizeKey &lt; 4 ) return FALSE; </p>
<p>    *((unsigned long*)key) *= 3; </p>
<p>    *((unsigned long*)key) &amp;= 0x55555555; </p>
<p>    *((unsigned long*)key) *= 5;  </p>
<p>    *sizeKey = 4; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>16 / 109 </p>
<p>    return TRUE; </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<p><b>3.6 </b></p>
<p><b>Checksum Calculation </b></p>
<p>The  XCP  Protocol  Layer  supports  calculation  of  a  checksum  over  a  specific  memory </p>
<p>range. The XCP Protocol Layer supports all XCP ADD algorithms and the CRC16CCITT </p>
<p>checksum calculation algorithm. </p>
<p>XCP Professional allows the usage of the AUTOSAR CRC Module [VII]. If the AUTOSAR </p>
<p>CRC Module is used also the XCP CRC32 algorithm can be used. </p>
<p>Also refer to 7.2.2.1 ‘Table of Checksum Calculation Methods’. </p>
<p>If checksum calculation is enabled the background task has to be called cyclically. </p>
<p><b>3.6.1 </b></p>
<p><b>Custom CRC calculation </b></p>
<p>The Protocol Layer also allows the calculation of the CRC by the application. For this the </p>
<p>call-back: </p>
<p>uint8 <b>ApplXcpCalculateChecksum</b>( ROMBYTEPTR pMemArea, BYTEPTR pRes, </p>
<p>uint32 length ) </p>
<p>is  called.  This  call-back  can  either  calculate  the  checksum  synchronously  and  return </p>
<p>XCP_CMD_OK</p>
<p> or it can trigger the calculation and return </p>
<p>XCP_CMD_PENDING</p>
<p> for asynchronous </p>
<p>calculation of the checksum. In every case the response frame has to be assembled. </p>
<p><b>3.7 </b></p>
<p><b>MainFunction </b></p>
<p>The Xcp provides a MainFunction: </p>
<p>void <b>XcpBackground</b>( void )</p>
<p>  </p>
<p>(6.2.5)</p>
<p> </p>
<p> which must be called cyclically and performs the following tasks: </p>
<p></p>
<p> </p>
<p>Checksum  calculation  which  is  done  asynchronously  in  configurable  chunks  to </p>
<p>prevent extensive runtime </p>
<p></p>
<p> </p>
<p>Resume Mode Handling </p>
<p>The XcpBackground is normally called by the SchM. If you use a 3</p>
<p>rd</p>
<p> party SchM you must </p>
<p>configure it accordingly such that the function is called cyclically. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>17 / 109 </p>
<p><b>3.8 </b></p>
<p><b>Memory Protection (XCP Professional only) </b></p>
<p>If </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p> is defined write access of specific RAM areas can </p>
<p>be checked with the function </p>
<p>uint8 <b>ApplXcpCheckWriteAccess</b>( MTABYTEPTR addr, uint8 size )</p>
<p>(6.5.7) </p>
<p>It should only be used, if write protection of memory areas is required. </p>
<p>If </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p> is defined read access of specific RAM areas can be </p>
<p>checked with the function </p>
<p>uint8 <b>ApplXcpCheckReadAccess</b>( MTABYTEPTR addr, uint8 size )</p>
<p> (6.5.8) </p>
<p>It should only be used, if read protection of memory areas is required. </p>
<p>While  the  first  two  functions  are  used  during  polling,  the  following  function  is  used  for </p>
<p>DAQ/STIM access: </p>
<p>uint8 <b>ApplXcpCheckDAQAccess</b>( DAQBYTEPTR addr, uint8 size )</p>
<p> </p>
<p>(6.5.9) </p>
<p>These  functions  can  be  used  to  protect  memory  areas  that  are  not  allowed  to  be </p>
<p>accessed, e.g. memory mapped registers or the xcp memory itself. </p>
<p><b>3.9 </b></p>
<p><b>Memory Access by Application </b></p>
<p>There are two APIs available that allow memory access by application. Those APIs can be </p>
<p>enabled by setting </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL.</p>
<p> Please note that these </p>
<p>API are only used for polling access. DAQ/STIM still uses direct memory access. </p>
<p>uint8 <b> ApplXcpCalibrationWrite</b>(  MTABYTEPTR  addr,  uint8  size, </p>
<p>ROMBYTEPTR data )</p>
<p> </p>
<p>(6.5.33) </p>
<p>uint8 <b> ApplXcpCalibrationRead</b>(  MTABYTEPTR  addr,  uint8  size, </p>
<p>BYTEPTR data )</p>
<p> </p>
<p>(6.5.32) </p>
<p><b>3.10 </b></p>
<p><b>Event Codes </b></p>
<p>The slave device may report events by sending asynchronous event packets (EV), which </p>
<p>contain  event  codes,  to  the  master  device.  The  transmission  is  not  guaranteed  due  to </p>
<p>these event packets are not acknowledged. </p>
<p>The </p>
<p>transmission </p>
<p>of </p>
<p>event </p>
<p>codes </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>XCP_ENBALE_SEND_EVENT</p>
<p>. </p>
<p>The </p>
<p>transmission is done by the service </p>
<p>void <b>XcpSendEvent</b>( uint8 evc, ROMBYTEPTR c, uint8 len )</p>
<p> </p>
<p>(6.2.6) </p>
<p>The event codes can be found in the following table. </p>
<p><b>Event </b></p>
<p><b>Code </b></p>
<p><b>Description </b></p>
<p>EV_RESUME_MODE </p>
<p>0x00</p>
<p> </p>
<p>The slave indicates that it is starting in RESUME mode. </p>
<p>EV_CLEAR_DAQ </p>
<p>0x01</p>
<p> </p>
<p>The slave indicates that the DAQ configuration in non-</p>
<p>volatile memory has been cleared. </p>
<p>EV_STORE_DAQ </p>
<p>0x02</p>
<p> </p>
<p>The slave indicates that the DAQ configuration has been </p>
<p>stored into non-volatile memory. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>18 / 109 </p>
<p>EV_STORE_CAL </p>
<p>0x03</p>
<p> </p>
<p>The slave indicates that the calibration data has been </p>
<p>stored. </p>
<p>EV_CMD_PENDING </p>
<p>0x05</p>
<p> </p>
<p>The slave requests the master to restart the time-out </p>
<p>detection. </p>
<p>EV_DAQ_OVERLOAD </p>
<p>0x06</p>
<p> </p>
<p>The slave indicates an overload situation when </p>
<p>transferring DAQ lists. </p>
<p>EV_SESSION_TERMINATED </p>
<p>0x07</p>
<p> </p>
<p>The slave indicates to the master that it autonomously </p>
<p>decided to disconnect the current XCP session. </p>
<p>EV_USER </p>
<p>0xFE</p>
<p> </p>
<p>User-defined event. </p>
<p>EV_TRANSPORT </p>
<p>0xFF</p>
<p> </p>
<p>Transport layer specific event. </p>
<p> </p>
<p><b>3.11 </b></p>
<p><b>Service Request Messages (XCP Professional only) </b></p>
<p>The slave device may request some action to be performed by the master device. This is </p>
<p>done by the transmission of a Service Request Packet (SERV) that contains the service </p>
<p>request  code.  The  transmission  of  service  request  packets  is  asynchronous  and  not </p>
<p>guaranteed due to these packets are not being acknowledged. </p>
<p>The service request messages can be sent by the following functions </p>
<p>void <b>ApplXcpUserService </b>( ROMBYTEPTR uint8 c )</p>
<p> </p>
<p>(6.2.7) </p>
<p>void <b>ApplXcpPrint </b>( const uint8 *str )</p>
<p> </p>
<p>(6.2.8) </p>
<p>Refer to 7.2.1 for the configuration of the service request message. </p>
<p><b>3.12 </b></p>
<p><b>User Defined Command </b></p>
<p>The  XCP  Protocol  allows  having  a  user  defined  command  with  an  application  specific </p>
<p>functionality. </p>
<p>The </p>
<p>user </p>
<p>defined </p>
<p>command </p>
<p>is </p>
<p>enabled </p>
<p>by </p>
<p>setting </p>
<p>XCP_ENABLE_USER_COMMAND</p>
<p>  and  upon  reception  of  the  user  command  the  following </p>
<p>callback function is called by the XCP command processor: </p>
<p>uint8 <b>ApplXcpUserService </b>( ROMBYTEPTR pCmd )</p>
<p> </p>
<p>(6.5.11) </p>
<p> </p>
<p><b>3.13 </b></p>
<p><b>Transport Layer Command </b></p>
<p>The transport layer commands are received by the XCP Protocol Layer and processed by </p>
<p>the XCP Transport Layer. The XCP Protocol Layer transmits the XCP response packets </p>
<p>(RES) or XCP error packets (ERR).  </p>
<p>The transport layer command is enabled by setting </p>
<p>XCP_ENABLE_TL_COMMAND</p>
<p>. </p>
<p> </p>
<p>Upon reception of any transport layer command the following callback function is called by </p>
<p>the XCP command processor: </p>
<p>uint8 <b>&lt;Bus&gt;XcpTLService </b>( ROMBYTEPTR pCmd )</p>
<p> </p>
<p>(6.4.5) </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>19 / 109 </p>
<p><b>3.14 </b></p>
<p><b>Synchronous Data Transfer </b></p>
<p><b>3.14.1 </b></p>
<p><b>Synchronous Data Acquisition (DAQ) </b></p>
<p>The </p>
<p>synchronous </p>
<p>data </p>
<p>transfer </p>
<p>can </p>
<p>be </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>compiler </p>
<p>switch </p>
<p>XCP_ENABLE_DAQ</p>
<p>. In this mode, the MCS configures tables of memory addresses in the </p>
<p>XCP Protocol Layer. These tables contain pointers to measurement objects, which have </p>
<p>been  configured  previously  for  the  measurement  in  the  MCS.  Each  configured  table  is </p>
<p>assigned to an event channel. </p>
<p>The  function </p>
<p>XcpEvent(x)</p>
<p>  has  to  be  called  cyclically  for  each  event  channel  with  the </p>
<p>corresponding  event  channel  number  as  parameter.  The  application  has  to  ensure  that </p>
<p>XcpEvent</p>
<p> is called with the correct cycle time, which is defined in the MCS. Note that the </p>
<p>event channel numbers  are given by the Configuration Tool when the Event Info feature is </p>
<p>used. </p>
<p>The  ECU  automatically  transmits  the  current  value  of  the  measurement  objects  via </p>
<p>messages to the MCS, when the function </p>
<p>XcpEvent</p>
<p> is executed in the ECU’s code with </p>
<p>the corresponding event channel number. This means that the data can be transmitted at </p>
<p>any particular point of the ECU code when the data values are valid. </p>
<p>The data acquisition mode can be used in multiple configurations that are described within </p>
<p>the next chapters. </p>
<p>Annotation for the usage of CANape </p>
<p>It is recommended to enable both data acquisition plug &amp; play mechanisms to detect the </p>
<p>DAQ settings. </p>
<p><b>3.14.2 </b></p>
<p><b>DAQ Timestamp </b></p>
<p>There are two methods to generate timestamps for data acquisition signals. </p>
<p>1. By the MCS tool on reception of the message </p>
<p>2. By the ECU (XCP slave) </p>
<p>The time precision of the MCS tool is adequate for the most applications; however, some </p>
<p>applications  like  the  monitoring  of  the  OSEK  operating  system </p>
<p>or  measurement  on </p>
<p>FlexRay  with  an  event  cycle  time  smaller  than  the  FlexRay  cycle  time  require  higher </p>
<p>precision timestamps. In such cases, ECU generated timestamps are recommended. </p>
<p>The timestamp must be implemented in a call-back which returns the current value: </p>
<p>XcpDaqTimestampType <b>ApplXcpGetTimestamp </b>( void )</p>
<p>                           (6.5.24) </p>
<p>There are several possibilities to implement such a timestamp: </p>
<p></p>
<p> </p>
<p>16bit Counter variable, incremented by software in a fast task (.e.g. 1ms task) for </p>
<p>applications </p>
<p>where </p>
<p>such </p>
<p>a </p>
<p>resolution </p>
<p>is </p>
<p>sufficient </p>
<p>and </p>
<p>returned </p>
<p>in </p>
<p>the </p>
<p>above </p>
<p>mentioned call-back </p>
<p></p>
<p> </p>
<p>32bit General Purpose Timer of the used µC, configured to a certain repetition rate </p>
<p>(e.g. 1µs increment) for applications that require a high resolution of the timestamp </p>
<p>and returned in the above mentioned call-back </p>
<p>The resolution and increment value of this timer must be configured in the  configuration </p>
<p>Tool (e.g. GENy) accordingly, see 7.1.2.2. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>20 / 109 </p>
<p>For the configuration of the DAQ time stamped mode refer to chapter 7.2.6 (Configuration </p>
<p>of the DAQ Time Stamped Mode). </p>
<p><b>3.14.3 </b></p>
<p><b>Power-Up Data Transfer (XCP Professional only) </b></p>
<p>Power-up data transfer (also called resume mode) allows automatic data transfer (DAQ, </p>
<p>STIM) </p>
<p>of </p>
<p>the </p>
<p>slave </p>
<p>directly </p>
<p>after </p>
<p>power-up. </p>
<p>Automotive </p>
<p>applications </p>
<p>would </p>
<p>e.g. </p>
<p>be </p>
<p>measurements during cold start. </p>
<p>The slave and the master have to store all the necessary communication parameters for </p>
<p>the automatic data transfer after power-up. Therefore the following functions have to be </p>
<p>implemented in the slave. </p>
<p>uint8 <b>ApplXcpDaqResume </b>( tXcpDaq * daq )</p>
<p>  </p>
<p>(6.5.20) </p>
<p>void <b>ApplXcpDaqResumeStore </b>( const tXcpDaq * daq )</p>
<p>  </p>
<p>(6.5.21) </p>
<p>void <b>ApplXcpDaqResumeClear </b>( void )</p>
<p>  </p>
<p>(6.5.22) </p>
<p>uint8 <b>ApplXcpCalResumeStore </b>( void )</p>
<p>  </p>
<p>(6.5.23) </p>
<p>To </p>
<p>use </p>
<p>the </p>
<p>resume </p>
<p>mode </p>
<p>the </p>
<p>compiler </p>
<p>switches </p>
<p>XCP_ENBALE_DAQ</p>
<p> </p>
<p>and </p>
<p>XCP_ENABLE_RESUME_MODE</p>
<p> have to be defined. </p>
<p>Annotation for the usage of CANape </p>
<p>Start the resume mode with the menu command Measurement|Start and push the button </p>
<p>“Measure offline” on the dialog box. </p>
<p><b>3.14.4 </b></p>
<p><b>Send Queue </b></p>
<p>The send queue is used to store measurement values until they can be transmitted on the </p>
<p>bus. This is required if the used Transport Layer does not perform buffering on its own. </p>
<p>Vector Transport Layers do not buffer any data and therefore this feature should be used. </p>
<p>The send queue size can be indirectly configured in the Configuration Tool. It is defined by </p>
<p>the parameter “Memory Size” – the memory size used by the dynamic DAQ lists. As the </p>
<p>DAQ lists are created during runtime by the tool no detailed calculation is possible. A worst </p>
<p>case analysis can be made and the parameter should be chosen such that enough space </p>
<p>is left for the send queue. </p>
<p>Furthermore  the  behaviour  of  the  send  queue  in  case  of  an  overrun  condition  can  be </p>
<p>influenced. There are two possible options: </p>
<p>1. </p>
<p>Throw away oldest element </p>
<p></p>
<p> The oldest odt in the send queue is discarded and the new measurement value is </p>
<p>inserted. The send queue behaves as a ring buffer. </p>
<p>2. </p>
<p>Throw away latest element </p>
<p></p>
<p>  The  latest  measurement  values  are  discarded.  The  send  queue  behaves  like  a </p>
<p>linear buffer. </p>
<p>The Configuration Tool option “Replace First Element” determines the default behaviour. </p>
<p>The </p>
<p>behaviour </p>
<p>can </p>
<p>be </p>
<p>changed </p>
<p>during </p>
<p>runtime </p>
<p>by </p>
<p>modifying </p>
<p>the </p>
<p>variable </p>
<p>xcp.Daq.SendQueueBehaviour</p>
<p>. If this variable is zero linear mode is selected, if this variable </p>
<p>is one the ring buffer mode is selected. This variable can be modified by the Master Tool. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>21 / 109 </p>
<p><b>3.14.5 </b></p>
<p><b>Data Stimulation (STIM) (XCP Professional only) </b></p>
<p>Synchronous Data Stimulation is the inverse mode of Synchronous Data Acquisition. </p>
<p>The  STIM  processor  buffers  incoming  data  stimulation  packets.  When  an  event  occurs </p>
<p>(</p>
<p>XcpEvent</p>
<p> is called), which triggers a DAQ list in data stimulation mode, the buffered data </p>
<p>is transferred to the slave device’s memory. </p>
<p>To use data stimulation the compiler switches </p>
<p>XCP_ENBALE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_STIM</p>
<p> </p>
<p>have to be defined. </p>
<p><b>3.14.6 </b></p>
<p><b>Bypassing (XCP Professional only) </b></p>
<p>Bypassing  can  be  realized  by  making  use  of  Synchronous  Data Acquisition  (DAQ)  and </p>
<p>Synchronous Data Stimulation (STIM) simultaneously. </p>
<p>State-of-the-art Bypassing also requires the administration of the bypassed functions. This </p>
<p>administration has to be performed in a MCS like e.g. CANape. </p>
<p>Also  the  slave  should  perform  plausibility  checks  on  the  data  it  receives  through  data </p>
<p>stimulation.  The  borders  and  actions  of  these  checks  are  set  by  standard  calibration </p>
<p>methods. No special XCP commands are needed for this. </p>
<p><b>3.14.7 </b></p>
<p><b>Data Acquisition Plug &amp; Play Mechanisms </b></p>
<p>The XCP Protocol Layer comprises two plug &amp; play mechanisms for data acquisition: </p>
<p><b>&gt; </b></p>
<p>general information on the DAQ processor  </p>
<p>(enabled with </p>
<p>XCP_ENABLE_DAQ_PROCESSOR_INFO</p>
<p>) </p>
<p><b>&gt; </b></p>
<p>general information on DAQ processing resolution  </p>
<p>(enabled with </p>
<p>XCP_ENABLE_DAQ_RESOLUTION_INFO</p>
<p>) </p>
<p>The general information on the DAQ processor contains: </p>
<p><b>&gt; </b></p>
<p>general properties of DAQ lists </p>
<p><b>&gt; </b></p>
<p>total number of available DAQ lists and event channels </p>
<p>The general information on the DAQ processing resolution contains: </p>
<p><b>&gt; </b></p>
<p>granularity and maximum size of ODT entries for both directions </p>
<p><b>&gt; </b></p>
<p>information on the time stamp mode </p>
<p><b>3.14.8 </b></p>
<p><b>Event Channel Plug &amp; Play Mechanism </b></p>
<p>The  XCP  Protocol  Layer  supports  a  plug  &amp;  play  mechanism  that  allows  the  MCS  to </p>
<p>automatically detect the available event channels in the slave. </p>
<p>Please refer to chapter 7.2.5 (Configuration of the Event Channel Plug &amp; Play Mechanism) </p>
<p>for details about the configuration of this plug &amp; play mechanism. </p>
<p>Annotation for the usage of CANape </p>
<p>If the plug &amp; play mechanism is not built-in, you must open the dialog XCP Device Setup </p>
<p>with the menu command Tools|Driver parameters. Go to the Event tab. Make one entry for </p>
<p>each event channel. An event channel is an </p>
<p>XcpEvent(x)</p>
<p> function call in ECU source </p>
<p>code. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>22 / 109 </p>
<p><b>3.14.9 </b></p>
<p><b>Data consistency </b></p>
<p>The  Xcp  supports  a  data  consistency  on  ODT  level.  If  a  consistency  on  DAQ  level  is </p>
<p>required, interrupts must be disabled prior calling XcpEvent and enabled again after the </p>
<p>function  returns.  The  following  example  demonstrates  the  integrity  on  ODT  level  by </p>
<p>showing the XCP ODT frames as sent on the bus. Two Events (x, y) are configured with </p>
<p>DAQ list DAQ1 assigned to Event(x) and DAQ list DAQ2 assigned to Event(y). A call of the </p>
<p>XcpEvent </p>
<p>function </p>
<p>with </p>
<p>the </p>
<p>respective </p>
<p>event </p>
<p>channel </p>
<p>number </p>
<p>will </p>
<p>then </p>
<p>trigger </p>
<p>the </p>
<p>transmission of the associated DAQ list. </p>
<p>Example1: a call of XcpEvent(x) is interrupted by a call of Xcp_Event(y). This is allowed as </p>
<p>long </p>
<p>as </p>
<p>the </p>
<p>interrupt </p>
<p>locks </p>
<p>are </p>
<p>provided </p>
<p>by </p>
<p>the </p>
<p>Schedule </p>
<p>Manager </p>
<p>(default </p>
<p>with </p>
<p>MICROSAR stack). </p>
<p>Example2: a call of Xcp_Event(x) is interrupted by a call of Xcp_Event(x). As a result a </p>
<p>DAQ  list  is  interrupted  by  itself.  This  is  not  allowed  and  must  be  prevented  by  data </p>
<p>consistency on DAQ level. For this use a interrupt lock when calling Xcp_Event() </p>
<p> </p>
<p> </p>
<p>DAQ1 </p>
<p> </p>
<p>DAQ2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ODT0 </p>
<p> </p>
<p> </p>
<p>ODT3 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ODT1 </p>
<p> </p>
<p> </p>
<p>ODT4 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ODT2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Example1 </p>
<p>ODT0 </p>
<p>ODT1 </p>
<p>ODT3 </p>
<p>ODT4 </p>
<p>ODT2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Example2 </p>
<p>ODT0 </p>
<p>ODT1 </p>
<p>ODT0 </p>
<p>ODT1 </p>
<p>ODT2 </p>
<p>ODT2 </p>
<p>Figure 3-1 Data consistency </p>
<p> </p>
<p><b>3.15 </b></p>
<p><b>The Online Data Calibration Model </b></p>
<p><b>3.15.1 </b></p>
<p><b>Page Switching </b></p>
<p>The  MCS  can  switch  between  a  flash  page  and  a  RAM  page.  The  XCP  command </p>
<p>SET_CAL_PAGE is used to activate the required page. The page switching is enabled with </p>
<p>the </p>
<p>XCP_ENABLE_CALIBRATION_PAGE</p>
<p> definition. </p>
<p>The following application callback functions have to be implemented: </p>
<p>uint8 <b>ApplXcpGetCalPage </b>( uint8 segment, uint8 mode )</p>
<p> </p>
<p>(6.5.25) </p>
<p>uint8 <b>ApplXcpSetCalPage </b>( uint8 segment, uint8 page, uint8 mode </p>
<p>)</p>
<p> </p>
<p>(6.5.26) </p>
<p> </p>
<p>Annotation for the usage of CANape </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>23 / 109 </p>
<p>Open the dialog XCP Device Setup with the menu command Tools|Driver Configuration. </p>
<p>Go to the tab “FLASH”. Activate page switching. Enter a flash selector value e.g. 1 and a </p>
<p>Ram selector e.g. 0. </p>
<p><b>3.15.2 </b></p>
<p><b>Page Switching Plug &amp; Play Mechanism </b></p>
<p>The MCS can be automatically configured if the page switching plug &amp; play mechanism is </p>
<p>used. This mechanism comprises </p>
<p><b>&gt; </b></p>
<p>general information about the paging processor </p>
<p>Also refer to chapter 7.2.8 (Configuration of the Page Switching Plug &amp; Play Mechanism) </p>
<p>and to the XCP Specification [II]. </p>
<p>The </p>
<p>page </p>
<p>switching </p>
<p>plug </p>
<p>&amp; </p>
<p>play </p>
<p>mechanism </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>switch </p>
<p>XCP_ENABLE_PAGE_INFO</p>
<p>. </p>
<p><b>3.15.3 </b></p>
<p><b>Calibration Data Page Copying </b></p>
<p>Calibration data page copying is performed by the XCP command COPY_CAL_PAGE. To </p>
<p>enable this feature the compiler switch </p>
<p>XCP_ENABLE_PAGE_COPY</p>
<p> has to be set. </p>
<p>For  calibration  data  page  copying  the  following  application  callback  function  has  to  be </p>
<p>provided by the application: </p>
<p>uint8 <b>ApplXcpCopyCalPage</b>( uint8 srcSeg,  uint8 srcPage, </p>
<p>    uint8 destSeg, uint8 destPage )</p>
<p> (6.5.27) </p>
<p><b>3.15.4 </b></p>
<p><b>Freeze Mode Handling </b></p>
<p>Freeze mode handling is performed by the XCP commands SET_SEGMENT_MODE and </p>
<p>GET_SEGMENT_MODE. </p>
<p>To </p>
<p>enable </p>
<p>this </p>
<p>feature </p>
<p>the </p>
<p>compiler </p>
<p>switch </p>
<p>XCP_ENABLE_PAGE_FREEZE</p>
<p> has to be set. </p>
<p>For freeze mode handling the following application callback functions have to be provided </p>
<p>by the application: </p>
<p>void <b>ApplXcpSetFreezeMode</b>( uint8 segment, uint8 mode )</p>
<p> </p>
<p>(6.5.28) </p>
<p>uint8 <b>ApplXcpGetFreezeMode</b>( uint8 segment )</p>
<p> </p>
<p>(6.5.29) </p>
<p><b>3.16 </b></p>
<p><b>Flash Programming (XCP Professional only) </b></p>
<p>There are two methods available for the programming of flash memory. </p>
<p><b>&gt; </b></p>
<p>Flash programming by the ECU’s application </p>
<p><b>&gt; </b></p>
<p>Flash programming with a flash kernel </p>
<p>Depending on the hardware it might not be possible to reprogram an internal flash sector, </p>
<p>while a program is running from another sector. In this case the usage of a special flash </p>
<p>kernel is necessary. </p>
<p><b>3.16.1 </b></p>
<p><b>Flash Programming by the ECU’s Application </b></p>
<p>If </p>
<p>the </p>
<p>internal </p>
<p>flash </p>
<p>has </p>
<p>to </p>
<p>be </p>
<p>reprogrammed </p>
<p>and </p>
<p>the </p>
<p>microcontroller </p>
<p>allows </p>
<p>to </p>
<p>simultaneously  reprogram  and  execute  code  from  the  flash  the  programming  can  be </p>
<p>performed with the ECU’s application that contains the XCP. This method is also used for </p>
<p>the programming of external flash. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>24 / 109 </p>
<p>The  flash  programming  is  done  with  the  following  XCP  commands  PROGRAM_START, </p>
<p>PROGRAM_RESET, </p>
<p>PROGRAM_CLEAR, </p>
<p>PROGRAM, </p>
<p>PROGRAM_NEXT, </p>
<p>PROGRAM_MAX, PROGRAM_RESET, PROGRAM_FORMAT</p>
<p>1</p>
<p>, PROGRAM_VERIFY</p>
<p>1</p>
<p>. </p>
<p>The  flash  prepare,  flash  program  and  the  clear  routines  are  platform  dependent  and </p>
<p>therefore have to be implemented by the application. </p>
<p>uint8 <b>ApplXcpProgramStart</b>( void )</p>
<p>  </p>
<p>(6.5.17) </p>
<p>uint8 <b>ApplXcpFlashClear</b>( MTABYTEPTR a, uint32 size )</p>
<p>  </p>
<p>(6.5.18) </p>
<p>uint8 <b>ApplXcpFlashProgram</b>( ROMBYTEPTR data,  </p>
<p>    MTABYTEPTR a, uint8 size )</p>
<p>  </p>
<p>(6.5.19) </p>
<p>The flash programming is enabled with the switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p>. </p>
<p>Annotation for the usage of CANape </p>
<p>Open the dialog XCP Device Setup with the menu command Tools|Driver Configuration. </p>
<p>Go to the tab “FLASH” and select the entry “Direct” in the flash kernel drop down list. </p>
<p><b>3.16.1.1 </b></p>
<p><b>Flash Programming Plug &amp; Play Mechanism </b></p>
<p>The </p>
<p>MCS </p>
<p>(like </p>
<p>e.g. </p>
<p>CANape) </p>
<p>can </p>
<p>get </p>
<p>information </p>
<p>about </p>
<p>the </p>
<p>Flash </p>
<p>and </p>
<p>the </p>
<p>Flash </p>
<p>programming process from the ECU. The following information is provided by the ECU: </p>
<p><b>&gt; </b></p>
<p>number of sectors, start address or length of each sector </p>
<p><b>&gt; </b></p>
<p>the program sequence number, clear sequence number and programming method </p>
<p><b>&gt; </b></p>
<p>additional information about compression, encryption </p>
<p>Also </p>
<p>refer </p>
<p>to </p>
<p>chapter </p>
<p>7.2.7 </p>
<p>(Configuration </p>
<p>of </p>
<p>the </p>
<p>Flash </p>
<p>Programming </p>
<p>Plug </p>
<p>&amp; </p>
<p>Play </p>
<p>Mechanism) and to the XCP Specification [II]. </p>
<p>The </p>
<p>flash </p>
<p>programming </p>
<p>plug </p>
<p>&amp; </p>
<p>play </p>
<p>mechanism </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>switch </p>
<p>XCP_ENABLE_PROGRAM_INFO</p>
<p>. </p>
<p><b>3.16.2 </b></p>
<p><b>Flash Programming with a Flash Kernel </b></p>
<p>A </p>
<p>flash </p>
<p>kernel </p>
<p>has </p>
<p>to </p>
<p>be </p>
<p>used </p>
<p>for </p>
<p>the </p>
<p>flash </p>
<p>programming </p>
<p>if </p>
<p>it </p>
<p>is </p>
<p>not </p>
<p>possible </p>
<p>to </p>
<p>simultaneously </p>
<p>reprogram </p>
<p>and </p>
<p>execute </p>
<p>code </p>
<p>from </p>
<p>the </p>
<p>flash. </p>
<p>Even </p>
<p>though </p>
<p>the </p>
<p>reprogrammed sector and the sector the code is executed from are different sectors. </p>
<p>The application callback function </p>
<p>uint8 <b>ApplXcpDisableNormalOperation</b>( MTABYTEPTR a, uint16 size </p>
<p>)</p>
<p>  </p>
<p> (6.5.14) </p>
<p>is  called  prior  to  the  flash  kernel  download  in  the  RAM. Within  this  function  the  normal </p>
<p>operation of the ECU has to be stopped and the flash kernel download can be prepared. </p>
<p>Due  to  the flash  kernel is downloaded  in  the  RAM typically  data  gets  lost  and  no  more </p>
<p>normal operation of the ECU is possible. </p>
<p>The </p>
<p>flash </p>
<p>programming </p>
<p>with </p>
<p>a </p>
<p>flash </p>
<p>kernel </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>switch </p>
<p>XCP_ENABLE_BOOTLOADER_DOWNLOAD</p>
<p>. </p>
<p>Annotation for the usage of CANape </p>
<p>                                            </p>
<p>1</p>
<p> Command not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>25 / 109 </p>
<p>The flash kernel is loaded by CANape into the microcontroller’s RAM via XCP whenever </p>
<p>the flash memory has to be reprogrammed. The flash kernel contains the necessary flash </p>
<p>routines,  its  own  CAN-Driver  and  XCP  Protocol  implementation  to  communicate  via  the </p>
<p>CAN interface with CANape. </p>
<p>Every  flash  kernel  must  be  customized  to  the  microcontroller  and  the  flash  type  being </p>
<p>used. CANape already includes some flash kernels for several microcontrollers. There is </p>
<p>also </p>
<p>an </p>
<p>application </p>
<p>note </p>
<p>available </p>
<p>by </p>
<p>Vector </p>
<p>Informatik </p>
<p>GmbH </p>
<p>that </p>
<p>describes </p>
<p>the </p>
<p>development of a proprietary flash kernel. </p>
<p>Open the dialog XCP Device Setup with the menu command Tools|Driver Configuration. </p>
<p>Go to the tab “FLASH”, and select in the ‘flash kernel’ drop down list, the corresponding <i>fkl </i></p>
<p>file for the microcontroller being used. </p>
<p><b>3.16.3 </b></p>
<p><b>Flash Programming Write Protection </b></p>
<p>If </p>
<p>XCP_ENABLE_PROGRAMMING_WRITE_PROTECTION</p>
<p> is defined write access of specific </p>
<p>FLASH areas can be checked with the function </p>
<p>uint8 <b>ApplXcpCheckProgramAccess</b>( MTABYTEPTR addr, uint32 size )</p>
<p>(6.5.10) </p>
<p>It should only be used, if write protection of flash areas is required. </p>
<p><b>3.17 </b></p>
<p><b>EEPROM Access (XCP Professional only) </b></p>
<p>For  uploading  data  from  the  ECU  to  a  MCS  the  XCP  commands </p>
<p>SHORT_UPLOAD</p>
<p>  and </p>
<p>UPLOAD</p>
<p> are used. The switch </p>
<p>XCP_ENABLE_READ_EEPROM</p>
<p> allows EEPROM access for </p>
<p>these commands. </p>
<p>Before reading from an address it is checked within the following callback function whether </p>
<p>EEPROM or RAM is accessed: </p>
<p>uint8 <b>ApplXcpCheckReadEEPROM </b></p>
<p>( MTABYTEPTR addr, uint8 size, BYTEPTR data )</p>
<p> </p>
<p>(6.5.5) </p>
<p>The EEPROM access is directly performed within this function. </p>
<p>For </p>
<p>downloading </p>
<p>data </p>
<p>from </p>
<p>the </p>
<p>MCS </p>
<p>to </p>
<p>the </p>
<p>ECU </p>
<p>the </p>
<p>XCP </p>
<p>commands </p>
<p>SHORT_DOWNLOAD, DOWNLOAD, DOWNLOAD_NEXT and DOWNLOAD_MAX can be </p>
<p>used.  The  switch </p>
<p>XCP_ENABLE_WRITE_EEPROM</p>
<p>  allows  the  EEPROM  access  for  these </p>
<p>commands. </p>
<p>Also  before  writing  to  an  address  within  the  following  callback  function  it  is  checked </p>
<p>whether EEPROM or RAM is accessed </p>
<p>uint8 <b>ApplXcpCheckWriteEEPROM </b></p>
<p>( MTABYTEPTR addr, uint8 size, ROMBYTEPTR data )</p>
<p> </p>
<p>(6.5.6) </p>
<p><b>3.18 </b></p>
<p><b>Parameter Check </b></p>
<p>As  long  as  the  XCP  Protocol  Layer  is  not  thoroughly  tested  together  with  the  XCP </p>
<p>Transport Layer and the application, the parameter check should be enabled. This is done </p>
<p>by setting the compiler switch </p>
<p>XCP_ENABLE_PARAMETER_CHECK</p>
<p>. </p>
<p>The parameter check may be removed in order to save code space. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>26 / 109 </p>
<p><b>3.19 </b></p>
<p><b>Performance Optimizations </b></p>
<p>The XCP Protocol Layer is a platform comprehensive higher software layer and therefore </p>
<p>platform  specific  optimizations  are  not  implemented.  However  it  is  possible  to  apply </p>
<p>platform specific optimizations. </p>
<p>The following memory access functions can be overwritten by either macros or functions: </p>
<p>void <b>XcpMemCpy</b>( DAQBYTEPTR dest,  </p>
<p>ROMDAQBYTEPTR src, uint16 n )</p>
<p> </p>
<p>(6.6.1) </p>
<p>void <b>XcpMemSet</b>( BYTEPTR p, uint16 n, uint8 b )</p>
<p>  </p>
<p>(6.6.2) </p>
<p>static void <b>XcpMemClr</b>( BYTEPTR p, uint16 n )</p>
<p>  </p>
<p>(6.6.3) </p>
<p>It  is  recommended  to  use  DMA  access  as  far  as  possible  for  faster  execution  of  these </p>
<p>services. </p>
<p>The  transmission  of  data  transfer  objects  (DTO)  could  also  be  optimized  e.g.  by  using </p>
<p>DMA. Therefore the following function has to be overwritten </p>
<p>void <b>XcpSendDto</b>( const xcpDto_t *dto )</p>
<p>  </p>
<p>(6.6.4) </p>
<p>The above listed functions can be overwritten by defining a macro with the functions name </p>
<p>that is included in the XCP Protocol Layer component. </p>
<p><b>3.20 </b></p>
<p><b>Interrupt Locks / Exclusive Areas </b></p>
<p>The  functions </p>
<p>XcpEvent</p>
<p>, </p>
<p>XcpSendCallBack</p>
<p>, </p>
<p>XcpBackground</p>
<p>  and </p>
<p>XcpCommand</p>
<p>  are </p>
<p>not  reentrant. If one of  these functions may  interrupt  one of  the others,  the functions  or </p>
<p>macros </p>
<p>ApplXcpInterruptEnable</p>
<p>  (6.4.3)  and </p>
<p>ApplXcpInterruptDisable</p>
<p>  (6.4.4) </p>
<p>have to be defined to protect critical sections in the code from being interrupted. The time </p>
<p>periods  are  as  short  as  possible,  but  note  that </p>
<p>&lt;Bus&gt;XcpSend</p>
<p>  is  called  with  disabled </p>
<p>interrupts! </p>
<p>If used with a Vector Transport Layer the Xcp Protocol Layer makes use of the exclusive </p>
<p>areas of the Transport Layer. A usage priority must be kept in mind: CanXcp &gt; FrXcp &gt; </p>
<p>TcpIpXcp &gt; LinXcp. This means if two Transport Layers are used (e.g. CanXcp and FrXcp) </p>
<p>the  Protocol  Layer  uses  the  exclusive  area  of  the  first  Transport  Layer  (CanXcp  in  the </p>
<p>given example). </p>
<p><b>3.21 </b></p>
<p><b>Accessing internal data </b></p>
<p>The function  </p>
<p>void <b>XcpGetXcpDataPointer </b>( </p>
<p>P2VAR(tXcpData, AUTOMATIC, </p>
<p>XCP_APPL_DATA) *pXcpData </p>
<p> )</p>
<p>  </p>
<p>(6.2.11) </p>
<p>provides  access  to  the  internal  data  structure  of  the  XCP  module.  By  means  of  this </p>
<p>function the internal data can be preset to a certain value. This can be used to process a </p>
<p>measurement  further  that  has  been  started  in  application  mode  but  is  finished  in  boot </p>
<p>mode.  </p>
<p>As the whole data can be accessed, it must be handled with care. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>27 / 109 </p>
<p><b>3.22 </b></p>
<p><b>En- / Disabling the XCP module </b></p>
<p>The function  </p>
<p>void <b>XcpControl </b>( uint8 command )</p>
<p>  </p>
<p>(6.2.12) </p>
<p>can be used to en- or disable the XCP module during run time. Thus the XCP functionality </p>
<p>can be controlled by the application. </p>
<p>Furthermore  two  macros  are  available:  XCP_ACTIVATE  and  XCP_DEACTIVATE.  They </p>
<p>can be used to control the protocol and transport layer together, i.e. enabling or disabling </p>
<p>them as a whole. </p>
<p><b>3.23 </b></p>
<p><b>XCP measurement during the follow up time </b></p>
<p>In use cases where there is no further communication request except XCP measurement </p>
<p>the session state of the XCP can be determined to prevent an early shutdown of the ECU. </p>
<p>For this purpose the following API exist: </p>
<p>SessionStatusType <b>XcpGetSessionStatus</b></p>
<p> ( void )</p>
<p>  </p>
<p>(6.3.3) </p>
<p> </p>
<p>An example implementation that is called cyclically could look like the following example: </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p>{ </p>
<p>  SessionStatusType sessionState; </p>
<p> </p>
<p>  sessionState = XcpGetSessionStatus(); </p>
<p>  if( 0 != (sessionState &amp; SS_CONNECTED) ) </p>
<p>  { </p>
<p>    /* Is the xcp actively used? */ </p>
<p>    if( 0 != (sessionState &amp; (SS_DAQ | SS_POLLING)) ) </p>
<p>    { </p>
<p>      /* Yes, reaload timer */ </p>
<p>      swTimer = XCP_TIMEOUT_TIMER_RELOAD; </p>
<p>    } </p>
<p>  } </p>
<p> </p>
<p>  if( swTimer &gt; 0 ) </p>
<p>  { </p>
<p>    /* No timeout so far */ </p>
<p>    swTimer--; </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    /* Timer timeout happened, release xcp communication request */ </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<p>Please note that polling requests may happen erratically. Therefore it is important not to </p>
<p>choose the timeout value </p>
<p>XCP_TIMEOUT_TIMER_RELOAD </p>
<p>too small. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>28 / 109 </p>
<p><b>4 </b></p>
<p><b>Integration into the Application </b></p>
<p>This  chapter  describes  the  steps  for  the  integration  of  the  XCP  Protocol  Layer  into  an </p>
<p>application environment of an ECU. </p>
<p><b>4.1 </b></p>
<p><b>Files of XCP Professional </b></p>
<p>The XCP Protocol Layer consists of the following files.  </p>
<p><b>Files of the XCP Protocol Layer </b></p>
<p>XcpProf.c </p>
<p>XCP Professional source code. </p>
<p>This file <b>must not </b>be changed by the user! </p>
<p> </p>
<p>XcpProf.h </p>
<p>API of XCP Professional. </p>
<p>This file <b>must not </b>be changed by the user! </p>
<p> </p>
<p>_xcp_appl.c </p>
<p>Template that contains the application callback functions of the XCP </p>
<p>Protocol Layer. It is just an example and has to be customized. </p>
<p> </p>
<p>v_def.h </p>
<p>General Vector definitions of memory qualifiers and types. </p>
<p>This file <b>must not </b>be changed by the application! </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Additionally the following files are generated by the generation tool. If no generation tool or </p>
<p>if CANgen is used the XPC Protocol Layer has to be customized manually. In this case the </p>
<p>following files will be available as template. </p>
<p><b>Files generated by GENy </b></p>
<p>xcp_cfg.h </p>
<p>XCP Protocol Layer configuration file. </p>
<p> </p>
<p>xcp_par.c </p>
<p>Parameter definition for the XCP Protocol Layer. </p>
<p> </p>
<p>xcp_par.h </p>
<p>External declarations for the parameters. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Note that all files of XCP Professional <b>must not </b>be changed manually! </p>
<p><b>4.2 </b></p>
<p><b>Files of XCP Basic </b></p>
<p>Xcp  Basic  is  the  free  Xcp  implementation  which  can  be  downloaded  from  the  Vector </p>
<p>website. The XCP Basic Protocol Layer consists of the following files: </p>
<p><b>Files of the XCP Protocol Layer </b></p>
<p>XcpBasic.c </p>
<p>XCP Basic source code. </p>
<p>This file <b>must not </b>be changed by the application! </p>
<p> </p>
<p>XcpBasic.h </p>
<p>API of XCP Basic. </p>
<p>This file <b>must not </b>be changed by the application! </p>
<p> </p>
<p>xcp_cfg.h </p>
<p>Configuration file template for the XCP Protocol Layer. </p>
<p>It is just an example and has to be customized. </p>
<p> </p>
<p>xcp_par.c </p>
<p>Template with parameter definitions for the XCP Protocol Layer. </p>
<p>It is just an example and has to be customized </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>29 / 109 </p>
<p>xcp_par.h </p>
<p>Template with external declarations for the parameters. </p>
<p>It is just an example and has to be customized </p>
<p> </p>
<p> </p>
<p><b>4.3 </b></p>
<p><b>Version changes </b></p>
<p>Changes and the release versions of the XCP Protocol Layer are listed at the beginning of </p>
<p>the header and source code. </p>
<p><b>4.4 </b></p>
<p><b>Integration of XCP into the Application </b></p>
<p><b>4.4.1 </b></p>
<p><b>Integration of XCP on CAN (XCP Professional only) </b></p>
<p>The Vector CANbedded stack includes optionally XCP on CAN, which comprises the XCP </p>
<p>Protocol Layer in conjunction with the XCP on CAN Transport Layer and the CAN-Driver.   </p>
<p>Note that the CAN-Driver, which is distributed as a separate product, is only partly part of </p>
<p>XCP on CAN. </p>
<p>The following figure shows the interface between XCP on CAN and the application: </p>
<p><b>XCP on CAN</b></p>
<p><b>XCP</b></p>
<p><b>Protocol Layer</b></p>
<p><b>( XcpProf.c )</b></p>
<p><b>XCP on CAN</b></p>
<p><b>Interface Layer</b></p>
<p><b>(xcp_can.c)</b></p>
<p>XcpCommand</p>
<p><b>Application</b></p>
<p>ApplXcpSend</p>
<p>XcpSendCallback</p>
<p>XcpEvent</p>
<p>XcpInit</p>
<p>XcpBackground</p>
<p>ApplXcp..</p>
<p><b>CAN Driver</b></p>
<p><b>(can_drv.c)</b></p>
<p> </p>
<p>Figure 4-1 Integration of XCP on CAN into the application </p>
<p> </p>
<p> </p>
<p><b>Practical Procedure </b></p>
<p>The integration of XCP on CAN can be done by following these steps: </p>
<p>1. </p>
<p>Configure XCP on CAN in the generation tool GENy and generate. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>30 / 109 </p>
<p>2. </p>
<p>Include the include header file </p>
<p>v_inc.h</p>
<p> into all modules that access the </p>
<p>XCP on CAN services or provide services that XCP on CAN uses. </p>
<p>3. </p>
<p>Add all source files and generated source files in the make file and link it </p>
<p>together with the data link layer and the application. </p>
<p>4. </p>
<p>Initialize </p>
<p>the </p>
<p>data </p>
<p>link </p>
<p>layer </p>
<p>after </p>
<p>each </p>
<p>reset </p>
<p>during </p>
<p>start-up </p>
<p>before </p>
<p>initializing XCP on CAN (interrupts have to be disabled until the complete </p>
<p>initialization procedure is done) by calling </p>
<p>XcpInit</p>
<p>. </p>
<p>5. </p>
<p>If required call the background function </p>
<p>XcpBackground </p>
<p>cyclically. </p>
<p>6. </p>
<p>Integrate  the  desired  XCP  on  CAN  services  into  your  application.  Call </p>
<p>especially the function </p>
<p>XcpEvent(channel) </p>
<p>cyclic with the appropriate </p>
<p>cycle time and channel number. </p>
<p>The  XCP  on  CAN  sources  must  not  be  changed  for  the  integration  into  the </p>
<p>application. </p>
<p> </p>
<p><b>4.4.2 </b></p>
<p><b>Integration with a Proprietary XCP Transport Layer </b></p>
<p>The  XCP  Protocol  Layer  needs  a  XCP  Transport  Layer  to  transmit  and  receive  XCP </p>
<p>protocol  messages  on  the  communication  link  (CAN,  FlexRay,  Ethernet,  SxI,  …)  that  is </p>
<p>used.  The  free  Vector  XCP  Protocol  Layer  implementation  does  not  include  the  XCP </p>
<p>Transport Layer, which typically is strongly ECU dependant. However the Vector XCP on </p>
<p>CAN software components already includes the XCP Transport Layer for CAN. </p>
<p>The following figure shows the interface between the transport layer and the protocol layer. </p>
<p><b>XCP</b></p>
<p><b>Protocol Layer</b></p>
<p><b>( XcpBasic.c )</b></p>
<p><b>XCP Transport Layer</b></p>
<p>XcpCommand</p>
<p>Application - XCPTransport Layer interface</p>
<p><b>Application</b></p>
<p>ApplXcpSend</p>
<p>XcpSendCallback</p>
<p>XcpEvent</p>
<p>XcpInit</p>
<p>XcpBackground</p>
<p>ApplXcp..</p>
<p> </p>
<p>Figure 4-2 Integration of XCP with a proprietary XCP Transport Layer </p>
<p>The transport layer driver has to notify the protocol layer after reception of a XCP protocol </p>
<p>message by calling the protocol layer function </p>
<p>XcpCommand()</p>
<p>. </p>
<p>The protocol layer will use the function </p>
<p>&lt;Bus&gt;XcpSend()</p>
<p> of the transport layer to transmit </p>
<p>a command response message or a data acquisition message. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>31 / 109 </p>
<p>After the message  has  been  transmitted  successfully,  the  transport  layer has  to  call the </p>
<p>function </p>
<p>XcpSendCallBack()</p>
<p> of the protocol layer to indicate this. </p>
<p>The  functions </p>
<p>XcpInit()</p>
<p>, </p>
<p>XcpEvent()</p>
<p>  and </p>
<p>XcpBackground()</p>
<p>  are  called  from  the </p>
<p>ECU’s application program. </p>
<p>The  function </p>
<p>ApplXcpGetPointer()</p>
<p>  is  used  by  the  protocol  layer  to  convert  a  32  Bit </p>
<p>address with an address extension to a valid pointer. </p>
<p>Depending on the optional features that can be enabled upon demand further application </p>
<p>callback functions are necessary. All application functions are indicated in  Figure 4-2 by </p>
<p>their prefix </p>
<p>ApplXcp…</p>
<p>. </p>
<p>  </p>
<p> </p>
<p><b>Example </b></p>
<p>The following C pseudo code example shows the required software handshake between </p>
<p>the protocol layer and the transport layer. The example uses a simple transport layer </p>
<p>definition where the length of the protocol message is transmitted in the first byte of the </p>
<p>protocol packet: </p>
<p> </p>
<p>/* Initialization */ </p>
<p>XcpInit(); </p>
<p> </p>
<p>/* Main Loop */ </p>
<p>for (;;) { </p>
<p> </p>
<p>  /* Packet received */ </p>
<p>  if (Message received) { </p>
<p>    XcpCommand(&amp;ReceiveBuffer[1]); </p>
<p>  } </p>
<p> </p>
<p>  /* Transmit Message Buffer available */  </p>
<p>  if (Message transmitted) { </p>
<p>    XcpSendCallBack(); </p>
<p>  } </p>
<p>   </p>
<p>  /* Background Processing */ </p>
<p>  XcpBackground(); </p>
<p>} </p>
<p> </p>
<p>/* Transmit Function */ </p>
<p>void ApplXcpSend(uint8 len, MEMORY_ROM BYTEPTR msg ) { </p>
<p>  TransmitBuffer[0] = len; /* This is transport layer specific */ </p>
<p>  memcpy(&amp;TransmitBuffer[1],msg,len); </p>
<p>  Transmit(TransmitBuffer); </p>
<p>} </p>
<p> </p>
<p>/* Pointer Conversion */ </p>
<p>MTABYTEPTR ApplXcpGetPointer( uint8 addr_ext, uint32 addr ) { </p>
<p>  Return (BYTE*)addr; </p>
<p>}</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>32 / 109 </p>
<p><b>4.4.3 </b></p>
<p><b>Motorola HC12 with CAN Transport Layer </b></p>
<p>See the application note “AN-IMC-1-007_Integration_of_the_Vector_XCP_Driver </p>
<p>with_a_free_CAN_Driver_v1.0.0_EN.pdf” which explains in detail how to integrate the </p>
<p>Vector basic XCP driver into an HC12 microcontroller with an existing CAN driver.</p>
<p> </p>
<p> </p>
<p><b>4.5 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions defined for XCP, and illustrates their assignment among each other. </p>
<p><b>Compiler Abstraction </b></p>
<p><b>Definitions </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>XCP_CONST </p>
<p>XCP_DAQ_DATA </p>
<p>XCP_MTA_DATA </p>
<p>XCP_APPL_DATA </p>
<p>XCP_CODE </p>
<p>XCP_START_SEC_CONST_16BIT</p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_CONST_8BIT</p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_VAR_NOINIT_UNSPECIFIED</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_VAR_NOINIT_8BIT</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_CODE </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Table 4-1  </p>
<p>Compiler abstraction and memory mapping </p>
<p>Please  see  the  document:  “AUTOSAR_SWS_CompilerAbstraction.pdf”  for  details  about </p>
<p>how to use these definitions. </p>
<p><b>4.6 </b></p>
<p><b>Support of Vx1000 Integration </b></p>
<p>The  Xcp  component  provides  basic  support  for  the  Vx1000  Hardware  which  can  be </p>
<p>enabled in the configuration tool. If enabled the code size is increased, yet the same API </p>
<p>calls  as used for the Xcp  component  are  reused for the Vx  which minimizes  integration </p>
<p>effort. </p>
<p>When  the  option  is  enabled  the  sources  provided  with  your  Vx1000  hardware  must  be </p>
<p>integrated.  The  Xcp  component  includes  the  Vx1000.h  header  and  makes  use  of  the </p>
<p>respective macros. </p>
<p>If  the  Vx  hardware  is  attached  prior  to  ECU  Initialization  the  Xcp  software  itself  is </p>
<p>deactivated,  hence  no  access  via  the  bus  interface  is  possible  anymore.  If  you  want  to </p>
<p>perform measurement &amp; calibration via the bus interface again, detach the Vx hardware </p>
<p>and perform an ECU reset. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>33 / 109 </p>
<p><b>5 </b></p>
<p><b>Feature List </b></p>
<p>This general feature list describes the overall feature set of the XCP Protocol Layer. Not all </p>
<p>of these features are available in XCP Basic. Please also refer to 9.2 “Limitations of XCP </p>
<p>Basic”. </p>
<p><b>Description of the XCP functionality </b></p>
<p><b>Version </b></p>
<p><b>Functions </b></p>
<p><b>Initialization </b></p>
<p>Initialization </p>
<p>Prof, Basic </p>
<p>XcpInit </p>
<p>ApplXcpInit </p>
<p><b>Task</b></p>
<p><b> </b></p>
<p>Background task </p>
<p>Prof, Basic </p>
<p>XcpBackground </p>
<p><b>XCP Command Processor</b></p>
<p><b> </b></p>
<p>Command Processor </p>
<p>Prof, Basic </p>
<p>XcpCommand </p>
<p>Transmission and Confirmation of XCP Packets </p>
<p>Prof, Basic </p>
<p>&lt;Bus&gt;XcpSend </p>
<p>XcpSendCallBack </p>
<p>Transmission of Response packets </p>
<p>Prof, Basic </p>
<p>XcpSendCrm </p>
<p>Transmission of XCP Packets </p>
<p>Prof, Basic </p>
<p>ApplXcpSendStall </p>
<p>&lt;Bus&gt;XcpSendFlush </p>
<p><b>XCP Commands</b></p>
<p><b> </b></p>
<p>Get Identification </p>
<p>Prof, Basic </p>
<p>ApplXcpGetIdData </p>
<p>Seed &amp; Key </p>
<p>Prof, Basic </p>
<p>ApplXcpGetSeed </p>
<p>ApplXcpUnlock </p>
<p>Short Download </p>
<p>Prof </p>
<p>- </p>
<p>Modify Bits </p>
<p>Prof </p>
<p>- </p>
<p>Write DAQ Multiple </p>
<p>Prof </p>
<p>ApplXcpCheckDAQAccess  </p>
<p>Transport Layer Command </p>
<p>Prof </p>
<p>&lt;Bus&gt;Xcp_TLService </p>
<p>Open Command Interface </p>
<p>Prof </p>
<p>ApplXcpOpenCmdIf </p>
<p>User command </p>
<p>Prof, Basic </p>
<p>ApplXcpUserService </p>
<p><b>Data Acquisition (DAQ) </b></p>
<p>Synchronous Data Acquisition and Stimulation </p>
<p>Prof, Basic </p>
<p>XcpEvent </p>
<p>ApplXcpCheckDAQAccess </p>
<p>DAQ Timestamp </p>
<p>Prof, Basic </p>
<p>ApplXcpGetTimestamp </p>
<p>Resume Mode </p>
<p>Prof </p>
<p>ApplXcpDaqResume </p>
<p>ApplXcpDaqResumeStore </p>
<p>ApplXcpDaqResumeClear </p>
<p>ApplXcpCalResumeStore </p>
<p><b>Online Data Calibration</b></p>
<p><b> </b></p>
<p>Calibration page switching </p>
<p>Prof, Basic </p>
<p>ApplXcpGetCalPage </p>
<p>ApplXcpSetCalPage </p>
<p>Copy calibration page </p>
<p>Prof, Basic </p>
<p>ApplXcpCopyCalPage </p>
<p>Freeze Mode </p>
<p>Prof, Basic </p>
<p>ApplXcpSetFreezeMode </p>
<p>ApplXcpGetFreezeMode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>34 / 109 </p>
<p><b>Boot loader Download</b></p>
<p><b> </b></p>
<p>Disable normal operation of ECU </p>
<p>Prof </p>
<p>ApplXcpDisableNormalOpera</p>
<p>tion </p>
<p>Start of the boot loader </p>
<p>Prof </p>
<p>ApplXcpStartBootLoader </p>
<p><b>Flash Programming </b></p>
<p>Reset of ECU </p>
<p>Prof </p>
<p>ApplXcpReset </p>
<p>Clear flash memory </p>
<p>Prof </p>
<p>ApplXcpFlashClear </p>
<p>Prepare flash programming </p>
<p>Prof </p>
<p>ApplXcpProgramStart </p>
<p>Program flash memory </p>
<p>Prof </p>
<p>ApplXcpFlashProgram </p>
<p><b>Special Features</b></p>
<p><b> </b></p>
<p>Interrupt Control </p>
<p>Prof, Basic </p>
<p>ApplXcpInterruptEnable </p>
<p>ApplXcpInterruptDisable </p>
<p>Event Codes </p>
<p>Prof </p>
<p>XcpSendEvent </p>
<p>Service Request Packets </p>
<p>Prof </p>
<p>XcpPutchar </p>
<p>XcpPrint </p>
<p>Disconnect XCP </p>
<p>Prof, Basic </p>
<p>XcpDisconnect </p>
<p>Pointer conversion </p>
<p>Prof, Basic </p>
<p>ApplXcpGetPointer </p>
<p>EEPROM access </p>
<p>Prof </p>
<p>ApplXcpCheckReadEEPROM </p>
<p>ApplXcpCheckWriteEEPROM </p>
<p>Write protection </p>
<p>Prof </p>
<p>ApplXcpCheckWriteAccess </p>
<p>Read protection </p>
<p>Prof </p>
<p>ApplXcpCheckReadAccess </p>
<p>Overwriteable macros </p>
<p>Prof, Basic </p>
<p>XcpMemCpy </p>
<p>XcpMemSet </p>
<p>XcpMemClr </p>
<p>XcpSendDto </p>
<p>En- / Disabling XCP module </p>
<p>Prof </p>
<p>XcpControl </p>
<p>Access to internal data </p>
<p>Prof </p>
<p>XcpGetXcpDataPointer </p>
<p>En-/Disable Calibration </p>
<p>Prof </p>
<p>- </p>
<p>Programming Write Protection </p>
<p>Prof </p>
<p>ApplXcpCheckProgramAccess </p>
<p>Session Status </p>
<p>Prof </p>
<p>XcpGetSessionStatus </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>35 / 109 </p>
<p><b>6 </b></p>
<p><b>Description of the API </b></p>
<p>The XCP Protocol Layer application programming interface consists of services, which are </p>
<p>realized  by  function  calls.  These  services  are  called  wherever  they  are  required.  They </p>
<p>transfer  information  to-  or  take  over  information  from  the  XCP  Protocol  Layer.  This </p>
<p>information </p>
<p>is </p>
<p>stored </p>
<p>in </p>
<p>the </p>
<p>XCP </p>
<p>Protocol </p>
<p>Layer </p>
<p>until </p>
<p>it </p>
<p>is </p>
<p>not </p>
<p>required </p>
<p>anymore, </p>
<p>respectively until it is changed by other operations. </p>
<p>Examples  for  calling  the  services </p>
<p>of </p>
<p>the  XCP  Protocol  Layer  can  be  found  in  the </p>
<p>description of the services. </p>
<p> </p>
<p><b>6.1 </b></p>
<p><b>Version of the Source Code </b></p>
<p>The  source  code  version  of  the  XCP  Protocol  Layer  is  provided  by  three  BCD  coded </p>
<p>constants: </p>
<p>CONST(uint8, XCP_CONST)</p>
<p> kXcpMainVersion =  </p>
<p>(uint8)(CP_XCP_VERSION &gt;&gt; 8);</p>
<p> </p>
<p>CONST(uint8, XCP_CONST)</p>
<p>  kXcpSubVersion  = </p>
<p>(uint8)(CP_XCP_ VERSION); </p>
<p>CONST(uint8, XCP_CONST)</p>
<p> kXcpReleaseVersion = </p>
<p>(uint8)(CP_XCP_RELEASE_VERSION);</p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Example</b> </p>
<p>Version 1.00.00 is registered as: </p>
<p>kXcpMainVersion    = 0x01; </p>
<p>kXcpSubVersion     = 0x00; </p>
<p>kXcpReleaseVersion = 0x00;</p>
<p> </p>
<p> </p>
<p>These constants are declared as external and can be read by the application at any time. </p>
<p>Alternatively the Version can be obtained with the GetVersionInfo API if enabled: </p>
<p>void </p>
<p> </p>
<p><b>XcpGetVersionInfo </b>(P2VAR(Std_VersionInfoType, AUTOMATIC, </p>
<p>XCP_APPL_DATA) XcpVerInfoPtr)</p>
<p>  </p>
<p>(6.2.13) </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>36 / 109 </p>
<p><b>6.2 </b></p>
<p><b>XCP Services called by the Application </b></p>
<p>The following XCP services that are called by the application are all not reentrant. If they </p>
<p>are called within interrupt context at least the CAN-Interrupts have to be disabled. </p>
<p> </p>
<p><b>6.2.1 </b></p>
<p><b>XcpInitMemory: Initialization of the XCP Protocol Layer Memory </b></p>
<p><b>XcpInitMemory </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpInitMemory </b>( </p>
<p>void </p>
<p>) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This service initializes the XCP Protocol Layer memory. It must be called from the application </p>
<p>program before any other XCP function is called. This is only required if the Startup Code does not </p>
<p>initialize the memory with zero. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This service function has to be called after the initialization of XCP Transport Layer. </p>
<p><b>&gt; </b></p>
<p>The global interrupts have to be disabled while this service function is executed. This function </p>
<p>should be called during initialization of the ECU before the interrupts have been enabled </p>
<p>before. </p>
<p> </p>
<p><b>6.2.2 </b></p>
<p><b>XcpInit: Initialization of the XCP Protocol Layer </b></p>
<p><b>XcpInit </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpInit  </b>( </p>
<p>void </p>
<p>) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>37 / 109 </p>
<p><b>Functional Description </b></p>
<p>This service initializes the XCP Protocol Layer and its internal variables. It must be called from the </p>
<p>application program before any other XCP function is called. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This service function has to be called after the initialization of XCP Transport Layer. </p>
<p><b>&gt; </b></p>
<p>The global interrupts have to be disabled while this service function is executed. This function </p>
<p>should be called during initialization of the ECU before the interrupts have been enabled </p>
<p>before. </p>
<p> </p>
<p><b>6.2.3 </b></p>
<p><b>XcpEvent: Handling of a data acquisition event channel </b></p>
<p><b>XcpEvent </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 XcpEvent  ( uint8 event ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>event </p>
<p>Number of event channels to process </p>
<p>The event channel numbers have to start at 0 and have to be </p>
<p>continuous. The range is: 0..x </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_EVENT_NO :   </p>
<p>Inactive (DAQ not running, Event not configured) </p>
<p>XCP_EVENT_DAQ :  DAQ active */ </p>
<p>XCP_EVENT_DAQ_OVERRUN :  DAQ queue overflow </p>
<p>XCP_EVENT_STIM :  STIM active </p>
<p>XCP_EVENT_STIM_OVERRUN :  STIM data not available </p>
<p><b>Functional Description </b></p>
<p>Calling XcpEvent with a particular event channel number triggers the sampling and transmission </p>
<p>of all DAQ lists that are assigned to this event channel. </p>
<p>The event channels are defined by the ECU developer in the application program. An MCS (e.g. </p>
<p>CANape) must know about the meaning of the event channel numbers. These are usually </p>
<p>described in the tool configuration files or in the interface specific part of the ASAM MC2 (ASAP2) </p>
<p>database. </p>
<p>Example: </p>
<p>A motor control unit may have a 10ms, a 100ms and a crank synchronous event channel. In this </p>
<p>case, the three XcpEvent calls have to be placed at the appropriate locations in the ECU’s </p>
<p>program: </p>
<p>xcpEvent (0); /* 10ms cycle */ </p>
<p>xcpEvent (1); /* 100ms cycle */ </p>
<p>xcpEvent (2); /* Crank synchronous cycle */ </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>38 / 109 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Data acquisition has to be enabled: XCP_ENABLE_DAQ has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.4 </b></p>
<p><b>XcpStimEventStatus: Check data stimulation events </b></p>
<p><b>XcpStimEventStatus </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpStimEventStatus  </b>( uint8 event, uint8 action ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>event </p>
<p>Event channel number </p>
<p>action </p>
<p>STIM_CHECK_ODT_BUFFER</p>
<p> : check ODT buffer </p>
<p>STIM_RESET_ODT_BUFFER</p>
<p> : reset ODT buffer </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0</p>
<p> : stimulation data not available</p>
<p> </p>
<p>1</p>
<p> : new stimulation data is available</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Check if data stimulation (STIM) event can perform or delete the buffers. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Data acquisition has to be enabled: XCP_ENABLE_STIM has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.5 </b></p>
<p><b>XcpBackground: Background calculation of checksum </b></p>
<p><b>XcpBackground </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpBackground  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>39 / 109 </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 : background calculation finished </p>
<p>1 : background calculation is still in progress </p>
<p><b>Functional Description </b></p>
<p>If the XCP command for the calculation of the memory checksum has to be used for large memory </p>
<p>areas, it might not be appropriate to block the processor for a long period of time. Therefore, the </p>
<p>checksum calculation is divided into smaller sections that are handled in </p>
<p>XcpBackground</p>
<p>. </p>
<p>Therefore </p>
<p>XcpBackground</p>
<p> should be called periodically whenever the ECU’s CPU is idle. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task level </p>
<p> </p>
<p><b>6.2.6 </b></p>
<p><b>XcpSendEvent: Transmission of event codes </b></p>
<p><b>XcpSendEvent </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpSendEvent  </b>( uint8 evc, ROMBYTEPTR c, uint8 len ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>evc </p>
<p>event code </p>
<p>c  </p>
<p>pointer to event data </p>
<p>len </p>
<p>event data length </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Transmission of event codes via event packets (EV). </p>
<p>Please refer to chapter 3.10 Event Codes. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Data acquisition has to be enabled: XCP_ENABLE_SEND_EVENT has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p> </p>
<p><b>6.2.7 </b></p>
<p><b>XcpPutchar: Put a char into a service request packet </b></p>
<p><b>XcpPutchar </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpPutchar  </b>( const uint8 c ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>40 / 109 </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>c </p>
<p>character that is put in a service request packet </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Put a char into a service request packet (SERV). </p>
<p>The service request packet is transmitted if either the maximum packet length is reached (the </p>
<p>service request message packet is full) or the character 0x00 is out in the service request packet. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SERV_TEXT_PUTCHAR</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.8 </b></p>
<p><b>XcpPrint: Transmission of a service request packet </b></p>
<p><b>XcpPrint </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpPrint  </b>(</p>
<p>P2CONST(uint8, AUTOMATIC, XCP_APPL_DATA)</p>
<p> str ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>str </p>
<p>pointer to a string that is terminated by 0x00 </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Transmission of a service request packet (SERV). </p>
<p>The string </p>
<p>str</p>
<p> is sent via service request packets. The string has to be terminated by 0x00. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SERV_TEXT_PRINT</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.9 </b></p>
<p><b>XcpDisconnect: Disconnect from XCP master </b></p>
<p><b>XcpDisconnect </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>41 / 109 </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpDisconnect  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>If the XCP slave is connected to a XCP master a call of this function discontinues the connection </p>
<p>(transition to disconnected state). If the XCP slave is not connected this function performs no </p>
<p>action. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.10 </b></p>
<p><b>XcpSendCrm: Transmit response or error packet </b></p>
<p><b>XcpSendCrm </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpSendCrm  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Transmission of a command response packet (RES), or error packet (ERR) if no other packet is </p>
<p>pending. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly, XCP is in connected state and a </p>
<p>command packet (CMD) has been received. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>42 / 109 </p>
<p><b>6.2.11 </b></p>
<p><b>XcpGetXcpDataPointer: Request internal data pointer </b></p>
<p><b>XcpGetXcpDataPointer </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpGetXcpDataPointer </b>( tXcpData ** pXcpData ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pXcpData</p>
<p> </p>
<p>pointer to store the pointer to the module internal data </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>With this function the pointer to the module internal data can be received. With this pointer the </p>
<p>internal variable can be set to a certain configuration (e.g. after entering a boot mode where no </p>
<p>connection shall be established again). As this pointer allows the access to all internal data it must </p>
<p>be handled with care. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_GET_XCP_DATA_POINTER</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.2.12 </b></p>
<p><b>XcpControl: En- / Disable the XCP module </b></p>
<p><b>XcpControl </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpControl </b>( uint8 command ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>command</p>
<p> </p>
<p>parameter to either en- or disable the module </p>
<p>kXcpControl_Disable: disable the module </p>
<p>kXcpControl_Enable: enable the module </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>With this function the whole module can be en- or disabled. After initialization the module is </p>
<p>enabled. A call with parameter kXcpControl_Enable does not lead to any changed behavior. After </p>
<p>call with parameter kXcpControl_Disable each function either called by the application or by the </p>
<p>transport layer is directly left without any handling.  </p>
<p>Thus this function can be used to disable the XCP functionality during runtime. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>43 / 109 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_CONTROL</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.2.13 </b></p>
<p><b>XcpGetVersionInfo: Request module version information </b></p>
<p><b>XcpGetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpGetVersionInfo </b>(P2VAR(Std_VersionInfoType, AUTOMATIC, </p>
<p>XCP_APPL_DATA) XcpVerInfoPtr) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>XcpVerInfoPtr </p>
<p> </p>
<p>Pointer to the location where the Version information shall be stored. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>With this service it is possible to get the version information of this software module. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The switch </p>
<p>XCP_ENABLE_VERSION_INFO_API</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: task level (Re-entrant) </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>6.3 </b></p>
<p><b>XCP Protocol Layer Functions, called by the XCP Transport Layer </b></p>
<p>For using the following functions there are some limitations which have to be taken into </p>
<p>consideration – especially when using an operation system like, i.e. OSEK OS: </p>
<p><b>&gt; </b></p>
<p>The ISR level for the transmission and reception of CAN messages has to be the same. </p>
<p><b>&gt; </b></p>
<p>Interrupts must be mutually </p>
<p><b>&gt; </b></p>
<p>No nested calls of these functions are allowed. (i.e. these functions are not reentrant) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>44 / 109 </p>
<p>All functions provided by the application must match the required interfaces. This can be </p>
<p>ensured by including the header file in the modules which provide the required functions. If </p>
<p>these interfaces do not match unexpected run-time behavior may occur. </p>
<p> </p>
<p><b>6.3.1 </b></p>
<p><b>XcpCommand: Evaluation of XCP packets and command interpreter </b></p>
<p><b>XcpCommand </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpCommand  </b>(</p>
<p>P2CONST(uint32, AUTOMATIC, </p>
<p>XCP_APPL_DATA)</p>
<p> pCommand ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pCommand</p>
<p> </p>
<p>Pointer to the XCP protocol message, which must be extracted from </p>
<p>the XCP protocol packet. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Every time the XCP Transport Layer receives a XCP CTO Packet this function has to be called. </p>
<p>The parameter is a pointer to the XCP protocol message, which must be extracted from the XCP </p>
<p>protocol packet. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p> </p>
<p><b>6.3.2 </b></p>
<p><b>XcpSendCallBack: Confirmation of the successful transmission of a XCP </b></p>
<p><b>packet </b></p>
<p><b>XcpSendCallBack </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpSendCallBack  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>45 / 109 </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>0</p>
<p> : </p>
<p>if the XCP Protocol Layer is idle (no transmit messages are </p>
<p>pending) </p>
<p><b>Functional Description </b></p>
<p>The XCP Protocol Layer does not call </p>
<p>&lt;Bus&gt;XcpSend</p>
<p> again, until </p>
<p>XcpSendCallBack</p>
<p> has </p>
<p>confirmed the successful transmission of the previous message. </p>
<p>XcpSendCallBack</p>
<p> transmits </p>
<p>pending data acquisition messages by calling </p>
<p>&lt;Bus&gt;XcpSend</p>
<p> again.  </p>
<p>Note that if </p>
<p>XcpSendCallBack</p>
<p> is called from inside </p>
<p>&lt;Bus&gt;XcpSend</p>
<p> a recursion occurs, which </p>
<p>assumes enough space on the call stack. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.3.3 </b></p>
<p><b>XcpGetSessionStatus: Get session state of XCP </b></p>
<p><b>XcpGetSessionStatus </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>SessionStatusType <b>XcpGetSessionStatus  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>SS_CONNECTED</p>
<p> </p>
<p>XCP is connected </p>
<p>SS_DAQ </p>
<p>DAQ measurement is running </p>
<p>SS_POLLING</p>
<p> </p>
<p>Polling is running (depending on polling rate this flag is not </p>
<p>always set) </p>
<p><b>Functional Description </b></p>
<p>This service can be used to get the session state of the XCP Protocol Layer. The session state is </p>
<p>returned as bit mask where the individual bits can be tested. </p>
<p>E.g. this service is used by the XCP on CAN Transport Layer to determine the connection state in </p>
<p>case multiple CAN channels are used and can be used by the application to prevent an ECU </p>
<p>shutdown. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p><b>&gt; </b></p>
<p>Enabled/Disabled by </p>
<p>XCP_xxx_GET_SESSION_STATUS_API</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>46 / 109 </p>
<p><b>6.3.4 </b></p>
<p><b>XcpSetActiveTl: Set the active Transport Layer </b></p>
<p><b>XcpSetActiveTl </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpSetActiveTl  </b>( uint8 MaxCto, uint8 MaxDto, uint8 ActiveTl ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>MaxCto </p>
<p>Max CTO used by the respective XCP Transport Layer </p>
<p>MaxDto </p>
<p>Max DTO used by the respective XCP Transport Layer </p>
<p>ActiveTl </p>
<p>XCP_TRANSPORT_LAYER_CAN:</p>
<p> XCP on CAN Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_FR:</p>
<p> XCP on Fr Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_ETH:</p>
<p> XCP on Ethernet Transport Layer</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Set the active Transport Layer the XCP Protocol Layer uses. </p>
<p>This service is used by the XCP Transport Layers to set the Transport Layer to be used by the </p>
<p>XCP Protocol Layer </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.3.5 </b></p>
<p><b>XcpGetActiveTl: Set the active Transport Layer </b></p>
<p><b>XcpGetActiveTl </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpGetActiveTl  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_TRANSPORT_LAYER_CAN:</p>
<p> XCP on CAN Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_FR:</p>
<p> XCP on Fr Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_ETH:</p>
<p> XCP on Ethernet Transport Layer</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>47 / 109 </p>
<p><b>Functional Description </b></p>
<p>Get the active Transport Layer the XCP Protocol Layer uses. </p>
<p>This service is used by the XCP Transport Layers to get the currently active Transport Layer used </p>
<p>by the XCP Protocol Layer </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p> </p>
<p><b>6.4 </b></p>
<p><b>XCP Transport Layer Services called by the XCP Protocol Layer </b></p>
<p>The prototypes of the functions that are required by the XCP Protocol Layer can be found in the </p>
<p>component’s header. </p>
<p> </p>
<p><b>6.4.1 </b></p>
<p><b>&lt;Bus&gt;XcpSend: Request for the transmission of a DTO or CTO message </b></p>
<p><b>&lt;Bus&gt;XcpSend </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>&lt;Bus&gt;XcpSend  </b>( uint8 len, ROMBYTEPTR msg ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>len </p>
<p>Length of message data </p>
<p>msg </p>
<p>Pointer to message </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0</p>
<p> : if the XCP Protocol Layer is idle (no transmit messages are </p>
<p>pending) </p>
<p><b>Functional Description </b></p>
<p>Requests for the transmission of a command transfer object (CTO) or data transfer object (DTO). </p>
<p>XcpSendCallBack</p>
<p> must be called after the successful transmission of any XCP message. The </p>
<p>XCP Protocol Layer will not request further transmissions, until </p>
<p>XcpSendCallBack</p>
<p> has been </p>
<p>called. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant)</p>
<p> </p>
<p><b>&gt; </b></p>
<p>&lt;Bus&gt;XcpSend </p>
<p>is not defined as macro</p>
<p> </p>
<p> </p>
<p><b>6.4.2 </b></p>
<p><b>&lt;Bus&gt;XcpSendFlush: Flush transmit buffer </b></p>
<p><b>&lt;Bus&gt;XcpSendFlush </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>48 / 109 </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>&lt;Bus&gt;XcpSendFlush  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Flush the transmit buffer.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The function can be overwritten by the macro </p>
<p>&lt;Bus&gt;XcpSendFlush()</p>
<p> </p>
<p> </p>
<p><b>6.4.3 </b></p>
<p><b>ApplXcpInterruptEnable: Enable interrupts </b></p>
<p><b>ApplXcpInterruptEnable </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>ApplXcpInterruptEnable  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Enabling of the global interrupts. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This function is reentrant! </p>
<p><b>&gt; </b></p>
<p>The function </p>
<p>ApplXcpInterruptEnable</p>
<p> can be overwritten by the macro </p>
<p>ApplXcpInterruptEnable</p>
<p>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>49 / 109 </p>
<p><b>6.4.4 </b></p>
<p><b>ApplXcpInterruptDisable: Disable interrupts </b></p>
<p><b>ApplXcpInterruptDisable </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>ApplXcpInterruptDisable  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Disabling of the global interrupts. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This function is reentrant! </p>
<p><b>&gt; </b></p>
<p>The function </p>
<p>ApplXcpInterruptDisable</p>
<p> can be overwritten by the macro </p>
<p>ApplXcpInterruptDisable</p>
<p>. </p>
<p> </p>
<p><b>6.4.5 </b></p>
<p><b>&lt;Bus&gt;XcpTLService: Transport Layer specific commands </b></p>
<p><b>&lt;Bus&gt;XcpTLService </b></p>
<p>Prototype </p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>&lt;Bus&gt;XcpTLService  </b>( ROMBYTEPTR  pCmd ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p>Parameter </p>
<p>pCmd </p>
<p>Pointer to COMMAND that has been received by the XCP Slave. </p>
<p>Return code </p>
<p>uint8 </p>
<p>XCP_CMD_OK </p>
<p>:  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Done </p>
<p>XCP_CMD_PENDING</p>
<p> :   </p>
<p> </p>
<p> </p>
<p> </p>
<p>Call XcpSendCrm() when done </p>
<p>XCP_CMD_SYNTAX</p>
<p> :  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Error </p>
<p>XCP_CMD_BUSY</p>
<p> :   </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>not executed </p>
<p>XCP_CMD_UNKNOWN</p>
<p> :   </p>
<p> </p>
<p> </p>
<p> </p>
<p>not implemented optional command </p>
<p>XCP_CMD_OUT_OF_RANGE </p>
<p>:  command parameters out of range </p>
<p>Functional Description </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>50 / 109 </p>
<p>Transport Layer specific command that is processed within the XCP Transport Layer. </p>
<p> </p>
<p>Particularities and Limitations </p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_TL_COMMAND</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5 </b></p>
<p><b>Application Services called by the XCP Protocol Layer </b></p>
<p>The prototypes of the functions that are required by the XCP Protocol Layer can be found </p>
<p>in the header. </p>
<p>The  XCP  Protocol  Layer  provides  application  callback  functions  in  order  to  perform </p>
<p>application and hardware specific tasks. </p>
<p>Note: All services within this chapter are called from task or interrupt level. All services are </p>
<p>not reentrant. </p>
<p><b>6.5.1 </b></p>
<p><b>ApplXcpGetPointer: Pointer conversion </b></p>
<p><b>ApplXcpGetPointer </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>MTABYTEPTR <b>ApplXcpGetPointer  </b>( uint8 addr_ext, uint32 addr ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr_ext </p>
<p>8 bit address extension </p>
<p>addr </p>
<p>32 bit address </p>
<p><b>Return code </b></p>
<p>MTABYTEPTR </p>
<p>Pointer to the address specified by the parameters </p>
<p><b>Functional Description </b></p>
<p>This function converts a memory address from XCP format (32-bit address plus 8-bit address </p>
<p>extension) to a C style pointer. An MCS like CANape usually reads this memory addresses from </p>
<p>the ASAP2 database or from a linker map file. </p>
<p>The address extension may be used to distinguish different address spaces or memory types. In </p>
<p>most cases, the address extension is not used and may be ignored. </p>
<p>This function is used for memory transfers like DOWNLOAD and UPLOAD. </p>
<p>Example:  </p>
<p>The following code shows an example of a typical implementation of </p>
<p>ApplXcpGetPointer</p>
<p>: </p>
<p>MTABYTEPTR ApplXcpGetPointer( uint8 addr_ext, uint32 addr ) </p>
<p>{ </p>
<p>  return (MTABYTEPTR)addr; </p>
<p>} </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>51 / 109 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten by defining </p>
<p>ApplXcpGetPointer</p>
<p> as macro. </p>
<p> </p>
<p><b>6.5.2 </b></p>
<p><b>ApplXcpGetIdData: Get Identification </b></p>
<p><b>ApplXcpGetIdData </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint32 <b>ApplXcpGetIdData  </b>( MTABYTEPTR *pData, uint8 id ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pData </p>
<p>Pointer to identification information </p>
<p>id </p>
<p>Id of requested information </p>
<p><b>Return code </b></p>
<p>uint32 </p>
<p>length of identification information </p>
<p><b>Functional Description </b></p>
<p>Returns a pointer to identification information. </p>
<p>Refer to chapter 3.4.2.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_GET_ID_GENERIC </p>
<p>has to be defined </p>
<p> </p>
<p><b>6.5.3 </b></p>
<p><b>ApplXcpGetSeed: Generate a seed </b></p>
<p><b>ApplXcpGetSeed </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 ApplXcpGetSeed  ( const uint8 resource, </p>
<p> P2VAR(uint8, AUTOMATIC, XCP_APPL_DATA) seed ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>52 / 109 </p>
<p><b>Parameter </b></p>
<p>Resource </p>
<p>Resource for which the seed has to be generated </p>
<p>XCP Professional and XPC Basic </p>
<p>RM_CAL_PAG</p>
<p> :  </p>
<p>to unlock the resource calibration/paging </p>
<p>RM_DAQ</p>
<p> :  </p>
<p>to unlock the resource data acquisition </p>
<p>XCP Professional only </p>
<p>RM_STIM</p>
<p> : </p>
<p>to unlock the resource stimulation </p>
<p>RM_PGM</p>
<p> :  </p>
<p>to unlock the resource programming </p>
<p>Seed </p>
<p>Pointer to RAM where the seed has to be generated to. </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>The length of the generated seed that is returned by <i>seed</i>. </p>
<p><b>Functional Description </b></p>
<p>Generate a seed for the appropriate resource. </p>
<p>The seed has a maximum length of MAX_CTO-2 bytes.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SEED_KEY</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.4 </b></p>
<p><b>ApplXcpUnlock: Valid key and unlock resource </b></p>
<p><b>ApplXcpUnlock </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 ApplXcpUnlock  (P2CONST(uint8, AUTOMATIC, </p>
<p>XCP_APPL_DATA) key, const uint8 length )</p>
<p> </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>key </p>
<p>Pointer to the key. </p>
<p>length </p>
<p>Length of the key. </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP Professional and XPC Basic </p>
<p>0</p>
<p> :  </p>
<p>if the key is not valid </p>
<p>RM_CAL_PAG</p>
<p> :  </p>
<p>to unlock the resource calibration/paging </p>
<p>RM_DAQ</p>
<p> :  </p>
<p>to unlock the resource data acquisition </p>
<p>XCP Professional only </p>
<p>RM_STIM</p>
<p> : </p>
<p>to unlock the resource stimulation </p>
<p>RM_PGM</p>
<p> :  </p>
<p>to unlock the resource programming </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>53 / 109 </p>
<p><b>Functional Description </b></p>
<p>Check the key and return the resource that has to be unlocked. </p>
<p>Only one resource may be unlocked at one time.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SEED_KEY</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.5 </b></p>
<p><b>ApplXcpCheckReadEEPROM: Check read access from EEPROM </b></p>
<p><b>ApplXcpCheckReadEEPROM </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCheckReadEEPROM  </b>( MTABYTEPTR addr, </p>
<p> </p>
<p>uint8 size, </p>
<p> </p>
<p>BYTEPTR data )</p>
<p> </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>Address that is checked </p>
<p>size </p>
<p>Number of bytes </p>
<p>data </p>
<p>Pointer to data </p>
<p>(if the address is on the EEPROM the data is written here) </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>EEPROM read </p>
<p>XCP_CMD_DENIED</p>
<p> :  This is not EEPROM </p>
<p>XCP_CMD_PENDING</p>
<p> :  EEPROM read in progress, call </p>
<p>XcpSendCrm</p>
<p>  </p>
<p> </p>
<p>when done</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Checks whether the address lies within the EEPROM memory or in the RAM area. </p>
<p>If the area is within the EEPROM area </p>
<p>size</p>
<p> data byte are read from </p>
<p>addr</p>
<p> and written to </p>
<p>data</p>
<p>.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_READ_EEPROM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.6 </b></p>
<p><b>ApplXcpCheckWriteEEPROM: Check write access to the EEPROM </b></p>
<p><b>ApplXcpCheckWriteEEPROM </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCheckWriteEEPROM  </b>( MTABYTEPTR addr, </p>
<p> </p>
<p>uint8 size,</p>
<p> </p>
<p>ROMBYTEPTR data)</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>54 / 109 </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>Address that is checked </p>
<p>size </p>
<p>number of bytes </p>
<p>data </p>
<p>pointer to data </p>
<p>(if </p>
<p>addr</p>
<p> is on the EEPROM this data is written to </p>
<p>addr</p>
<p>) </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>EEPROM written </p>
<p>XCP_CMD_DENIED</p>
<p> :  This is not EEPROM </p>
<p>XCP_CMD_PENDING</p>
<p> :  EEPROM write in progress, call </p>
<p>XcpSendCrm</p>
<p>  </p>
<p> </p>
<p>when done </p>
<p><b>Functional Description </b></p>
<p>Checks whether the address </p>
<p>addr</p>
<p> is within the EEPROM memory. If not, the function returns </p>
<p>XCP_CMD_DENIED</p>
<p>. If it lies within, EEPROM programming is performed. The function may return </p>
<p>during programming with </p>
<p>XCP_CMD_PENDING</p>
<p> or may wait until the programming sequence has </p>
<p>finished and then returns with </p>
<p>XCP_CMD_OK</p>
<p>.  </p>
<p>If the programming sequence has finished, the </p>
<p>XcpSendCrm</p>
<p> function must be called. </p>
<p>XcpSendCrm</p>
<p> is an internal function of the XCP Protocol Layer.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_WRITE_EEPROM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.7 </b></p>
<p><b>ApplXcpCheckWriteAccess: Check address for valid write access </b></p>
<p><b>ApplXcpCheckWriteAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCheckWriteAccess  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED </p>
<p>:   if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>55 / 109 </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid write access. A write access is enabled with the </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p>, it should be only used, if write protection of memory </p>
<p>areas is required </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Can be overwritten by the macro </p>
<p>ApplXcpCheckWriteAccess</p>
<p> </p>
<p> </p>
<p><b>6.5.8 </b></p>
<p><b>ApplXcpCheckReadAccess: Check address for valid read access </b></p>
<p><b>ApplXcpCheckReadAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCheckReadAccess  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED</p>
<p> : </p>
<p>if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid read access. A read access is enabled with the </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p>, it should be only used, if read protection of memory areas </p>
<p>is required </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Can be overwritten by the macro </p>
<p>ApplXcpCheckReadAccess</p>
<p> </p>
<p> </p>
<p><b>6.5.9 </b></p>
<p><b>ApplXcpCheckDAQAccess: Check address for valid read or write access </b></p>
<p><b>ApplXcpCheckDAQAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCheckDAQAccess  </b>( DAQBYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>56 / 109 </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED</p>
<p> : </p>
<p>if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid read or write access. This callback is called when a WRITE_DAQ </p>
<p>command is performed. Therefore it is not possible to know whether this is a read or write </p>
<p>access. Out of this reason this unified function is called. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p> or </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p> has to </p>
<p>be defined </p>
<p> </p>
<p><b>6.5.10 </b></p>
<p><b>ApplXcpCheckProgramAccess: Check address for valid write access </b></p>
<p><b>ApplXcpCheckProgramAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCheckProgramAccess  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>      uint32 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED</p>
<p> : </p>
<p>if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid write access. A write access is enabled with the </p>
<p>XCP_ENABLE_PROGRAMMING_WRITE_PROTECTION</p>
<p>, it should be only used, if write protection </p>
<p>of memory areas is required </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAMMING_WRITE_PROTECTION</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Can be overwritten by the macro </p>
<p>ApplXcpCheckWriteAccess</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>57 / 109 </p>
<p> </p>
<p><b>6.5.11 </b></p>
<p><b>ApplXcpUserService: User defined command </b></p>
<p><b>ApplXcpUserService </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpUserService </b>( ROMBYTEPTR pCmd ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pCmd </p>
<p>Pointer to XCP command packet </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>positive response </p>
<p>XCP_CMD_PENDING</p>
<p> :  Call XcpSendCrm() when done </p>
<p>XCP_CMD_SYNTAX</p>
<p> :  negative response </p>
<p><b>Functional Description </b></p>
<p>Application specific user command. </p>
<p>Please refer to 3.12 User Defined Command. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_USER_COMMAND</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.12 </b></p>
<p><b>ApplXcpOpenCmdIf: XCP command extension interface </b></p>
<p><b>ApplXcpOpenCmdIf </b></p>
<p>Prototype </p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpOpenCmdIf  </b>( ROMBYTEPTR  pCmd </p>
<p>BYTEPTR pRes, BYTEPTR pLength ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p>Parameter </p>
<p>pCmd </p>
<p>Pointer to COMMAND that has been received by the XCP Slave. </p>
<p>pRes </p>
<p>Pointer to response buffer that will be sent by the XCP Slave. </p>
<p>pLength </p>
<p>Number of bytes that will be sent in the response. </p>
<p>Return code </p>
<p>uint8 </p>
<p>XCP_CMD_OK </p>
<p>:  </p>
<p> </p>
<p> </p>
<p> </p>
<p>Done </p>
<p>XCP_CMD_PENDING </p>
<p>:  </p>
<p>Call XcpSendCrm() when done </p>
<p>XCP_CMD_ERROR</p>
<p> : </p>
<p> </p>
<p> </p>
<p>Error </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>58 / 109 </p>
<p>Functional Description </p>
<p>Call back that can be used to extend the XCP commands of the XCP protocol layer. </p>
<p> </p>
<p>Particularities and Limitations </p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_OPENCMDIF</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.13 </b></p>
<p><b>ApplXcpSendStall: Resolve a transmit stall condition </b></p>
<p><b>ApplXcpSendStall </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpSendStall  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p>Parameter </p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 :     if not successful </p>
<p>&gt; 0 :  successful </p>
<p><b>Functional Description </b></p>
<p>Resolve a transmit stall condition in </p>
<p>XcpPutchar</p>
<p> or </p>
<p>XcpSendEvent</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SEND_EVENT</p>
<p> or </p>
<p>XCP_ENABLE_SERV_TEXT_PUTCHAR</p>
<p> and </p>
<p>XCP_ENABLE_SEND_QUEUE</p>
<p> are defined </p>
<p><b>&gt; </b></p>
<p>The function can be overwritten by the macro </p>
<p>ApplXcpSendStall()</p>
<p> </p>
<p> </p>
<p><b>6.5.14 </b></p>
<p><b>ApplXcpDisableNormalOperation: Disable normal operation of the ECU </b></p>
<p><b>ApplXcpDisableNormalOperation </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpDisableNormalOperation  </b>( MTABYTEPTR a, </p>
<p> </p>
<p>uint16 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>59 / 109 </p>
<p><b>Parameter </b></p>
<p>a </p>
<p>Address (where the flash kernel is downloaded to) </p>
<p>size </p>
<p>Size (of the flash kernel) </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>download of flash kernel confirmed </p>
<p>XCP_CMD_DENIED</p>
<p> : download of flash kernel refused </p>
<p><b>Functional Description </b></p>
<p>Prior to the flash kernel download has the ECU’s normal operation to be stopped in order to </p>
<p>avoid misbehavior due to data inconsistencies. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_BOOTLOADER_DOWNLAOD</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.15 </b></p>
<p><b>ApplXcpStartBootLoader: Start of boot loader </b></p>
<p><b>ApplXcpStartBootLoader </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpStartBootLoader  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>This function should not return. </p>
<p>0</p>
<p> : </p>
<p>negative response </p>
<p>&gt; 0 </p>
<p>: </p>
<p>positive response </p>
<p><b>Functional Description </b></p>
<p>Start of the boot loader. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_BOOTLOADER_DOWNLAOD</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.16 </b></p>
<p><b>ApplXcpReset: Perform ECU reset </b></p>
<p><b>ApplXcpReset </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>ApplXcpReset  </b>( void ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>60 / 109 </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Perform an ECU reset after reprogramming of the application. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.17 </b></p>
<p><b>ApplXcpProgramStart: Prepare flash programming </b></p>
<p><b>ApplXcpProgramStart </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpProgramStart  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>Preparation done </p>
<p>XCP_CMD_PENDING </p>
<p>:  </p>
<p>Call XcpSendCrm() when done </p>
<p>XCP_CMD_ERROR</p>
<p> :  </p>
<p>Flash programming not possible </p>
<p><b>Functional Description </b></p>
<p>Prepare the ECU for flash programming. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.18 </b></p>
<p><b>ApplXcpFlashClear: Clear flash memory </b></p>
<p><b>ApplXcpFlashClear </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>61 / 109 </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpFlashClear  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>uint32 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>Address </p>
<p>size </p>
<p>Size </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK </p>
<p>: </p>
<p>Flash memory erase done </p>
<p>XCP_CMD_PENDING</p>
<p> :  Call XcpSendCrm() when done </p>
<p>XCP_CMD_ERROR</p>
<p> : </p>
<p>Flash memory erase error </p>
<p><b>Functional Description </b></p>
<p>Clear the flash memory, before the flash memory will be reprogrammed. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.19 </b></p>
<p><b>ApplXcpFlashProgram: Program flash memory </b></p>
<p><b>ApplXcpFlashProgram </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpFlashProgram  </b>( ROMBYTEPTR data, </p>
<p> </p>
<p>MTABYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>data </p>
<p>Pointer to data </p>
<p>address </p>
<p>Address </p>
<p>size </p>
<p>Size </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>Flash memory programming finished </p>
<p>XCP_CMD_PENDING </p>
<p>: Flash memory programming in progress. </p>
<p> </p>
<p>XcpSendCrm</p>
<p> has to be called when done. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>62 / 109 </p>
<p><b>Functional Description </b></p>
<p>Program the cleared flash memory. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.20 </b></p>
<p><b>ApplXcpDaqResume: Resume automatic data transfer </b></p>
<p><b>ApplXcpDaqResume </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpDaqResume  </b>( tXcpDaq * daq ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>daq </p>
<p>Pointer to dynamic DAQ list structure </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 : </p>
<p>failed </p>
<p>&gt;0 : </p>
<p>Ok </p>
<p><b>Functional Description </b></p>
<p>Resume the automatic data transfer. </p>
<p>The whole dynamic DAQ list structure that had been stored in non-volatile memory within the </p>
<p>service </p>
<p>ApplXcpDaqResumeStore(..)</p>
<p> has to be restored to RAM. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.21 </b></p>
<p><b>ApplXcpDaqResumeStore: Store DAQ lists for resume mode </b></p>
<p><b>ApplXcpDaqResumeStore </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void ApplXcpDaqResumeStore  (P2CONST(tXcpDaq, AUTOMATIC, </p>
<p>XCP_APPL_DATA) daq, uint16 size, uint8 measurementStart ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>daq </p>
<p>Pointer to dynamic DAQ list structure. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>63 / 109 </p>
<p>size </p>
<p>Size of DAQ data that needs to be stored </p>
<p>MeasurementStart </p>
<p>If &gt; 0 then set flag to start measurement during next init </p>
<p><b>Return code </b></p>
<p>-</p>
<p> </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This application callback service has to store the whole dynamic DAQ list structure in non-</p>
<p>volatile memory for the DAQ resume mode. Any old DAQ list configuration that might have </p>
<p>been stored in non-volatile memory before this command, must not be applicable anymore. </p>
<p>After a cold start or reset the dynamic DAQ list structure has to be restored by the application </p>
<p>callback service </p>
<p>ApplXcpDaqResume(..)</p>
<p> when the flag measurementStart is &gt; 0. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.22 </b></p>
<p><b>ApplXcpDaqResumeClear: Clear stored DAQ lists </b></p>
<p><b>ApplXcpDaqResumeClear </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>ApplXcpDaqResumeClear  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>-</p>
<p> </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The whole dynamic DAQ list structure that had been stored in non-volatile memory within the </p>
<p>service </p>
<p>ApplXcpDaqResumeStore(..)</p>
<p> has to be cleared. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.23 </b></p>
<p><b>ApplXcpCalResumeStore: Store Calibration data for resume mode </b></p>
<p><b>ApplXcpCalResumeStore </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCalResumeStore  </b>( void ) </p>
<p>Multi Channel </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>64 / 109 </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>-</p>
<p> </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 :    Storing not yet finished (STORE_CAL_REQ flag kept) </p>
<p>&gt;0 :  Storing finished (STORE_CAL_REQ flag cleared) </p>
<p><b>Functional Description </b></p>
<p>This application callback service has to store the current calibration data in non-volatile </p>
<p>memory for the resume mode. </p>
<p>After a cold start or reset the calibration data has to be restored by the application. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.24 </b></p>
<p><b>ApplXcpGetTimestamp: Returns the current timestamp </b></p>
<p><b>ApplXcpGetTimestamp </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>XcpDaqTimestampType <b>ApplXcpGetTimestamp  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>XcpDaqTimestampType </p>
<p>timestamp </p>
<p><b>Functional Description </b></p>
<p>Returns the current timestamp. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p> are defined </p>
<p><b>&gt; </b></p>
<p>The parameter </p>
<p>kXcpDaqTimestampSize</p>
<p> defines the timestamp size. It can either be </p>
<p>DAQ_TIMESTAMP_BYTE, DAQ_TIMESTAMP_WORD, DAQ_TIMESTAMP_DWORD</p>
<p> </p>
<p> </p>
<p><b>6.5.25 </b></p>
<p><b>ApplXcpGetCalPage: Get calibration page </b></p>
<p><b>ApplXcpGetCalPage </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>65 / 109 </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpGetCalPage  </b>( uint8 segment, uint8 mode ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>segment </p>
<p>Logical data segment number </p>
<p>mode </p>
<p>Access mode </p>
<p>The access mode can be one of the following values: </p>
<p>CAL_ECU</p>
<p> : ECU access </p>
<p>CAL_XCP</p>
<p> : XCP access </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Logical data page number </p>
<p><b>Functional Description </b></p>
<p>This function returns the logical number of the calibration data page that is currently activated </p>
<p>for the specified access mode and data segment. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.26 </b></p>
<p><b>ApplXcpSetCalPage: Set calibration page </b></p>
<p><b>ApplXcpSetCalPage </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpSetCalPage  </b>( uint8 segment, </p>
<p> </p>
<p>uint8 page, uint8 mode ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>segment </p>
<p>Logical data segment number </p>
<p>Page </p>
<p>Logical data page number </p>
<p>mode </p>
<p>Access mode </p>
<p>CAL_ECU</p>
<p> : the given page will be used by the slave device application </p>
<p>CAL_XCP</p>
<p> : the slave device XCP driver will access the given page </p>
<p>Both flags may be set simultaneously or separately. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>66 / 109 </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 :  </p>
<p>Ok </p>
<p>CRC_OUT_OF_RANGE</p>
<p> :  </p>
<p>segment out of range </p>
<p> </p>
<p>( only one segment supported) </p>
<p>CRC_PAGE_NOT_VALID</p>
<p> :  </p>
<p>Selected page not available </p>
<p>CRC_PAGE_MODE_NOT_VALID</p>
<p> :  </p>
<p>Selected page mode not available </p>
<p><b>Functional Description </b></p>
<p>Set the access mode for a calibration data segment. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.27 </b></p>
<p><b>ApplXcpCopyCalPage: Copying of calibration data pages </b></p>
<p><b>ApplXcpCopyCalPage </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpCopyCalPage  </b>( uint8 srcSeg, uint8 srcPage </p>
<p> </p>
<p>uint8 destSeg, uint8 destPage ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>srcSeg </p>
<p>Source segment </p>
<p>srcPage </p>
<p>Source page </p>
<p>destSeg </p>
<p>Destination segment </p>
<p>destPage </p>
<p>Destination page </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 :  </p>
<p>Ok </p>
<p>XCP_CMD_PENDING</p>
<p> :  </p>
<p>Call XcpSendCrm() when done </p>
<p>CRC_PAGE_NOT_VALID</p>
<p> :  </p>
<p>Page not available </p>
<p>CRC_SEGMENT_NOT_VALID</p>
<p> :  Segment not available </p>
<p>CRC_WRITE_PROTECTED </p>
<p>:  </p>
<p>Destination page is write protected. </p>
<p><b>Functional Description </b></p>
<p>Copying of calibration data pages. </p>
<p>The pages are copied from source to destination. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_PAGE_COPY</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMEOUT</p>
<p> are defined </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>67 / 109 </p>
<p> </p>
<p><b>6.5.28 </b></p>
<p><b>ApplXcpSetFreezeMode: Setting the freeze mode of a segment </b></p>
<p><b>ApplXcpSetFreezeMode </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>ApplXcpSetFreezeMode </b>( uint8 segment, uint8 mode ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>segment </p>
<p>Segment to set freeze mode </p>
<p>mode </p>
<p>New freeze mode </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Setting the freeze mode of a certain segment. Application must store the current freeze mode </p>
<p>of each segment. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_PAGE_FREEZE</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.29 </b></p>
<p><b>ApplXcpGetFreezeMode: Reading the freeze mode of a segment </b></p>
<p><b>ApplXcpGetFreezeMode </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>ApplXcpGetFreezeMode </b>( uint8 segment ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>segment </p>
<p>Segment to read freeze mode </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Return the current freeze mode, set by ApplXcpSetFreezeMode(). </p>
<p><b>Functional Description </b></p>
<p>Reading the freeze mode of a certain segment. Application must store the current freeze mode </p>
<p>of each segment and report it by the return value of this function. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_PAGE_FREEZE</p>
<p> is defined </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>68 / 109 </p>
<p> </p>
<p><b>6.5.30 </b></p>
<p><b>ApplXcpRead: Read a single byte from memory </b></p>
<p><b>ApplXcpRead </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>ApplXcpRead  </b>( uint32 addr ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>32 Bit address </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Pointer to the address specified by the parameters </p>
<p><b>Functional Description </b></p>
<p>Read a single byte from the memory. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_MEM_ACCESS_BY_APPL</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.31 </b></p>
<p><b>ApplXcpWrite: Write a single byte to RAM </b></p>
<p><b>ApplXcpWrite </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>void <b>ApplXcpWrite  </b>( uint32 addr, uint8 data ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>32 Bit address </p>
<p>data </p>
<p>data to be written to memory </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Write a single byte to RAM. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>69 / 109 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_MEM_ACCESS_BY_APPL</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.32 </b></p>
<p><b>ApplXcpCalibrationRead: Read multiple bytes from memory </b></p>
<p><b>ApplXcpCalibrationRead </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>ApplXcpCalibrationRead  </b>( MTABYTEPTR addr, uint8 size, </p>
<p>BYTEPTR data ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>Address pointer </p>
<p>Size </p>
<p>Number of bytes to read </p>
<p>Data </p>
<p>Pointer to data </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Protection code </p>
<p><b>Functional Description </b></p>
<p>Read multiple bytes from memory. Please note that this service is only used for polling mode. </p>
<p>DAQ reads directly to memory. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL </p>
<p>is defined </p>
<p> </p>
<p><b>6.5.33 </b></p>
<p><b>ApplXcpCalibrationWrite: Write multiple bytes to memory </b></p>
<p><b>ApplXcpCalibrationWrite </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>ApplXcpCalibrationWrite  </b>( MTABYTEPTR addr, uint8 size, </p>
<p>ROMBYTEPTR data ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>Address pointer </p>
<p>Size </p>
<p>Number of bytes to write </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>70 / 109 </p>
<p>Data </p>
<p>Pointer to data </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Protection code </p>
<p><b>Functional Description </b></p>
<p>Write multiple bytes to memory. Please note that this service is only used for polling mode. </p>
<p>STIM writes directly to memory. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL </p>
<p>is defined </p>
<p> </p>
<p><b>6.5.34 </b></p>
<p><b>ApplXcpReadChecksumValue: Read checksum value </b></p>
<p><b>ApplXcpReadChecksumValue </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>tXcpChecksumAddType <b>ApplXcpReadChecksumValue  </b>( uint32 addr </p>
<p>) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Addr </p>
<p>Address pointer </p>
<p><b>Return code </b></p>
<p>tXcpChecksumAddType </p>
<p>New value for checksum calculation </p>
<p><b>Functional Description </b></p>
<p>This function is used to access checksum values when no direct access to memory is allowed. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL </p>
<p>is defined </p>
<p> </p>
<p><b>6.5.35 </b></p>
<p><b>ApplXcpCalculateChecksum: Custom checksum calculation </b></p>
<p><b>ApplXcpCalculateChecksum </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>ApplXcpCalculateChecksum  </b>( ROMBYTEPTR pMemArea, </p>
<p>BYTEPTR pRes, uint32 length ) </p>
<p>Multi Channel </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>71 / 109 </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pMemArea </p>
<p>Address pointer </p>
<p>pRes </p>
<p>Pointer to response string </p>
<p>Length </p>
<p>Length of mem area, used for checksum calculation </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK/XCP_CMD_PENDING</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Normally the XCP uses internal checksum calculation functions. If the internal checksum </p>
<p>calculation does not fit the user requirements this call-back can be used to calculate the </p>
<p>checksum by the application. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CHECKSUM </p>
<p>and</p>
<p> XCP_ENABLE_CUSTOM_CRC </p>
<p>is defined </p>
<p> </p>
<p><b>6.6 </b></p>
<p><b>XCP Protocol Layer Functions that can be overwritten </b></p>
<p>The following functions are defined within the XCP Protocol Layer and can be overwritten </p>
<p>for optimization purposes. </p>
<p>Note: All services within this chapter are called from task or interrupt level. All services are </p>
<p>not reentrant. </p>
<p> </p>
<p><b>6.6.1 </b></p>
<p><b>XcpMemCpy: Copying of a memory range </b></p>
<p><b>XcpMemCpy </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpMemCpy  </b>( DAQBYTEPTR dest,  </p>
<p>ROMDAQBYTEPTR src, uint8 n ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>dest </p>
<p>pointer to destination address </p>
<p>src </p>
<p>pointer to source address </p>
<p>n </p>
<p>number of data bytes to copy </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>72 / 109 </p>
<p><b>Functional Description </b></p>
<p>General memory copy function that copies a memory range from source to destination. </p>
<p>This function is used in the inner loop of </p>
<p>XcpEvent</p>
<p> for data acquisition sampling. </p>
<p>This function is already defined in the XCP Protocol Layer, but can be overwritten by a macro or </p>
<p>function for optimization purposes. E.g. it would be possible to use DMA for faster execution. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten </p>
<p>XcpMemCpy</p>
<p> is defined. </p>
<p> </p>
<p><b>6.6.2 </b></p>
<p><b>XcpMemSet: Initialization of a memory range </b></p>
<p><b>XcpMemSet </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpMemSet  </b>( BYTEPTR p, uint16 n, uint8 b ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>p </p>
<p>pointer to start address </p>
<p>n </p>
<p>number of data bytes </p>
<p>b </p>
<p>data byte to initialize with </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialization of </p>
<p>n</p>
<p> bytes starting from address </p>
<p>p</p>
<p> with </p>
<p>b</p>
<p>. </p>
<p>This function is already defined in the XCP Protocol Layer, but can be overwritten by a macro or </p>
<p>function for optimization purposes. E.g. it would be possible to use DMA for faster execution. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten if </p>
<p>XcpMemSet</p>
<p> is defined. </p>
<p> </p>
<p><b>6.6.3 </b></p>
<p><b>XcpMemClr: Clear a memory range </b></p>
<p><b>XcpMemClr </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>static void <b>XcpMemClr  </b>( BYTEPTR p, uint16 n ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>73 / 109 </p>
<p><b>Parameter </b></p>
<p>p </p>
<p>pointer to start address </p>
<p>n </p>
<p>number of data bytes </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialize </p>
<p>n</p>
<p> data bytes starting from address </p>
<p>p</p>
<p> with </p>
<p>0x00</p>
<p>. </p>
<p>This function is already defined in the XCP Protocol Layer, but can be overwritten by a macro or </p>
<p>function for optimization purposes. E.g. it would be possible to use DMA for faster execution. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten if </p>
<p>XcpMemClr</p>
<p> is defined. </p>
<p> </p>
<p><b>6.6.4 </b></p>
<p><b>XcpSendDto: Transmission of a data transfer object </b></p>
<p><b>XcpSendDto </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpSendDto  </b>(const xcpDto_t *dto ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>dto </p>
<p>pointer to data transfer object </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Transmit a data transfer object (DTO). </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_DAQ </p>
<p>is defined </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten by defining </p>
<p>XcpSendDto</p>
<p>. </p>
<p> </p>
<p> </p>
<p><b>6.7 </b></p>
<p><b>AUTOSAR CRC Module Services called by the XCP Protocol Layer (XCP </b></p>
<p><b>Professional Only) </b></p>
<p>The  following  services  of  the  AUTOSAR  CRC  Module  are  called  by  the  XCP  Protocol </p>
<p>Layer: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>74 / 109 </p>
<p>Crc_CalculateCRC16(…) </p>
<p>Crc_CalculateCRC32(…) </p>
<p>A  detailed  description  of  the API  can  be  found  in  the  software  specification  of  the  CRC </p>
<p>Module [VII]. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>75 / 109 </p>
<p><b>7 </b></p>
<p><b>Configuration of the XCP Protocol Layer </b></p>
<p>This chapter describes the common options for configuring (customizing) the XCP Protocol </p>
<p>Layer. Please note that the XCP Professional can conveniently be configured with GENy </p>
<p>(chapter 7.1). In this case no manual configuration has to be applied to the configuration </p>
<p>files. </p>
<p> </p>
<p>The configuration of the XCP Protocol Layer without GENy can be found in chapter 7.2.It </p>
<p>is mainly applicable for the configuration of XCP Basic. </p>
<p><b>7.1 </b></p>
<p><b>Configuration with GENy (XCP Professional only) </b></p>
<p>The XCP Protocol Layer is a higher software layer that can be configured independent of </p>
<p>the communication system channels. Therefore in GENy the Protocol Layer component is </p>
<p>attached  to  the  ECU.  I.e.  it  can  be  configured  without  associating  any  XCP  Transport </p>
<p>Layer in GENy. </p>
<p>Therefore there are no database attributes defined for the XCP Protocol Layer. </p>
<p><b>7.1.1 </b></p>
<p><b>Component Selection </b></p>
<p>The following figure shows the selection of the XCP Protocol Layer component: </p>
<p> </p>
<p>Figure 7-1 Component selection in GENy </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>76 / 109 </p>
<p><b>7.1.2 </b></p>
<p><b>Component Configuration </b></p>
<p><b>7.1.2.1 </b></p>
<p><b>General Settings </b></p>
<p> </p>
<p> </p>
<p> </p>
<p>Figure 7-2 Component configuration – General settings </p>
<p> </p>
<p><b>Configuration option </b></p>
<p><b>Description of configuration option </b></p>
<p>XCP Station Identifier </p>
<p>The 'XCP Station Identifier' is an ASAM-MC2 filename without path </p>
<p>and extension that identifies the ECU's software program version. </p>
<p>It is used for slave device identification and automatic session </p>
<p>configuration. </p>
<p>The Master Control System (MCS) can interpret this identifier as file </p>
<p>name for the ECU database. The ECU developer should change the </p>
<p>XCP station identifier with each program change. This will prevent </p>
<p>database mix-ups and grant the correct access of measurement and </p>
<p>calibration objects from the MCS to the ECU. </p>
<p>Another benefit of the usage of the XCP station identifier is the </p>
<p>automatic assignment of the correct ECU database at program start </p>
<p>of the MCS via the Plug&amp;Play mechanism. The Plug&amp;Play </p>
<p>mechanism prevents the user to choose the wrong ECU database. </p>
<p>Command Parameter </p>
<p>Check </p>
<p>Checks of the range and validity of Command Transfer Object (CTO) </p>
<p>and Data Transfer Object (DTO) parameters. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>77 / 109 </p>
<p>Enable Calibration </p>
<p>The option 'Enable Calibration' unlocks the commands </p>
<p>- DOWNLOAD </p>
<p>- DOWNLOAD_NEXT </p>
<p>- DOWNLOAD_MAX </p>
<p>- SHORT_DOWNLOAD </p>
<p>- MODIFY_BITS </p>
<p>If this option is disabled, these commands will return an </p>
<p>ERR_ACCESS_DENIED error and calibration of parameters will not </p>
<p>be possible! </p>
<p>Event Codes </p>
<p>'Event Codes' are transmitted within event packets (EV) from the </p>
<p>slave device to the master device. </p>
<p>The transmission is not guaranteed since event packets are not </p>
<p>acknowledged. </p>
<p>Please refer to the XCP Protocol Layer specification for the 'Table of </p>
<p>Event codes'. </p>
<p>Bootloader Download </p>
<p>In order to reprogram the internal flash of some microcontrollers it is </p>
<p>necessary to use a bootloader, because code cannot be executed </p>
<p>from flash while programming flash. </p>
<p>Memory Write Protection </p>
<p>The option 'Memory Write Protection' enables write access to memory </p>
<p>areas. </p>
<p>I.e. prior to carrying out write access to RAM an application callback </p>
<p>function is called and the memory address is passed as parameter. </p>
<p>The application has to either grant or deny the memory access. </p>
<p>Memory Read Protection </p>
<p>The option 'Memory Read Protection' enables read access to memory </p>
<p>areas. </p>
<p>I.e. prior to carrying out read access to RAM an application callback </p>
<p>function is called and the memory address is passed as parameter. </p>
<p>The application has to either grant or deny the memory access. </p>
<p>XCP Control </p>
<p>The option ‘XCP Control’ enables an API to en- or disable the XCP </p>
<p>module (s. 3.22). </p>
<p>Get Xcp Data Pointer </p>
<p>The option ‘Get Xcp Data Pointer’ enables an API to retrieve the </p>
<p>pointer to the internal data of the XCP module (s. 3.21) </p>
<p>Open Command </p>
<p>Interface </p>
<p>The ‘Open Command Interface’ can be used to add unsupported XCP </p>
<p>commands. A user call back is made available which must be </p>
<p>implemented in the application. </p>
<p>Memory Mapping </p>
<p>Support </p>
<p>Each code section (e.g. RAM and ROM variables, functions, etc.) is </p>
<p>classified by its type (e.g. 8Bit RAM, 16Bit ROM, Code, etc.). </p>
<p>If you enable this option, each code section will be enclosed in </p>
<p>special memory mapping sections. This allows to manage the </p>
<p>resources of the component more efficiently. </p>
<p>Version Info API </p>
<p>The 'Version Info Api' option provides access to the version </p>
<p>information of the XCP Transport Layer module. Provided </p>
<p>informations are Module identifier, Vendor identifier and vendor </p>
<p>specific Version numbers. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>78 / 109 </p>
<p>User Config File </p>
<p>The configuration file </p>
<p>xcp_cfg.h</p>
<p> is generated by GENy. If you want </p>
<p>to overwrite settings in the generated configuration file, you can </p>
<p>specify a path to a user defined configuration file. </p>
<p>The user defined configuration file will be included at the end of the </p>
<p>generated file. Therefore definitions in the user defined configuration </p>
<p>file can overwrite definitions in the generated configuration file. </p>
<p>Generic Measurement </p>
<p>Generic Measurement is an extension which allows the Master to </p>
<p>take addresses for an a2l update directly from the ECU instead of the </p>
<p>map file. </p>
<p>Session Status API  </p>
<p> This API allows to determine the session status of the XCP. It can be </p>
<p>used to check the status in order to keep the ECU awake. </p>
<p>Vx1000 Support </p>
<p>Provide basic support for the Vx1000 measurement hardware. </p>
<p>If </p>
<p>enabled the Vx software package needs to be integrated additionally. The </p>
<p>Xcp driver then makes use of the functions provided by this package.</p>
<p><b> </b></p>
<p>EEPROM Access </p>
<p>Read Access </p>
<p>The option 'Read Access' allows read access to EEPROM. </p>
<p>The routines for accessing the EEPROM have to be implemented in </p>
<p>the application. </p>
<p>Write Access </p>
<p>The option 'Write Access' allows write access to EEPROM. </p>
<p>The routines for accessing the EEPROM have to be implemented in </p>
<p>the application. </p>
<p>Service Request Message </p>
<p>Service Request </p>
<p>Message </p>
<p>'Service Request Messages' are always transmitted within service </p>
<p>request packets (SERV) by the slave device, in order to request the </p>
<p>master device to perform some action. </p>
<p>The transmission is not guaranteed since service request packets are </p>
<p>not acknowledged by the master device. </p>
<p>Please also refer to the XCP Protocol Layer specification for the </p>
<p>'Table of service request codes </p>
<p>Print </p>
<p>The function </p>
<p>XcpPrint(..)</p>
<p> can be used for the transmission of </p>
<p>service request packets that contain text. </p>
<p>Table 7-1 Component configuration – General settings </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>79 / 109 </p>
<p><b>7.1.2.2 </b></p>
<p><b>Synchronous Data Acquisition </b></p>
<p> </p>
<p>Figure 7-3 Component configuration – Synchronous Data Acquisition </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>80 / 109 </p>
<p><b>Configuration option </b></p>
<p><b>Description of configuration option </b></p>
<p>Synchronous Data Acquisition </p>
<p>(DAQ) </p>
<p>Data elements located in the slave's memory are transmitted in </p>
<p>Data Transfer Objects (DTOs) from slave to master (DAQ) and </p>
<p>from master to slave (STIM). </p>
<p>The Object Description Table (ODT) describes the mapping </p>
<p>between the synchronous data transfer objects and the slave's </p>
<p>memory. </p>
<p>Send Queue </p>
<p>The ‘Send Queue’ should be enabled if more than one ODT </p>
<p>(Object Description Table) is used and if the Transport Layer </p>
<p>does not support data queuing or data buffering. </p>
<p>It has to be enabled if the Vector XCP Transport Layer for CAN </p>
<p>is enabled. </p>
<p>Replace First Element </p>
<p>If an overrun occurs the oldest element is replaced and </p>
<p>not the newest element which is the default behaviour.</p>
<p><b> </b></p>
<p>Memory Size [byte] </p>
<p>A memory area has to be reserved for the dynamic allocation of </p>
<p>DAQ and ODT (Object Description Table) lists and for the </p>
<p>transmit queue. </p>
<p>Prescaler </p>
<p>If the option 'Prescaler' is enabled all DAQ lists support the </p>
<p>prescaler for reducing the transmission period. </p>
<p>Overrun Indication </p>
<p>Overrun situations are indicated to the Master Control System. </p>
<p>An overrun situation is e.g. an overflow of the transmit queue. </p>
<p>Write DAQ Multiple </p>
<p>This command allows downloading multiple DAQ list entries in </p>
<p>one CMD frame. This option is only usefull when: </p>
<p>1. </p>
<p>MAX_CTO is at least 12 bytes in size for one entry or at </p>
<p>least 20 bytes for 2 or more entries. </p>
<p>2. </p>
<p>This feature is enabled in CANape (Extended driver </p>
<p>settings) </p>
<p>DAQ / ODT Message Header </p>
<p>If the option 'DAQ/ODT message header' is enabled the 2 byte </p>
<p>DAQ/ODT XCP Packet Identification is used: Relative ODT </p>
<p>number (1 byte), absolute DAQ list number (1 byte). </p>
<p>If the option 'DAQ/ODT message header' is disabled a 1 byte </p>
<p>Packet Identification (PID) is used: Absolute ODT number. </p>
<p>Attention: The 'DAQ/ODT Message Header' must not be </p>
<p>enabled if the XCP Transport Layer for CAN or FlexRay is </p>
<p>enabled. </p>
<p>Resume Mode </p>
<p>The option 'Resume Mode' or often also called 'Cold Start </p>
<p>Measurement' allows automatic data transfer (DAQ, STIM) </p>
<p>directly after power-up of the slave without prior connection to </p>
<p>the master calibration system. Also prior set calibration data can </p>
<p>be restored. </p>
<p>General Info </p>
<p>The option 'General Info' enables the XCP command </p>
<p>GET_DAQ_PROCESSOR_INFO, which provides general </p>
<p>information on DAQ lists. </p>
<p>Resolution Info </p>
<p>The option 'Resolution Info' enables the command </p>
<p>GET_DAQ_RESOLUTION_INFO, which provides information </p>
<p>on the resolution of DAQ lists. </p>
<p>Virtual Measurement </p>
<p>Virtual Measurement allows to have Address Information of </p>
<p>Measurement Values in the ECU. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>81 / 109 </p>
<p>Synchronous Data Stimulation (STIM) </p>
<p>Synchronous Data Stimulation </p>
<p>(STIM) </p>
<p>'Synchronous Data Stimulation (STIM)' is the inverse mode of </p>
<p>'Synchronous Data Acquisition (DAQ)'. </p>
<p>Data elements located in the slave's memory are transmitted in </p>
<p>Data Transfer Objects from the master device to the slave </p>
<p>device. </p>
<p>These data elements are written to RAM upon XCP events. </p>
<p>Number of ODTs for STIM </p>
<p>The maximum number of Object Descriptor Tables (ODTs) for </p>
<p>Synchronous Data Stimulation (STIM) has to be configured. </p>
<p>Event Info </p>
<p>Event Info </p>
<p>The option 'Event Info' allows to configure Plug &amp; Play </p>
<p>Information about event channels. This information is written to </p>
<p>XCP_events.a2l : </p>
<p><b>&gt; </b></p>
<p>Number of event channel </p>
<p><b>&gt; </b></p>
<p>Name of event channel </p>
<p><b>&gt; </b></p>
<p>Measurement cycle time of event channel </p>
<p>Direction of event channel: DAQ, STIM, DAQ&amp;STIM </p>
<p>Get DAQ Event Info </p>
<p>This option additionally enables the Xcp Command </p>
<p>GET_DAQ_EVENT_INFO. If this option is enabled the </p>
<p>numbering of Events is provided by the Configuration Tool and </p>
<p>cannot be freely configured. </p>
<p><b>&gt; </b></p>
<p> </p>
<p>Events </p>
<p>The information about event channels, which is transferred from </p>
<p>the slave device to the master device, can be configured. </p>
<p>Attention: The number of the event channels has to be dense </p>
<p>and zero-based </p>
<p>Event Channel </p>
<p>For each 'Event Channel' information can be configured. </p>
<p>This information is transferred from the slave device to the </p>
<p>master device. </p>
<p>Number </p>
<p>The event channel numbers is freely configurable if the option </p>
<p>“Get DAQ Event Info” is disabled. Otherwise it is dense and </p>
<p>zero-based. Therefore this number cannot be entered manually. </p>
<p>The event channel number is passed as an argument to the </p>
<p>function </p>
<p>XcpEvent(..)</p>
<p>. </p>
<p>Name </p>
<p>The name of the event channel is used to identify an event </p>
<p>within the master control system. </p>
<p>Cycle Time [Event Info Unit] </p>
<p>The 'Cycle Time' of the event channel is transferred to the </p>
<p>master control system and used to set up the master control </p>
<p>system. </p>
<p>Event Info Unit </p>
<p>Select the resolution of the time stamp ticks. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>82 / 109 </p>
<p>Direction </p>
<p>The following data acquisition 'Directions' of event channels are </p>
<p>possible: </p>
<p><b>&gt; </b></p>
<p>DAQ: send cyclic data transfer packets from the slave device </p>
<p>to the master control system </p>
<p><b>&gt; </b></p>
<p>STIM: send cyclic data transfer packets from the master </p>
<p>control system to the slave device </p>
<p><b>&gt; </b></p>
<p>DAQ/STIM: both directions are possible, but not </p>
<p>simultaneously </p>
<p>DAQ Timestamp </p>
<p>DAQ Timestamp </p>
<p>Timestamps can be attached to Data Transfer Object (DTO) </p>
<p>Packets, to avoid measurement errors due to bus latency. </p>
<p>The timestamp unit and ticks per unit have to be defined if </p>
<p>timestamps are used. </p>
<p>Fixed Timestamp </p>
<p>If the 'Fixed Timestamp' option is selected the slave always </p>
<p>sends Data Transfer Object (DTO) Packets in time stamped </p>
<p>mode. </p>
<p>Otherwise timestamps are dynamically and individually enabled </p>
<p>for each DAQ list. </p>
<p>Size [byte] </p>
<p>Size of Timestamp. Possible timestamp sizes are 1Byte, 2Bytes </p>
<p>and 4Bytes. </p>
<p>Timestamp Unit </p>
<p>Select the resolution of the time stamp ticks. </p>
<p>Ticks per Unit </p>
<p>The timestamp will increment per unit by the value specified </p>
<p>here and wrap around if an overflow occurs. </p>
<p>Table 7-2 Component configuration – Synchronous Data Acquisition </p>
<p> </p>
<p><b>7.1.2.3 </b></p>
<p><b>Standard Commands </b></p>
<p> </p>
<p> </p>
<p>Figure 7-4 Component configuration – Standard Commands </p>
<p> </p>
<p>Configuration option </p>
<p>Description of configuration option </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>83 / 109 </p>
<p>Communication Mode Info </p>
<p>The XCP command 'GET_COMM_MODE_INFO' returns </p>
<p>optional information on different Communication Modes </p>
<p>supported by the slave and also the version number of the </p>
<p>Protocol Layer implementation. </p>
<p>If the master block mode is supported, also the maximum </p>
<p>allowed block size and the minimum separation time are </p>
<p>returned. </p>
<p>The XCP Protocol Layer supports the Standard Communication </p>
<p>model and also the Master Block Transfer Mode and the Slave </p>
<p>Block Transfer Mode. </p>
<p>Seed &amp; Key </p>
<p>Resources within the slave device can be protected by a 'Seed </p>
<p>&amp; Key' mechanism. </p>
<p>The following resources can be protected: </p>
<p><b>&gt; </b></p>
<p>Synchronous data acquisition (DAQ) </p>
<p><b>&gt; </b></p>
<p>Synchronous data stimulation (STIM) </p>
<p><b>&gt; </b></p>
<p>Online calibration (CAL) </p>
<p><b>&gt; </b></p>
<p>Programming (PGM) </p>
<p>Modify Bits </p>
<p>This command can be en- or disabled. </p>
<p>Short Download </p>
<p>This command can be en- or disabled. For bus systems with </p>
<p>maximum data length less equal eight (e.g. CAN, LIN) this </p>
<p>command make no sense as no data can be transported in </p>
<p>addition to the address information. </p>
<p>User Defined Command </p>
<p>The 'User Defined Command' is optional and can be </p>
<p>implemented within the application. </p>
<p>However it must not be used to implement functionalities done </p>
<p>by other services. </p>
<p>The application callback function ApplXcpUserService() is </p>
<p>provided to perform application specific actions. </p>
<p>GET_ID Command </p>
<p>Slave identification via GET_ID Command.  </p>
<p>This option enables a call-back that is called when the </p>
<p>XCP Master sends the GET_ID command and can be </p>
<p>used to return the requested information (e.g. Map </p>
<p>Filename, EPK Number, ...) </p>
<p> </p>
<p>Transport Layer Command </p>
<p>The option 'Transport Layer Command' has to be enabled if </p>
<p>transport layer specific commands are used and supported by </p>
<p>the transport layer component. </p>
<p>Block Transfer </p>
<p>Block Upload </p>
<p>The Slave Block Transfer Mode speeds up memory upload by </p>
<p>transmitting an entire block of continuous response packets. </p>
<p>There is only a response packet before and after transmission </p>
<p>of the entire block. </p>
<p>There are no limitations allowed for the master device. </p>
<p>The slave returns whether it supports Slave Block Transfer </p>
<p>Model in the response of the request CONNECT. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>84 / 109 </p>
<p>Block Download </p>
<p>The Master Block Transfer Mode speeds up memory download </p>
<p>by transmitting an entire block of continuous request packets. </p>
<p>There is only one response packet after transmission of the </p>
<p>entire block. </p>
<p>The XCP Master has to meet the slave's limitations of the </p>
<p>maximum block size and the minimum separation time. These </p>
<p>communication parameters are responded within the response </p>
<p>to GET_COMM_MODE_INFO. </p>
<p>MIN_ST for Block Download </p>
<p>MIN_ST indicates the required minimum separation time </p>
<p>between the packets of a block transfer from the master device </p>
<p>to the slave device in units of 100 microseconds. </p>
<p>The value given in GENy is transmitted within the response to </p>
<p>the command GET_COMM_MODE_INFO. </p>
<p>Table 7-3 Component configuration – Standard Commands </p>
<p><b>7.1.2.4 </b></p>
<p><b>Checksum </b></p>
<p> </p>
<p> </p>
<p>Figure 7-5 Component configuration – Checksum </p>
<p> </p>
<p><b>Configuration option </b></p>
<p><b>Description of configuration option </b></p>
<p>Checksum </p>
<p>The XCP command BUILD_CHECKSUM returns a checksum </p>
<p>that is calculated over the memory block defined by the Memory </p>
<p>Transfer Address (MTA) and block size. The MTA will be post-</p>
<p>incremented by the block size. </p>
<p>The checksum type (size of the checksum) and the calculation </p>
<p>method can be configured. </p>
<p>Custom CRC Module Support </p>
<p>Support a custom CRC module by calling a user call-back. </p>
<p>Internal CRC calculation is deactivated. </p>
<p>AUTOSAR CRC Module </p>
<p>Support </p>
<p>If ‘AUTOSAR CRC Module Support’ is enabled only the </p>
<p>following checksum calculation methods are available: </p>
<p><b>&gt; </b></p>
<p>CRC16_CCITT: CRC16 CCITT algorithm </p>
<p><b>&gt; </b></p>
<p>CRC32: CRC32 algorithm </p>
<p>The CRC32 algorithm is only supported if the AUTOSAR CRC </p>
<p>Module is used. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>85 / 109 </p>
<p>Calculation Method </p>
<p>The following checksum calculation methods are supported: </p>
<p><b>&gt; </b></p>
<p>ADD_11: add a BYTE into a BYTE checksum </p>
<p><b>&gt; </b></p>
<p>ADD_12: add a BYTE into a WORD checksum </p>
<p><b>&gt; </b></p>
<p>ADD_14: add a BYTE into a DWORD checksum </p>
<p><b>&gt; </b></p>
<p>ADD_22: add a WORD into a WORD checksum </p>
<p><b>&gt; </b></p>
<p>ADD_24: add a WORD into a DWORD checksum </p>
<p><b>&gt; </b></p>
<p>ADD_44: add a DWORD into a DWORD checksum </p>
<p><b>&gt; </b></p>
<p>CRC16_CCITT: CRC16 CCITT algorithm </p>
<p><b>&gt; </b></p>
<p>CRC32: CRC32 algorithm </p>
<p>The CRC32 algorithm is only supported if the AUTOSAR CRC </p>
<p>Module is used. </p>
<p>All checksum calculation algorithms except of the CRC </p>
<p>algorithms ignore overflows. The block size has to be a multiple </p>
<p>of the size of the type that is added. </p>
<p>Block Size </p>
<p>Please refer to the help of 'Checksum'. </p>
<p>Table 7-4 Component configuration – Checksum </p>
<p> </p>
<p><b>7.1.2.5 </b></p>
<p><b>Page Switching </b></p>
<p> </p>
<p> </p>
<p>Figure 7-6 Component configuration – Page Switching </p>
<p> </p>
<p><b>Configuration option </b></p>
<p><b>Description of configuration option </b></p>
<p>Page Switching </p>
<p>If calibration page switching (PAG) is enabled the access mode </p>
<p>calibration data segments can be set. </p>
<p>Calibration data segments and their pages are specified by </p>
<p>logical numbers. </p>
<p>General Paging Info </p>
<p>If 'General Paging Info' is enabled the XCP command </p>
<p>'GET_PAG_PROCESSOR_INFO' returns general information </p>
<p>on paging. </p>
<p>The following information is transferred from the slave device to </p>
<p>the master device: </p>
<p><b>&gt; </b></p>
<p>The total number of segments </p>
<p><b>&gt; </b></p>
<p>Whether the freeze mode is supported </p>
<p>Specific information for segments or pages is so far not </p>
<p>supported. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>86 / 109 </p>
<p>Copy Page </p>
<p>If more than one calibration page is defined, the slave can copy </p>
<p>a calibration page into another. </p>
<p>In principle any page of any segment can be copied to any page </p>
<p>of any segment. However, restrictions might be possible. </p>
<p>Freeze Mode </p>
<p>If enabled the commands SET_SEGMENT_MODE and </p>
<p>GET_SEGMENT_MODE are enabled and forwarded to the </p>
<p>application. </p>
<p>Enabling this feature also set the Freeze Mode Supported bit in </p>
<p>General Paging Info </p>
<p>Table 7-5 Component configuration – Page Switching </p>
<p> </p>
<p> </p>
<p><b>7.1.2.6 </b></p>
<p><b>Programming </b></p>
<p> </p>
<p> </p>
<p>Figure 7-7 Component configuration – Programming </p>
<p> </p>
<p><b>Configuration option </b></p>
<p><b>Description of configuration option </b></p>
<p>Programming </p>
<p>The option 'Programming' enables the programming of non-</p>
<p>volatile memory. </p>
<p>If the internal flash of the microcontroller cannot be </p>
<p>programmed while execution of code from the flash, the </p>
<p>'bootloader download' functionality has to be used instead. </p>
<p>Programming Write Protection </p>
<p>The option 'Programming Write Protection' enables the </p>
<p>programming write protection of non-volatile memory.. I.e. prior </p>
<p>to carrying out write access to non-volatile memory an </p>
<p>application callback function (see 6.5.10) is called and the </p>
<p>memory address is passed as parameter. The application has </p>
<p>to either grant or deny the memory access. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>87 / 109 </p>
<p>Min_St_Pgm </p>
<p>This parameter defines the delay the Master should insert </p>
<p>between two consecutive PROGRAM_NEXT commands. This </p>
<p>parameter is only relevant if Block Mode is used. </p>
<p>Processor and Sector Info </p>
<p>The option 'Processor and Sector Info' enables the commands: </p>
<p><b>&gt; </b></p>
<p>GET_PGM_PROCESSOR_INFO </p>
<p>Transfers the general properties for programming and the </p>
<p>total number of available sectors from the slave device to </p>
<p>the master device. </p>
<p><b>&gt; </b></p>
<p>GET_SECTOR_INFO </p>
<p>Transfers information on a specific sector from the slave </p>
<p>device to the master device. </p>
<p>Sectors </p>
<p>The information for sectors, which is transferred from the slave </p>
<p>device to the master device, can be configured. </p>
<p>Attention: The sector number has to be dense and zero-based! </p>
<p>Sector </p>
<p>For each 'Sector' information can be configured. This </p>
<p>information is transferred from the slave device to the master </p>
<p>device. </p>
<p>Number </p>
<p>The sector numbers have to be dense and zero-based. </p>
<p>Therefore this number cannot be entered manually. </p>
<p>Name </p>
<p>Name of this sector. This information can be read and displayed </p>
<p>by the Master Tool if supported. </p>
<p>Start Address </p>
<p>The 'Start Address' of each sector is individually configured in </p>
<p>the slave device and transferred to the master device. </p>
<p>End Address </p>
<p>The 'End Address' of each sector is individually configured in </p>
<p>the slave device and transferred to the master device. </p>
<p>Table 7-6 Component configuration – Programming </p>
<p><b>7.1.2.7 </b></p>
<p><b>Fr Parameter </b></p>
<p>The XCP component provides a functionality to read the FlexRay Parameters as provided </p>
<p>by the FrIf/Fr Driver. They are accessible with a configurable address extension at virtual </p>
<p>addresses. </p>
<p> </p>
<p> </p>
<p>Figure 7-8 Component configuration – FlexRay Parameter </p>
<p> </p>
<p><b>Configuration option </b></p>
<p><b>Description of configuration option </b></p>
<p>Virtual FlexRay Parameters </p>
<p>If the “Virtual FlexRay Parameters” feature is enabled, the </p>
<p>parameters can be read out in a platform independent way. </p>
<p>They will be provided as virtual measurement values that can </p>
<p>be read at fixed memory locations. This Option is only available </p>
<p>if the ReadCCConfig API is enabled in the FrIf and Fr Driver.</p>
<p><b> </b></p>
<p>FlexRay Parameter Address </p>
<p>extension </p>
<p>The &quot;Virtual FlexRay Parameters&quot; are accessible with this </p>
<p>address extension.</p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>88 / 109 </p>
<p>An  a2l  File  named  FrParam.a2l  is  provided  and  can  be  used  to  read  these  Parameter </p>
<p>platform independently. The a2l file describes the parameters according to the AUTOSAR </p>
<p>3.2.1 spezification. </p>
<p> </p>
<p><b>7.1.2.8 </b></p>
<p><b>Generated a2l files </b></p>
<p>The Configuration Tool also generates multiple a2l files which can be used in the Master </p>
<p>tool for easier integration. The following files are generated: </p>
<p></p>
<p> </p>
<p>XCP.a2l (general protocol layer settings) </p>
<p></p>
<p> </p>
<p>XCP_daq.a2l (DAQ specific settings) </p>
<p></p>
<p> </p>
<p>XCP_events.a2l (DAQ event info) </p>
<p></p>
<p> </p>
<p>XCP_Checksum.a2l (Checksum information) </p>
<p> </p>
<p> </p>
<p><b>Example Master.a2l: </b></p>
<p><b> </b></p>
<p>... </p>
<p>/begin IF_DATA XCP </p>
<p>  /include XCP.a2l </p>
<p>  <b>/begin DAQ </b></p>
<p><b>    /include XCP_daq.a2l </b></p>
<p><b>    /include XCP_events.a2l </b></p>
<p><b>    /include XCP_checksum.a2l </b></p>
<p><b>    ... </b></p>
<p><b>  /end DAQ </b></p>
<p>  /include CanXCPAsr.a2l </p>
<p>/end IF_DATA </p>
<p>... </p>
<p>/include bsw.a2l </p>
<p>...</p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>7.2 </b></p>
<p><b>Configuration without Generation Tool </b></p>
<p>The </p>
<p>configuration </p>
<p>of </p>
<p>the </p>
<p>configuration </p>
<p>switches </p>
<p>and </p>
<p>constants </p>
<p>is </p>
<p>done </p>
<p>in </p>
<p>the </p>
<p>file </p>
<p>xcp_cfg.h</p>
<p>. An example that contains the default configuration of XCP Basic is distributed </p>
<p>together  with  XCP  Basic.  It  is  recommended  to  use  this  example  as  a  template  for  the </p>
<p>individual configuration. </p>
<p><b>7.2.1 </b></p>
<p><b>Compiler Switches </b></p>
<p>Compiler switches are used to enable/disable optional functionalities in order to save code </p>
<p>space and RAM. </p>
<p>In  the  following  table  you  will  find  a  complete  list  of  all  configuration  switches,  used  to </p>
<p>control  the  functional  units  that  are  common  to  XCP  Basic  and  XCP  Professional.  The </p>
<p>default values are bold. </p>
<p><b>Configuration switches </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>XCP_xxx_DAQ</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables synchronous </p>
<p>data acquisition. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>89 / 109 </p>
<p>XCP_xxx_DAQ_PRESCALER </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables the DAQ </p>
<p>prescaler. </p>
<p>XCP_xxx_DAQ_OVERRUN_INDICATION </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables the DAQ </p>
<p>overrun detection. </p>
<p>XCP_xxx_DAQ_HDR_ODT_DAQ</p>
<p>2</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>The 2 Byte DAQ/ODT XCP </p>
<p>Packet identification is used </p>
<p>instead of the PID. </p>
<p>Enabled: Relative ODT </p>
<p>number, absolute list number </p>
<p>(BYTE) </p>
<p>Disabled: Absolute ODT </p>
<p>number </p>
<p>XCP_xxx_DAQ_PROCESSOR_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Plug &amp; play mechanism for </p>
<p>the data acquisition processor. </p>
<p>XCP_xxx_DAQ_RESOLUTION_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Plug &amp; play mechanism for </p>
<p>the data acquisition resolution. </p>
<p>XCP_xxx_DAQ_EVENT_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Plug &amp; play mechanism for </p>
<p>the event definitions. </p>
<p>XCP_xxx_DAQ_TIMESTAMP </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>DAQ timestamps </p>
<p>XCP_xxx_DAQ_TIMESTAMP_FIXED </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Slave always sends DTO </p>
<p>Packets in time stamped </p>
<p>mode. Otherwise are </p>
<p>timestamps used individual by </p>
<p>each DAQ-list. </p>
<p>kXcpDaqTimestampSize</p>
<p> </p>
<p>DAQ_TIMESTAMP_BYTE, </p>
<p>DAQ_TIMESTAMP_WORD, </p>
<p>DAQ_TIMESTAMP_DWORD</p>
<p> </p>
<p>The size of timestamps which </p>
<p>can either be 1Byte, 2Bytes or </p>
<p>4Bytes. </p>
<p>XCP_xxx_SEED_KEY</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Seed &amp; key access protection </p>
<p>XCP_xxx_CHECKSUM</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Calculation of checksum </p>
<p> </p>
<p> </p>
<p> </p>
<p>XCP_xxx_CRC16CCITT_REFLECTED </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable/disable reflected </p>
<p>CRC16 CCITT checksum </p>
<p>calculation algorithm. </p>
<p>Also refer to 7.2.2.1 ‘Table of </p>
<p>Checksum Calculation </p>
<p>Methods’. </p>
<p>XCP_xxx_AUTOSAR_CRC_MODULE </p>
<p><b>ENABLE</b>, DISABLE </p>
<p>Usage of CRC algorithms of </p>
<p>AUTOSAR CRC module. </p>
<p>XCP_xxx_PARAMETER_CHECK </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Parameter check </p>
<p>XCP_xxx_SEND_QUEUE </p>
<p><b>ENABLE</b>, DISABLE </p>
<p>Transmission send queue  </p>
<p>(shall be used in conjunction </p>
<p>with synchronous data </p>
<p>acquisition and stimulation). </p>
<p>XCP_xxx_SEND_EVENT </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Transmission of event packets </p>
<p>(EV) </p>
<p>                                            </p>
<p>2</p>
<p> The XCP Protocol allows three identification field types for DTOs: ‘absolute ODT number’, ‘relative ODT </p>
<p>number and absolute DAQ list number’, ‘empty identification field’ (not supported) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>90 / 109 </p>
<p>XCP_xxx_USER_COMMAND </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>User defined command </p>
<p>XCP_xxx_TL_COMMAND </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Transport Layer command </p>
<p>XCP_xxx_COMM_MODE_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Communication mode info </p>
<p>XCP_xxx_CALIBRATION_PAGE </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Calibration data page </p>
<p>switching </p>
<p>XCP_xxx_PAGE_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Calibration data page plug &amp; </p>
<p>play mechanism </p>
<p>XCP_xxx_PAGE_COPY </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Calibration data page copying </p>
<p>XCP_xxx_PAGE_FREEZE </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Segment freeze mode </p>
<p>handling  </p>
<p>XCP_xxx_DPRAM</p>
<p>3</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Supports the usage of dual </p>
<p>port RAM </p>
<p> </p>
<p>The following table contains an additional list of all configuration switches, used to control </p>
<p>the  functional  units  that  are  only  available  in  XCP  Professional.  The  default  values  are </p>
<p>bold. </p>
<p><b>Configuration switches </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>XCP_xxx_BLOCK_UPLOAD </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enables/disables the slave </p>
<p>block transfer. </p>
<p>XCP_xxx_BLOCK_DOWNLOAD</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables the master </p>
<p>block transfer. </p>
<p>XCP_xxx_WRITE_PROTECTION </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Write access to RAM </p>
<p>XCP_xxx_READ_PROTECTION </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Read access to RAM </p>
<p>XCP_xxx_READ_EEPROM </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Read access to EEPROM </p>
<p>XCP_xxx_WRITE_EEPROM </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Write access to EEPROM </p>
<p>XCP_xxx_PROGRAMMING_WRITE_PRO</p>
<p>TECTION </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Write access to flash </p>
<p>XCP_xxx_PROGRAM </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Flash programming </p>
<p>XCP_xxx_PROGRAM_INFO </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Flash programming plug &amp; play </p>
<p>mechanism </p>
<p>XCP_xxx_BOOTLOADER_DOWNLOAD </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Flash programming with a </p>
<p>flash kernel </p>
<p>XCP_xxx_STIM</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables data </p>
<p>stimulation. </p>
<p>(also </p>
<p>XCP_ENABLE_DAQ</p>
<p> has to </p>
<p>be defined in order to use data </p>
<p>stimulation) </p>
<p>XCP_xxx_DAQ_RESUME </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Data acquisition resume mode. </p>
<p>XCP_xxx_SERV_TEXT </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Transmission of service </p>
<p>request codes </p>
<p>XCP_xxx_SERV_TEXT_PUTCHAR </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Putchar function for the </p>
<p>transmission of service request </p>
<p>messages </p>
<p>                                            </p>
<p>3</p>
<p> Not supported by XCP Professional </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>91 / 109 </p>
<p>XCP_xxx_SERV_TEXT_PRINTF </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Print function for the </p>
<p>transmission of service request </p>
<p>messages </p>
<p>XCP_</p>
<p>xxx</p>
<p>_MEM_ACCESS_BY_APPL</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Memory access by application </p>
<p>XCP_xxx_MODEL_PAGED</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for paging / banking </p>
<p>XCP_xxx_SHORT_DOWNLOAD </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for </p>
<p>SHORT_DOWNLOAD </p>
<p>command </p>
<p>XCP_xxx_MODIFY_BITS </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for MODIFY_BITS </p>
<p>command </p>
<p>XCP_xxx_WRITE_DAQ_MULTIPLE</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Write DAQ multiple command </p>
<p>XCP_xxx_GET_XCP_DATA_POINTER </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable API for internal data </p>
<p>access </p>
<p>XCP_xxx_CONTROL </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable API for en- / disable </p>
<p>XCP module </p>
<p>XCP_xxx_DEV_ERROR_DETECT </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable Development Error </p>
<p>check </p>
<p>XCP_xx_READCCCONFIG </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable Read of FlexRay </p>
<p>Parameters </p>
<p>XCP_ADDR_EXT_READCCCONFIG </p>
<p>0x00…0xff </p>
<p>Address  Extension to be used </p>
<p>for FlexRay Parameters </p>
<p>XCP_xxx_VECTOR_GENERICMEASUREMEN</p>
<p>T </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for Generic </p>
<p>Measurement feature </p>
<p>XCP_xxx_GET_SESSION_STATUS_API </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable API to acquire the </p>
<p>current session status </p>
<p>XCP_xxx_CUSTOM_CRC </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable call-back for custom </p>
<p>CRC calculation </p>
<p>XCP_xxx_GET_ID_GENERIC </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>ECU identification </p>
<p> </p>
<p>The following table contains an additional list of all configuration switches, used to control </p>
<p>the functional units that are only available in XCP basic. The default values are bold. </p>
<p><b>Configuration switches </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>XCP_ENABLE_TESTMODE</p>
<p>4</p>
<p> </p>
<p>ENABLE, </p>
<p><b>DISABLE </b></p>
<p>Test mode that allows the output of debugging </p>
<p>information. </p>
<p>Not included in XCP Professional due to multiple MISRA </p>
<p>rule violations! </p>
<p> </p>
<p>                                            </p>
<p>4</p>
<p> Not supported by XCP Professional </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>92 / 109 </p>
<p><b>7.2.2 </b></p>
<p><b>Configuration of Constant Definitions </b></p>
<p>The configuration of constant definitions is done as described below.  </p>
<p>The default values are bold. </p>
<p><b>Constant definitions </b></p>
<p><b>Range </b></p>
<p><b>Default </b></p>
<p><b>Description </b></p>
<p>kXcpMaxCTOMax</p>
<p> </p>
<p>8..255 </p>
<p><b>8 </b></p>
<p>Maximum length of XCP command transfer </p>
<p>objects (CTO). </p>
<p>The length of the CTO can be variable. </p>
<p>However it has to be configured according to the </p>
<p>used XCP Transport Layer. </p>
<p>kXcpMaxDTOMax</p>
<p> </p>
<p>8..255</p>
<p>5</p>
<p> </p>
<p><b>8 </b></p>
<p>Maximum length of XCP data transfer objects </p>
<p>(DTO). </p>
<p>The length of the DTO can be variable. </p>
<p>However it has to be configured according to the </p>
<p>used XCP Transport Layer. </p>
<p>kXcpDaqMemSize </p>
<p>0.. </p>
<p>0xFFFF </p>
<p><b>256 </b></p>
<p>Define the amount of memory used for the DAQ </p>
<p>lists and buffers. </p>
<p>Also refer to chapter 8 (Resource </p>
<p>Requirements). </p>
<p>kXcpSendQueueMinSize </p>
<p>1..0x7F </p>
<p><b>- </b></p>
<p>The minimum queue size required for DAQ. The </p>
<p>queue size is the unallocated memory reserved </p>
<p>by </p>
<p>kXcpDaqMemSize</p>
<p>. </p>
<p>kXcpMaxEvent </p>
<p>0..0xFF</p>
<p>6</p>
<p> </p>
<p><b>- </b></p>
<p>Number of available events in the slave (part of </p>
<p>event channel plug &amp; play mechanism) </p>
<p>Also refer to chapter 7.2.5. </p>
<p>kXcpStimOdtCount </p>
<p>0..0xC0 </p>
<p><b>0xC0 </b></p>
<p>Maximum number of ODTs that may be used for </p>
<p>Synchronous Data Stimulation. </p>
<p>kXcpChecksumMethod </p>
<p>- </p>
<p><b>- </b></p>
<p>Checksum calculation method. </p>
<p>Refer to chapter 7.2.2.1 ‘Table of Checksum </p>
<p>Calculation Methods’ for valid values. </p>
<p>kXcpChecksumBlockSize </p>
<p>1 .. </p>
<p>0xFFFF </p>
<p><b>256 </b></p>
<p>Each call of </p>
<p>XcpBackground</p>
<p> calculates the </p>
<p>checksum on the amount of bytes specified by </p>
<p>kXcpChecksumBlockSize</p>
<p>. </p>
<p>XCP_TRANSPORT_LAYER_V</p>
<p>ERSION </p>
<p>0.. </p>
<p>0xFFFF </p>
<p><b>- </b></p>
<p>Version of the XCP Transport Layer that is used. </p>
<p>(this version gets transferred to the MCS) </p>
<p>kXcpMaxSector </p>
<p>1..0xFF </p>
<p><b>- </b></p>
<p>Number of flash sectors </p>
<p>Also refer to chapter 7.2.7 </p>
<p>kXcpMaxSegment</p>
<p> </p>
<p>1 </p>
<p><b>1 </b></p>
<p>Number of memory segments </p>
<p>Also refer to chapter 7.2.8. </p>
<p>kXcpMaxPages</p>
<p> </p>
<p>1..2 </p>
<p><b>2 </b></p>
<p>Number of pages </p>
<p>Also refer to chapter 7.2.8. </p>
<p>NUMBER_OF_TRANSPORTLA</p>
<p>YERS </p>
<p>1.. </p>
<p><b>1 </b></p>
<p>Number of used Transport Layers </p>
<p>XCP_TRANSPORT_LAYER_C</p>
<p>AN </p>
<p>0.. </p>
<p><b>0 </b></p>
<p>Index of Transport Layer </p>
<p>                                            </p>
<p>5</p>
<p> Implementation specific range. The range is 8..0xFFFF according to XCP specification [I], [II]. </p>
<p>6</p>
<p> Implementation specific range. The range is 0..0xFFFE according to XCP specification [I], [II]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>93 / 109 </p>
<p>XCP_TRANSPORT_LAYER_F</p>
<p>R </p>
<p>0.. </p>
<p><b>1 </b></p>
<p>Index of Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_E</p>
<p>TH </p>
<p>0.. </p>
<p><b>2 </b></p>
<p>Index of Transport Layer </p>
<p> </p>
<p><b>7.2.2.1 </b></p>
<p><b>Table of Checksum Calculation Methods </b></p>
<p><b>Constant </b></p>
<p><b>Checksum calculation method </b></p>
<p>XCP_CHECKSUM_TYPE_ADD11 </p>
<p>Add BYTE into a BYTE checksum, ignore overflows. </p>
<p>XCP_CHECKSUM_TYPE_ADD12 </p>
<p>Add BYTE into a WORD checksum, ignore overflows </p>
<p>XCP_CHECKSUM_TYPE_ADD14 </p>
<p>Add BYTE into a DWORD checksum, ignore overflows </p>
<p>XCP_CHECKSUM_TYPE_ADD22 </p>
<p>Add WORD into a WORD checksum, ignore overflows, block </p>
<p>size must be modulo 2 </p>
<p>XCP_CHECKSUM_TYPE_ADD24 </p>
<p>Add WORD into a DWORD checksum, ignore overflows, </p>
<p>block size must be modulo 2 </p>
<p>XCP_CHECKSUM_TYPE_ADD44 </p>
<p>Add DWORD into DWORD, ignore overflows, block size </p>
<p>must be modulo 4 </p>
<p>XCP_CHECKSUM_TYPE_CRC16CCITT </p>
<p>CRC16 CCITT checksum calculation algorithm </p>
<p>Both the standard and the reflected algorithm are supported. </p>
<p>Please refer to chapter 10.7 ‘Reflected CRC16 CCITT </p>
<p>Checksum Calculation Algorithm’. </p>
<p>The CRC16 CCITT algorithm of the AUTOSAR CRC module </p>
<p>is only supported by XCP Professional. </p>
<p>XCP_CHECKSUM_TYPE_CRC32 </p>
<p>CRC32 checksum calculation algorithm </p>
<p>The CRC32 algorithm is only supported in XCP Professional </p>
<p>if the AUTOSAR CRC module is used. </p>
<p> </p>
<p><b>7.2.3 </b></p>
<p><b>Configuration of the CPU Type  </b></p>
<p>To provide platform independent code platform, the CPU type has to be defined. </p>
<p><b>Configuration switches </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>C_CPUTYPE_xxxENDIAN </p>
<p>LITTLE, </p>
<p><b>BIG</b></p>
<p> </p>
<p>Definition whether the CPU is little endian (Intel </p>
<p>format) or big endian (Motorola format). </p>
<p>XCP_xxx_UNALIGNED_MEM_ACCESS </p>
<p>ENABLE, </p>
<p>DISABLE</p>
<p> </p>
<p>Enables / disables unaligned memory access. </p>
<p>If </p>
<p>XCP_DISBLE_UNALIGNED_MEM_ACCESS </p>
<p>is </p>
<p>defined WORDs are located on WORD aligned and </p>
<p>DWORD are located on DWORD aligned addresses. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>94 / 109 </p>
<p><b>7.2.4 </b></p>
<p><b>Configuration of Slave Device Identification </b></p>
<p>The configuration of the slave device identification and automatic session configuration is </p>
<p>described within this chapter. Only one of the following options can be used at one time. </p>
<p><b>7.2.4.1 </b></p>
<p><b>Identification by ASAM-MC2 Filename without Path and Extension </b></p>
<p>If  the  slave  device  identification  is  done  by  identification  with  an  ASAM-MC2  filename </p>
<p>without path and extension the filename length has to be defined: </p>
<p>#define kXcpStationIdLength <i>length </i></p>
<p>and the station ID itself has to be defined as string: </p>
<p>const uint8 kXcpStationId[] = “<i>station ID</i>” </p>
<p>The range of </p>
<p>kXcpStationIdLength</p>
<p> is </p>
<p>0..0xFF</p>
<p>. </p>
<p><b>7.2.4.2 </b></p>
<p><b>Automatic Session Configuration with MAP Filenames </b></p>
<p>The  automatic  session  configuration  by  transferring  MAP  filenames  is  a  Vector  specific </p>
<p>extension that works with CANape and can be enabled by the “XcpGetIdGeneric” attribute</p>
<p> </p>
<p>When  this feature  is enabled  the API  as  described  in  3.4.2  is  enabled. This API  will  be </p>
<p>called, should CANape request the MAP filename, and must be implemented by the user </p>
<p>accordingly. This feature must explicitly be enabled in CANape as well! </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p> </p>
<p> </p>
<p>#define MAP_FORMAT 29  </p>
<p>#define MAP_NAME   &quot;xcpsim&quot;  </p>
<p>  </p>
<p>uint8 MapTest[500];  </p>
<p>uint32 MapTestSize;  </p>
<p>  </p>
<p>uint32 XcpAppl_GetIdData( MTABYTEPTR *pData, uint8 id )  </p>
<p>{  </p>
<p>  if( id == IDT_VECTOR_MAPNAMES ) </p>
<p>  { </p>
<p>    MapTestSize = </p>
<p>sprintf((char*)MapTest,&quot;%c%c%s.map&quot;,MAP_FORMAT,0,MAP_NAME);  </p>
<p>    /* Result: MapTest = ”290xcpsim.map” */ </p>
<p>    *pData = MapTest;  </p>
<p>    return MapTestSize;  </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    return 0; /* Id not available */ </p>
<p>  } </p>
<p>}  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>‘MAP_FORMAT’ represents the format of the MAP file. (See table below) </p>
<p>‘0’ is a counter that is used as address extension. Please set this parameter to 0. </p>
<p>Table of MAP file formats: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>95 / 109 </p>
<p>  1 = &quot;BorlandC 16 Bit&quot;             29 = &quot;Microsoft standard&quot;  </p>
<p>  2 = &quot;M166&quot;                        30 = &quot;ELF/DWARF 16 Bit&quot;  </p>
<p>  3 = &quot;Watcom&quot;                      31 = &quot;ELF/DWARF 32 Bit&quot;  </p>
<p>  4 = &quot;HiTech HC05&quot;                 32 = &quot;Fujitsu Softune 3..8(.mps)&quot;  </p>
<p>  6 = &quot;IEEE&quot;                        33 = &quot;Microware Hawk&quot;  </p>
<p>  7 = &quot;Cosmic&quot;                      34 = &quot;TI C6711&quot;  </p>
<p>  8 = &quot;SDS&quot;                         35 = &quot;Hitachi H8S&quot;  </p>
<p>  9 = &quot;Fujitsu Softune 1(.mp1)&quot;     36 = &quot;IAR HC12&quot;  </p>
<p>  10 = &quot;GNU&quot;                        37 = &quot;Greenhill Multi 2000&quot;  </p>
<p>  11 = &quot;Keil 16x&quot;                   38 = &quot;LN308(MITSUBISHI) for M16C/80&quot;  </p>
<p>  12 = &quot;BorlandC 32 Bit&quot;            39 = &quot;COFF settings auto detected&quot;  </p>
<p>  13 = &quot;Keil 16x (static)&quot;          40 = &quot;NEC CC78K/0 v35&quot;  </p>
<p>  14 = &quot;Keil 8051&quot;                  41 = &quot;Microsoft extended&quot;  </p>
<p>  15 = &quot;ISI&quot;                        42 = &quot;ICCAVR&quot;  </p>
<p>  16 = &quot;Hiware HC12&quot;                43 = &quot;Omf96 (.m96)&quot;  </p>
<p>  17 = &quot;TI TMS470&quot;                  44 = &quot;COFF/DWARF&quot;  </p>
<p>  18 = &quot;Archimedes&quot;                 45 = &quot;OMF96 Binary (Tasking C196)&quot;  </p>
<p>  19 = &quot;COFF&quot;                       46 = &quot;OMF166 Binary (Keil C166)&quot;  </p>
<p>  20 = &quot;IAR&quot;                        47 = &quot;Microware Hawk Plug&amp;Play ASCII&quot;  </p>
<p>  21 = &quot;VisualDSP&quot;                  48 = &quot;UBROF Binary (IAR)&quot;  </p>
<p>  22 = &quot;GNU 16x&quot;                    49 = &quot;Renesas M32R/M32192 ASCII&quot;  </p>
<p>  23 = &quot;GNU VxWorks&quot;                50 = &quot;OMF251 Binary (Keil C251)&quot;  </p>
<p>  24 = &quot;GNU 68k&quot;                    51 = &quot;Microsoft standard VC8&quot;  </p>
<p>  25 = &quot;DiabData&quot;                   52 = &quot;Microsoft VC8 Release Build (MATLAB DLL)&quot;  </p>
<p>  26 = &quot;VisualDSP DOS&quot;              53 = &quot;Microsoft VC8 Debug Build (MATLAB DLL)&quot;  </p>
<p>  27 = &quot;HEW SH7055&quot;                 54 = &quot;Microsoft VC8 Debug file (pdb)&quot;  </p>
<p>  28 = &quot;Metrowerks&quot; </p>
<p> </p>
<p><b>7.2.5 </b></p>
<p><b>Configuration of the Event Channel Plug &amp; Play Mechanism </b></p>
<p>The event channel plug &amp; play mechanism is enabled with the switch </p>
<p>XCP_ENABLE_DAQ_EVENT_INFO</p>
<p> </p>
<p>A prerequisite for the event channel plug &amp; play mechanism is the general data acquisition </p>
<p>plug  &amp;  play  mechanism.  If  the  mechanism  is  enabled  the  following  configurations  items </p>
<p>have to be defined as described below: </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpMaxEvent </p>
<p>0..0xFF</p>
<p>7</p>
<p> </p>
<p>Number of available events in the slave </p>
<p>(part of event channel plug &amp; play mechanism) </p>
<p>If the event numbers do not start at 0 or are not </p>
<p>continuous this is the maximum used event channel </p>
<p>number plus 1. </p>
<p>kXcpEventName[] </p>
<p>kXcpMaxEvent </p>
<p>List with pointers to the event channel names that are </p>
<p>defined as strings. </p>
<p>                                            </p>
<p>7</p>
<p> Implementation specific range. The range is 0..0xFFFE according to XCP specification [I], [II]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>96 / 109 </p>
<p>kXcpEventNameLength[]  kXcpMaxEvent </p>
<p>Length of the event channel names without the </p>
<p>terminating char. </p>
<p>kXcpEventCycle[] </p>
<p>kXcpMaxEvent</p>
<p> </p>
<p>Cycle time of the event channels in milliseconds. </p>
<p>kXcpEventDirection[] </p>
<p>kXcpMaxEvent</p>
<p> </p>
<p>Direction of the event channels. </p>
<p>For XCP Basic valid values are: </p>
<p>-</p>
<p> </p>
<p>kXcpEventDirectionDaq </p>
<p>For XCP Professional valid values are: </p>
<p>-</p>
<p> </p>
<p>kXcpEventDirectionDaq </p>
<p>-</p>
<p> </p>
<p>kXcpEventDirectionStim</p>
<p> </p>
<p> </p>
<p>- </p>
<p>kXcpEventDirectionDaqStim</p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p> </p>
<p>#define XCP_ENABLE_DAQ_EVENT_INFO </p>
<p>#define kXcpMaxEvent 3 </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventName_0[] = &quot;10ms&quot;; </p>
<p>CONST(uint8, XCP_CONST) kXcpEventName_1[] = &quot;100ms DAQ&quot;; </p>
<p>CONST(uint8, XCP_CONST) kXcpEventName_2[] = &quot;100ms STIM&quot;; </p>
<p>CONSTP2CONST(uint8, XCP_CONST, XCP_CONST) kXcpEventName[] =  </p>
<p>{ </p>
<p>  &amp;kXcpEventName_0[0], </p>
<p>  &amp;kXcpEventName_1[0], </p>
<p>  &amp;kXcpEventName_2[0] </p>
<p>}; </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventNameLength[] = </p>
<p>{ </p>
<p>  4, </p>
<p>  9, </p>
<p>  10 </p>
<p>}; </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventCycle[] =  </p>
<p>{ </p>
<p>  10, </p>
<p>  100, </p>
<p>  100 </p>
<p>}; </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventDirection[] =  </p>
<p>{ </p>
<p>  kXcpEventDirectionDaq,  </p>
<p>  kXcpEventDirectionDaq,  </p>
<p>  kXcpEventDirectionStim </p>
<p>}; </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>97 / 109 </p>
<p><b>7.2.6 </b></p>
<p><b>Configuration of the DAQ Time Stamped Mode </b></p>
<p>Transmission  of  DAQ  timestamps  is  enabled  with </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p>.  If </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP_FIXED</p>
<p> is defined all DTO Packets will be transmitted in </p>
<p>time stamped mode.  </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpDaqTimestampSize </p>
<p>DAQ_TIMESTAMP_BYTE, </p>
<p>DAQ_TIMESTAMP_WORD, </p>
<p>DAQ_TIMESTAMP_DWORD </p>
<p>This parameter defines the </p>
<p>size of timestamps. It can </p>
<p>either be 1 byte, 2 bytes or 4 </p>
<p>bytes. </p>
<p>XcpDaqTimestampType </p>
<p>uint8, uint16 or uint32 </p>
<p>Type of the timestamp </p>
<p>depends on the parameter </p>
<p> </p>
<p>kXcpDaqTimestampSize.</p>
<p> </p>
<p>kXcpDaqTimestampUnit </p>
<p>DAQ_TIMESTAMP_UNIT_1NS </p>
<p>DAQ_TIMESTAMP_UNIT_10NS </p>
<p>DAQ_TIMESTAMP_UNIT_100NS </p>
<p>DAQ_TIMESTAMP_UNIT_1US </p>
<p>DAQ_TIMESTAMP_UNIT_10US </p>
<p>DAQ_TIMESTAMP_UNIT_100US </p>
<p>DAQ_TIMESTAMP_UNIT_1MS </p>
<p>DAQ_TIMESTAMP_UNIT_10MS </p>
<p>DAQ_TIMESTAMP_UNIT_100MS </p>
<p>DAQ_TIMESTAMP_UNIT_1S </p>
<p>DAQ_TIMESTAMP_UNIT_1pS </p>
<p>DAQ_TIMESTAMP_UNIT_10pS </p>
<p>DAQ_TIMESTAMP_UNIT_100pS </p>
<p>Unit of the timestamp </p>
<p>(1 ns, 10 ns .. 1 s) </p>
<p> </p>
<p> </p>
<p> </p>
<p>kXcpDaqTimestampTicksPerUnit  0..0xFFFF </p>
<p>Time stamp ticks per unit </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>7.2.7 </b></p>
<p><b>Configuration of the Flash Programming Plug &amp; Play Mechanism </b></p>
<p>The flash programming plug &amp; play mechanism is enabled with the switch </p>
<p>XCP_ENABLE_PROGRAM_INFO</p>
<p> </p>
<p>If the plug &amp; play mechanism is enabled the number of sectors and the start address and </p>
<p>end address of each sector has to be defined. The constants that have to be defined can </p>
<p>be found in the following table. </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpMaxSector </p>
<p>0..0xFF </p>
<p>Number of available flash sectors in the slave </p>
<p>kXcpSectorName[] </p>
<p>kXcpMaxSector </p>
<p>List with pointers to the Sector names that are </p>
<p>defined as strings. </p>
<p>kXcpSectorNameLength </p>
<p>kXcpMaxSector </p>
<p>Length of the Sector names without the terminating </p>
<p>char. </p>
<p>kXcpProgramSectorStart[] kXcpMaxSector </p>
<p>List with the start addresses of the sectors </p>
<p>kXcpProgramSectorEnd[] </p>
<p>kXcpMaxSector </p>
<p>List with the end address of the sectors </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>98 / 109 </p>
<p> </p>
<p><b>Example </b></p>
<p><b> </b></p>
<p>#define XCP_ENABLE_PROGRAM_INFO </p>
<p>#define kXcpMaxSector 2 </p>
<p> </p>
<p>CONST(XcpCharType, XCP_CONST) kXcpSectorName_0[] = &quot;Sector0&quot;; </p>
<p>CONST(XcpCharType, XCP_CONST) kXcpSectorName_1[] = &quot;Sector1&quot;; </p>
<p> </p>
<p>CONSTP2CONST(XcpCharType, XCP_CONST, XCP_CONST) kXcpSectorName[] =  </p>
<p>{ </p>
<p>  &amp;kXcpSectorName_0[0], </p>
<p>  &amp;kXcpSectorName_1[0] </p>
<p>}; </p>
<p>CONST(uint8, XCP_CONST) kXcpSectorNameLength[] =  </p>
<p>{ </p>
<p>  7U, </p>
<p>  7U </p>
<p>}; </p>
<p> </p>
<p>CONST(uint32, XCP_CONST) kXcpProgramSectorStart [] =  </p>
<p>{ </p>
<p>  (uint32)0x000000u,  </p>
<p>  (uint32)0x010000u,  </p>
<p>}; </p>
<p>CONST(uint32, XCP_CONST) kXcpProgramSectorEnd [] =  </p>
<p>{ </p>
<p>  (uint32)0x00FFFFu,  </p>
<p>  (uint32)0x01FFFFu,  </p>
<p>}; </p>
<p> </p>
<p> </p>
<p><b>7.2.8 </b></p>
<p><b>Configuration of the Page Switching Plug &amp; Play Mechanism </b></p>
<p>The page switching plug &amp; play mechanism is enabled with the switch </p>
<p>XCP_ENABLE_PAGE_INFO</p>
<p> </p>
<p>If  the  plug  &amp;  play  mechanism  is  enabled  the  following  configurations  items  have  to  be </p>
<p>defined as described below: </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpMaxSegment </p>
<p>0x01 </p>
<p>Number of memory segments </p>
<p>kXcpMaxPages </p>
<p> </p>
<p>0x01..0x02 </p>
<p>Number of pages </p>
<p> </p>
<p><b>7.2.9 </b></p>
<p><b>Configuration of the used Transport Layer </b></p>
<p>The XCP Protocol Layer uses a jump table to call respective Transport Layer Functions. </p>
<p>This jump table has to contain certain Function names </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>Xcp_TlApi </p>
<p>Number of TL </p>
<p>Function Pointer table containing pointers to the </p>
<p>respective Transport Layer </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>99 / 109 </p>
<p> </p>
<p><b>Example </b></p>
<p><b> </b></p>
<p>#define NUMBER_OF_TRANSPORTLAYERS            1 </p>
<p>#define XCP_TRANSPORT_LAYER_CAN              0u </p>
<p> </p>
<p>CONST(Xcp_TlApiType, XCP_CONST) </p>
<p>Xcp_TlApi[NUMBER_OF_TRANSPORTLAYERS] = </p>
<p>{ </p>
<p>  { </p>
<p>    CanXcp_Send, /* ApplXcpSend */ </p>
<p>    CanXcp_SendFlush /* ApplXcpSendFlush */ </p>
<p>    #if defined ( XCP_ENABLE_TL_COMMAND ) </p>
<p>    , </p>
<p>    CanXcp_TLService /* ApplXcpTLService */ </p>
<p>    #endif </p>
<p>  } </p>
<p>}; </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>100 / 109 </p>
<p><b>8 </b></p>
<p><b>Resource Requirements </b></p>
<p>The  resource  requirements  of  the  XCP  Protocol  Layer  mainly  depend  on  the  micro </p>
<p>controller,  compiler  options  and  configuration.  Within  this  chapter  only  the  configuration </p>
<p>specific resource requirements are taken in consideration. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>101 / 109 </p>
<p><b>9 </b></p>
<p><b>Limitations </b></p>
<p><b>9.1 </b></p>
<p><b>General Limitations </b></p>
<p>The functional limitations of the XCP Professional Version are listed below: </p>
<p><b>&gt; </b></p>
<p>Bit stimulation is not supported </p>
<p><b>&gt; </b></p>
<p>Only dynamic DAQ list allocation supported </p>
<p><b>&gt; </b></p>
<p>The interleaved communication model is not supported </p>
<p><b>&gt; </b></p>
<p>Only default programming data format is supported </p>
<p><b>&gt; </b></p>
<p>GET_SECTOR_INFO does not return sequence numbers </p>
<p><b>&gt; </b></p>
<p>Program Verify and Program Format are not supported </p>
<p><b>&gt; </b></p>
<p>DAQ numbers are limited to byte size </p>
<p><b>&gt; </b></p>
<p>DAQ does not support address extension </p>
<p><b>&gt; </b></p>
<p>DAQ-list and event channel prioritization is not supported </p>
<p><b>&gt; </b></p>
<p>Event channels contain one DAQ-list </p>
<p><b>&gt; </b></p>
<p>ODT optimization not supported </p>
<p><b>&gt; </b></p>
<p>Assignments of CAN identifiers to DAQ lists is not supported </p>
<p><b>&gt; </b></p>
<p>MAX_DTO is limited to 0xFF </p>
<p><b>&gt; </b></p>
<p>The resume bits in DAQ lists are not set </p>
<p><b>&gt; </b></p>
<p>STORE_DAQ, CLEAR_DAQ and STORE_CAL do not send an event message </p>
<p><b>&gt; </b></p>
<p>Entering resume mode does not send an event message </p>
<p><b>&gt; </b></p>
<p>Overload indication by an event is not supported </p>
<p><b>&gt; </b></p>
<p>SERV_RESET is not supported </p>
<p><b>&gt; </b></p>
<p>The following checksum types are not supported </p>
<p><b>&gt; </b></p>
<p>XCP_CRC_16 </p>
<p><b>&gt; </b></p>
<p>XCP_CRC_32 </p>
<p><b>&gt; </b></p>
<p>XCP_USER_DEFINED </p>
<p><b>&gt; </b></p>
<p>Maximum checksum block size is 0xFFFF </p>
<p><b>&gt; </b></p>
<p>Page Info and Segment Info is not supported </p>
<p><b>&gt; </b></p>
<p>Only one segment and two pages are supported </p>
<p><b>&gt; </b></p>
<p>The seed size and key size must be equal or less MAX_CTO-2 </p>
<p><b>&gt; </b></p>
<p>Consistency only supported on ODT level </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>102 / 109 </p>
<p>Planned: </p>
<p><b>&gt; </b></p>
<p>User defined checksum calculations </p>
<p><b>&gt; </b></p>
<p>CRC16 and CRC32 </p>
<p><b>9.2 </b></p>
<p><b>Limitations of XCP Basic </b></p>
<p>The XCP Protocol Layer is available in two variants: </p>
<p><b>&gt; </b></p>
<p>XCP Professional Version </p>
<p><b>&gt; </b></p>
<p>XCP Basic Version </p>
<p>The XCP Professional Version is the ‘full version’, which is also supported by the Vector </p>
<p>generation  tool  GENy. The  XCP  Basic  Version  is  a  subset  of  the  ‘full  version’,  which  is </p>
<p>distributed freely via the internet and which has to be configured manually. </p>
<p>The XCP features that are available by the XCP Professional version but not by the XCP </p>
<p>Basic version are listed below: </p>
<p><b>&gt; </b></p>
<p>Stimulation (Bypassing) </p>
<p><b>&gt; </b></p>
<p>Bit stimulation</p>
<p>8</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Atomic bit manipulation </p>
<p><b>&gt; </b></p>
<p>SHORT_DOWNLOAD </p>
<p><b>&gt; </b></p>
<p>FLASH and EEPROM Programming </p>
<p><b>&gt; </b></p>
<p>The block transfer communication mode </p>
<p><b>&gt; </b></p>
<p>Resume mode </p>
<p><b>&gt; </b></p>
<p>The transmission of service request packets </p>
<p><b>&gt; </b></p>
<p>Memory write protection </p>
<p><b>&gt; </b></p>
<p>Memory read protection </p>
<p><b>&gt; </b> Programming write protection </p>
<p><b>&gt; </b></p>
<p>Support of AUTOSAR CRC module </p>
<p><b>&gt; </b></p>
<p>Access to internal data pointer </p>
<p><b>&gt; </b></p>
<p>XCP deactivation </p>
<p><b>&gt; </b></p>
<p>Open Command Interface </p>
<p><b>&gt; </b></p>
<p>Transport Layer Commands </p>
<p><b>&gt; </b></p>
<p>Configurable timestamp size </p>
<p><b>&gt; </b></p>
<p>Disable Calibration </p>
<p> </p>
<p>                                            </p>
<p>8</p>
<p> Not yet supported by XCP Professional </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>103 / 109 </p>
<p><b>9.3 </b></p>
<p><b>Limitations Regarding Platforms, Compilers and Memory Models </b></p>
<p>Even though XCP Professional and XCP Basic are Protocol Layers and therefore higher </p>
<p>software layers, they manipulate memory addresses and directly access the memory with </p>
<p>these addresses. </p>
<p>This  might  cause  issues  for  some  combinations  of  platforms,  compilers  and  memory </p>
<p>models.  The  following  list  provides  all  known  restrictions  on  platforms,  compilers  and </p>
<p>linkers: </p>
<p><b>&gt; </b></p>
<p>CANoeOSEK Emulation is not supported </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>104 / 109 </p>
<p><b>10  FAQ </b></p>
<p><b>10.1 </b></p>
<p><b>Connection to MCS Not Possible </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>After integration of XCP on CAN or integration of XCP Basic with a proprietary </p>
<p>CAN-Driver does the MCS (e.g. CANape) not connect with the XCP slave, even </p>
<p>though the CAN communication is working properly. </p>
<p> </p>
<p>The XCP protocol allows transmitting XCP packets with a variable data length. However </p>
<p>many OEMs require that all CAN messages sent within their automotive networks have to </p>
<p>have a static DLC. Therefore messages sent by the MCS with a DLC of less than 8 (e.g. </p>
<p>CONNECT  has  a  DLC  of  2)  might  be  discarded  by  the  ECU’s  CAN-Driver  and  the </p>
<p>connection is not possible. </p>
<p>Check  whether  your  MCS  supports  transmission  with  static  DLC.  This  is  supported  by </p>
<p>CANape since Version 5.5. </p>
<p> </p>
<p><b>10.2 </b></p>
<p><b>Invalid Time Stamp Unit </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>If using data acquisition CANape reports an error due to an invalid timestamp </p>
<p>unit. </p>
<p> </p>
<p>If you are using CANape 5.5.x or an earlier version please define </p>
<p>#define XCP_ENABLE_CANAPE_5_5_X_SUPPORT </p>
<p>in your user config file. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>105 / 109 </p>
<p><b>10.3 </b></p>
<p><b>Support of small and medium memory model </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How is the XCP Protocol Layer configured in order to access the whole memory </p>
<p>in the small and medium memory model? </p>
<p> </p>
<p>By  default The  XCP  Protocol  Layer  accesses  the  memory  with  a  default  pointer.  I.e.  in </p>
<p>small and medium memory model a near pointer is used. If the far memory (e.g. code or </p>
<p>read-only  sections)  needs  to  be  accessed  via  the  XCP  Protocol  the  memory  qualifiers </p>
<p>have to be defined as far pointers by the user within the user config file.   </p>
<p>Two memory qualifiers are used to access the memory: </p>
<p>MTABYTEPTR </p>
<p>#define MTABYTEPTR P2VAR(uint8, AUTOMATIC, XCP_MTA_DATA) </p>
<p>This pointer is used to access memory for standard read and </p>
<p>write operations </p>
<p>DAQBYTEPTR </p>
<p>#define DAQBYTEPTR P2VAR(uint8, AUTOMATIC, XCP_DAQ_DATA) </p>
<p>This pointer is used to access memory for the Synchronous Data </p>
<p>Acquisition </p>
<p>Depending </p>
<p>on </p>
<p>the </p>
<p>use </p>
<p>case, </p>
<p>microcontroller, </p>
<p>memory </p>
<p>model </p>
<p>and </p>
<p>compiler </p>
<p>either </p>
<p>XCP_MEMORY_FAR</p>
<p> or both memory qualifiers (</p>
<p>DAQBYTEPTR </p>
<p>and </p>
<p>MTABYTEPTR</p>
<p>) have to </p>
<p>be defined by the user. Alternatively the AUTOSAR Compiler Abstraction can be used. In </p>
<p>this case the pointer classes </p>
<p>XCP_MTA_DATA and </p>
<p>XCP_DAQ_DATA </p>
<p>Have to be defined as “far” according to the used compiler. </p>
<p><b>10.4 </b></p>
<p><b>Small memory model on ST10 / XC16X / C16X with Tasking Compiler </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How has XCP Protocol Layer to be configured in order to support small memory </p>
<p>model on the following microcontrollers: </p>
<p>ST10, XC16X, C16X with Tasking </p>
<p>Compiler</p>
<p>? </p>
<p> </p>
<p>If the small memory model is used and the two least significant bits of the DPP register </p>
<p>where the data of XCP is located is not equal the default DPP register value (i.e. the two </p>
<p>least significant bits of DPPx are unequal x, x=0..3) the configuration of the XCP Protocol </p>
<p>Layer has to be adapted in the user config file  </p>
<p>Disable type casts from pointers to integers : </p>
<p>#define XCP_ENABLE_NO_P2INT_CAST </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>106 / 109 </p>
<p><b>10.5 </b></p>
<p><b>Data Page Banking on Star12X / Metrowerks </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How has the XCP Protocol Layer to be configured in order to support data page </p>
<p>banking on the Star12X with Metrowerks compiler? </p>
<p> </p>
<p>In  order  to  use  data  page  banking  the  following  definition  has  to  be  added  to  the  user </p>
<p>config file: </p>
<p>#define XCP_MEMORY_MODEL_PAGED </p>
<p>If this option is enabled far pointers are used for memory access, and address conversions </p>
<p>are carried out in the in the application callback template </p>
<p>_xcp_appl.c</p>
<p>. These address </p>
<p>conversions have to adapted to the used derivative. </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>The data page banking support is implemented in the template </p>
<p>_xcp_appl.c</p>
<p> for </p>
<p>the MC9S12XDP512. For other Star12X derivatives the template has to be </p>
<p>adapted.</p>
<p> </p>
<p> </p>
<p><b>10.6 </b></p>
<p><b>Memory model banked on Star12X / Cosmic </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How has the XCP Protocol Layer to be configured in order to support the access </p>
<p>to far pages in the banked memory model on the Star12X with Cosmic compiler? </p>
<p> </p>
<p>In order to access far pages or support data page banking the following definitions have to </p>
<p>be added to the user config file: </p>
<p>#define XCP_MEMORY_MODEL_PAGED </p>
<p>#define XCP_ENABLE_MEM_ACCESS_BY_APPL </p>
<p>If this option is enabled far pointers are used for memory access, and address conversions </p>
<p>are carried out in the in the application callback template </p>
<p>_xcp_appl.c</p>
<p>. These address </p>
<p>conversions have to adapted to the used derivative. </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>The data page banking support is implemented in the template </p>
<p>_xcp_appl.c</p>
<p> for </p>
<p>the MC9S12XDP512. For other Star12X derivatives the template has to be </p>
<p>adapted.</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>107 / 109 </p>
<p><b>10.7 </b></p>
<p><b>Reflected CRC16 CCITT Checksum Calculation Algorithm </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How is the reflected CRC16 CCITT checksum calculation algorithm configured? </p>
<p> </p>
<p>The  XCP  Protocol  Layer  supports  both  the  standard  CRC16  CCITT  algorithm  and  the </p>
<p>reflected  CRC16  CCITT  algorithm.  In  order  to  use  the  reflected  algorithm  the  following </p>
<p>definition has to be added to the user config file: </p>
<p>#define XCP_ENABLE_CRC16CCITT_REFLECTED </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>Up to CANape version 5.6.30.3 (SP3) the standard CRC16 CCITT algorithm is </p>
<p>not supported, but the reflected one. </p>
<p>However a user checksum calculation DLL can be used in order to use the </p>
<p>standard algorithm with former versions of CANape.</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>108 / 109 </p>
<p><b>11  Bibliography </b></p>
<p>This manual refers to the following documents: </p>
<p>[I] </p>
<p>XCP -Part 1 - Overview  </p>
<p>Version 1.1 </p>
<p>[II]  XCP -Part 2- Protocol Layer Specification </p>
<p>Version 1.1 </p>
<p>[III] XCP -Part 5- Example Communication Sequences </p>
<p>Version 1.1 </p>
<p>[IV] Technical Reference XCP on CAN Transport Layer </p>
<p>Version 1.6 </p>
<p>[V] Technical Reference XCP on FlexRay Transport Layer </p>
<p>Version 1.9 </p>
<p>[VI] Technical Reference XCP on LIN Transport Layer </p>
<p>Version 1.0 </p>
<p>[VII] </p>
<p>AUTOSAR Specification of CRC Routines </p>
<p>Release 2.0.0 of 2006-04-28 </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 2.03.00 </p>
<p> </p>
<p>109 / 109 </p>
<p><b>12  Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector-informatik.com </b></p>
<p> </p>
<p> </p>
</body>
</html>
{% endraw %}