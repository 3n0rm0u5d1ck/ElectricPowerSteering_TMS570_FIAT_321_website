---
layout: default
title: TechnicalReference_Asr_EcuM
nav_order: 17
parent: Fiasa_326_327_EPS_TMS570
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR ECUM </b></p>
<p><b> </b></p>
<p>Technical Reference </p>
<p> </p>
<p> </p>
<p>Version 2.07.02 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Christian Marchl, Bethina Mausz </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>2 / 117</p>
<p><b>1 </b></p>
<p><b>Document Information </b></p>
<p><b>1.1 </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Christian Marchl </p>
<p>2006-10-12 </p>
<p>0.9 </p>
<p>Initial setup </p>
<p>Christian Marchl </p>
<p>2006-12-12 </p>
<p>1.0 </p>
<p>Rework of review findings, </p>
<p>first release </p>
<p>Christian Marchl </p>
<p>2007-07-30 </p>
<p>1.1 </p>
<p>Update chapter for AUTOSAR </p>
<p>2.1 release </p>
<p>Christian Marchl </p>
<p>2007-09-26 </p>
<p>1.2 </p>
<p>Description of EcuM_Init() </p>
<p>function corrected </p>
<p>Christian Marchl </p>
<p>2008-04-03 </p>
<p>1.03.00 </p>
<p>Added AUTOSAR 3 changes. </p>
<p>Christian Marchl </p>
<p>2008-05-07 </p>
<p>1.04.00 </p>
<p>File renamed according to </p>
<p>new standard name. </p>
<p>Christian Marchl, Heike Bischof </p>
<p>2008-05-07 </p>
<p>2.00.00 </p>
<p>Conversion to MICROSAR </p>
<p>Technical Reference. </p>
<p>Christian Marchl </p>
<p>2008-07-23 </p>
<p>2.00.01 </p>
<p>ESCAN00028261: Added TTII </p>
<p>in abbreviation table. </p>
<p>Christian Marchl </p>
<p>2008-10-22 </p>
<p>2.00.02 </p>
<p>Added description for </p>
<p>PreCompile implementation </p>
<p>variant. </p>
<p>Christian Marchl </p>
<p>2008-12-08 </p>
<p>2.01.00 </p>
<p>Added description for </p>
<p>currentMode port,  </p>
<p>Solved ESCAN00031271,  </p>
<p>Added description new callout </p>
<p>function for selection the boot </p>
<p>target. </p>
<p>Christian Marchl </p>
<p>2009-03-20 </p>
<p>2.02.00 </p>
<p>ESCAN00032687: Added </p>
<p>chapter for BSW initialization </p>
<p>example. ESCAN00032038: </p>
<p>Added chapter how to handle </p>
<p>wakeup events after </p>
<p>ShutdownOS() </p>
<p>Added Chapters 4.7, 4.8, 4.9, </p>
<p>4.10 </p>
<p>Christian Marchl </p>
<p>2009-05-19 </p>
<p>2.03.00 </p>
<p>ESCAN00034455: Update </p>
<p>Figure 2-1 AUTOSAR </p>
<p>architecture, </p>
<p>ESCAN00034997: Document </p>
<p>Restriction and deviations for </p>
<p>multiple configuration ECUs, </p>
<p>Ch 4.11. </p>
<p>Christian Marchl </p>
<p>2009-07-20 </p>
<p>2.04.00 </p>
<p>ESCAN00035749: Add </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>3 / 117</p>
<p>restriction for usage of </p>
<p>InitItems regarding modules </p>
<p>without standard AUTOSAR </p>
<p>naming (Ch 4.8.1) </p>
<p>ESCAN00036018: Add </p>
<p>chapter configuration variant. </p>
<p>(Ch 6.1) </p>
<p>ESCAN00036019: Add </p>
<p>changed SWC generation </p>
<p>behavior (Ch 5.8) </p>
<p>ESCAN00036020: Add </p>
<p>description for </p>
<p>UserBlockCode generation </p>
<p>(Ch 4.12) </p>
<p>Christian Marchl </p>
<p>2009-09-10 </p>
<p>2.04.01 </p>
<p>ESCAN00037245: corrected </p>
<p>description of </p>
<p>Compiler/Memory Abstraction </p>
<p>in Ch 4.3.  </p>
<p>Christian Marchl </p>
<p>2009-11-23 </p>
<p>2.04.02 </p>
<p>ESCAN00039291: Added Ch </p>
<p>7.3.6 </p>
<p>Christian Marchl </p>
<p>2010-04-13 </p>
<p>2.04.03 </p>
<p>ESCAN00037828: Corrected </p>
<p>execution sequence </p>
<p>regarding WdgM_SetMode() </p>
<p>(Ch 4.6) </p>
<p>Rework of review findings: </p>
<p>(Ch 3.6.3, 7.2.4) </p>
<p>ESCAN00042035: upda</p>
<p>ted </p>
<p>chapter 4.6 </p>
<p>ESCAN00039984: adde</p>
<p>d </p>
<p>chapter 7.2.5. </p>
<p>ESCAN00042228: extended </p>
<p>chapter 4.4.7 </p>
<p>ESCAN00042314: extended </p>
<p>chapter 5.6.2.1, 3.6.1. </p>
<p>ESCAN00042505: adde</p>
<p>d </p>
<p>chapter 4.10.4. </p>
<p>Bethina Mausz </p>
<p>2010-07-30 </p>
<p>2.04.04 </p>
<p>ESCAN00043965: Corrected </p>
<p>ECUM_SUBSTATE_MASK </p>
<p>description in chapter 5.2 </p>
<p>ESCAN00044273: Inserted </p>
<p>more description in chapter </p>
<p>4.4.7 </p>
<p>Bethina Mausz </p>
<p>2010-09-20 </p>
<p>2.04.05 </p>
<p>ESCAN00045520: inserted </p>
<p>Mcu_PerformReset call into </p>
<p>chapter 4.6 </p>
<p>Bethina Mausz </p>
<p>2010-10-15 </p>
<p>2.05.00 </p>
<p>ESCAN00045755: added </p>
<p>Nvm_GetErrorStatus call into </p>
<p>NvM_ReadAll loop chapter </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>4 / 117</p>
<p>4.8.2 </p>
<p>ESCAN00042662: added </p>
<p>information about CAT1 ISRs </p>
<p>in chapter 4.7 </p>
<p>ESCAN00046048 adapted </p>
<p>the description to new Sleep </p>
<p>Mode ISR handling in chapter </p>
<p>4.7 </p>
<p>ESCAN00046058 modified </p>
<p>the description for </p>
<p>Mcu_SetMode in chapter </p>
<p>4.10.4 </p>
<p>Bethina Mausz </p>
<p>2010-11-09 </p>
<p>2.05.00 </p>
<p>Update after review </p>
<p>Bethina Mausz </p>
<p>2011-01-24 </p>
<p>2.07.00 </p>
<p>ESCAN00046327 more </p>
<p>description about </p>
<p>EcuM_KillAllRUNRequests </p>
<p>added </p>
<p>ESCAN00045114 more </p>
<p>description about </p>
<p>NvM_CancelWriteAll usage </p>
<p>added </p>
<p>ESCAN00046158 more </p>
<p>description about </p>
<p>Rte_Feedback usage added </p>
<p>Figure 2-2 update </p>
<p>Added the description for new </p>
<p>configuration parameters: </p>
<p>“RTE Acknowledgment </p>
<p>Mechanism” and </p>
<p>“NvM_CancelWriteAll Timout”</p>
<p>Bethina Mausz </p>
<p>2011-02-09 </p>
<p>2.07.01 </p>
<p>Architecture Overview </p>
<p>updated, issues from last </p>
<p>review fixed and  </p>
<p>ESCAN00048281 </p>
<p>Bethina Mausz </p>
<p>2011-06-17 </p>
<p>2.07.02 </p>
<p>ESCAN00051734 </p>
<p>modifications in chapter 4.7 </p>
<p>Table 1-1   History of the document </p>
<p><b>1.2 </b></p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> </p>
<p>AUTOSAR_SWS_ECU_StateManager.pdf </p>
<p>V1.2.0 </p>
<p>[2] </p>
<p> </p>
<p>AUTOSAR_SWS_DET.pdf </p>
<p>V2.2.0 </p>
<p>[3] </p>
<p> </p>
<p>AUTOSAR_SWS_DEM.pdf </p>
<p>V2.2.1 </p>
<p>[4] </p>
<p> </p>
<p>AUTOSAR_BasicSoftwareModules.pdf </p>
<p>V1.2.0 </p>
<p>Table 1-2   Reference documents </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>5 / 117</p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector’s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>6 / 117</p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Document Information.................................................................................................... 2</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>History............................................................................................................... 2</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Reference Documents ...................................................................................... 4</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Introduction ................................................................................................................... 15</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Architecture Overview..................................................................................... 16</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Functional Description ................................................................................................. 18</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Features.......................................................................................................... 18</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Initialization ..................................................................................................... 19</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Startup into wakeup validation state ............................................................... 19</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>States .............................................................................................................. 20</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Main Functions ............................................................................................... 21</p>
<p> </p>
<p>3.5.1</p>
<p> </p>
<p>Run Request Protocol..................................................................................... 21</p>
<p> </p>
<p>3.5.2</p>
<p> </p>
<p>Time Triggered Increased Inoperation Protocol.............................................. 22</p>
<p> </p>
<p>3.5.3</p>
<p> </p>
<p>Wakeup Validation Protocol ............................................................................ 22</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Error Handling................................................................................................. 24</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>Development Error Reporting ......................................................................... 24</p>
<p> </p>
<p>3.6.1.1</p>
<p> </p>
<p>Parameter Checking ....................................................................................... 26</p>
<p> </p>
<p>3.6.2</p>
<p> </p>
<p>Production Code Error Reporting ................................................................... 28</p>
<p> </p>
<p>3.6.3</p>
<p> </p>
<p>Vector specific error reporting......................................................................... 28</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Integration ..................................................................................................................... 29</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Scope of Delivery............................................................................................ 29</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Static Files ...................................................................................................... 29</p>
<p> </p>
<p>4.1.2</p>
<p> </p>
<p>Dynamic Files ................................................................................................. 29</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Include Structure............................................................................................. 30</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping................................................... 30</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Dependencies on SW modules ...................................................................... 31</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>AUTOSAR OS ................................................................................................ 31</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>MCU................................................................................................................ 31</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>DEM ................................................................................................................ 32</p>
<p> </p>
<p>4.4.4</p>
<p> </p>
<p>DET................................................................................................................. 32</p>
<p> </p>
<p>4.4.5</p>
<p> </p>
<p>WDGM ............................................................................................................ 32</p>
<p> </p>
<p>4.4.6</p>
<p> </p>
<p>COMM ............................................................................................................ 32</p>
<p> </p>
<p>4.4.7</p>
<p> </p>
<p>NVM ................................................................................................................ 32</p>
<p> </p>
<p>4.4.8</p>
<p> </p>
<p>RTE................................................................................................................. 33</p>
<p> </p>
<p>4.4.9</p>
<p> </p>
<p>SCHM ............................................................................................................. 33</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>7 / 117</p>
<p>4.4.10</p>
<p> </p>
<p>Other BSW Modules ....................................................................................... 33</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Successive Adding of Modules ....................................................................... 34</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>Callout execution sequences.......................................................................... 34</p>
<p> </p>
<p>4.7</p>
<p> </p>
<p>Critical code sections...................................................................................... 40</p>
<p> </p>
<p>4.7.1</p>
<p> </p>
<p>Wakeup Interrupt Source Handling – General Description ............................. 40</p>
<p> </p>
<p>4.7.2</p>
<p> </p>
<p>Wakeup Interrupt Source Handling – Cautions and further Information ......... 41</p>
<p> </p>
<p>4.8</p>
<p> </p>
<p>AUTOSAR stack initialization.......................................................................... 41</p>
<p> </p>
<p>4.8.1</p>
<p> </p>
<p>Configuration set selection ............................................................................. 41</p>
<p> </p>
<p>4.8.2</p>
<p> </p>
<p>Initialization order............................................................................................ 43</p>
<p> </p>
<p>4.9</p>
<p> </p>
<p>Handling of wakeup events after ShutdownOS() ............................................ 44</p>
<p> </p>
<p>4.10</p>
<p> </p>
<p>Wakeup event handling and Wakeup Validation............................................. 44</p>
<p> </p>
<p>4.10.1</p>
<p> </p>
<p>Wakeup after a physical sleep mode .............................................................. 45</p>
<p> </p>
<p>4.10.1.1</p>
<p> </p>
<p>Use case description ...................................................................................... 45</p>
<p> </p>
<p>4.10.1.2</p>
<p> </p>
<p>Execution flow................................................................................................. 45</p>
<p> </p>
<p>4.10.1.3</p>
<p> </p>
<p>Callout implementation examples................................................................... 46</p>
<p> </p>
<p>4.10.2</p>
<p> </p>
<p>Handling of wakeup events while ECUM is in RUN state ............................... 47</p>
<p> </p>
<p>4.10.2.1</p>
<p> </p>
<p>Use case description ...................................................................................... 47</p>
<p> </p>
<p>4.10.2.2</p>
<p> </p>
<p>Execution flow................................................................................................. 47</p>
<p> </p>
<p>4.10.2.3</p>
<p> </p>
<p>Callout implementation examples................................................................... 47</p>
<p> </p>
<p>4.10.3</p>
<p> </p>
<p>Wakeup validation of communication channels (ECUM in RUN state)........... 47</p>
<p> </p>
<p>4.10.3.1</p>
<p> </p>
<p>Use case description ...................................................................................... 47</p>
<p> </p>
<p>4.10.3.2</p>
<p> </p>
<p>Execution flow................................................................................................. 47</p>
<p> </p>
<p>4.10.3.3</p>
<p> </p>
<p>Callout implementation examples................................................................... 49</p>
<p> </p>
<p>4.10.4</p>
<p> </p>
<p>Notes to Mcu_SetMode()................................................................................ 50</p>
<p> </p>
<p>4.11</p>
<p> </p>
<p>Multiple Identity ECUs .................................................................................... 50</p>
<p> </p>
<p>4.11.1</p>
<p> </p>
<p>Restrictions when implementation variant PreCompile is used ...................... 50</p>
<p> </p>
<p>4.11.1.1</p>
<p> </p>
<p>Initialization ..................................................................................................... 51</p>
<p> </p>
<p>4.11.1.2</p>
<p> </p>
<p>EcuM configuration ......................................................................................... 51</p>
<p> </p>
<p>4.12</p>
<p> </p>
<p>Generated Template Files............................................................................... 51</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>API Description ............................................................................................................. 53</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Interfaces Overview ........................................................................................ 53</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Type Definitions .............................................................................................. 53</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Services provided by ECUM........................................................................... 55</p>
<p> </p>
<p>5.3.1</p>
<p> </p>
<p>EcuM_Init ........................................................................................................ 55</p>
<p> </p>
<p>5.3.2</p>
<p> </p>
<p>EcuM_Shutdown............................................................................................. 56</p>
<p> </p>
<p>5.3.3</p>
<p> </p>
<p>EcuM_GetVersionInfo ..................................................................................... 57</p>
<p> </p>
<p>5.3.4</p>
<p> </p>
<p>EcuM_RequestRUN ....................................................................................... 57</p>
<p> </p>
<p>5.3.5</p>
<p> </p>
<p>EcuM_ReleaseRUN........................................................................................ 58</p>
<p> </p>
<p>5.3.6</p>
<p> </p>
<p>EcuM_ComM_RequestRUN ........................................................................... 58</p>
<p> </p>
<p>5.3.7</p>
<p> </p>
<p>EcuM_ComM_ReleaseRUN ........................................................................... 59</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>8 / 117</p>
<p>5.3.8</p>
<p> </p>
<p>EcuM_ComM_HasRequestedRUN ................................................................ 59</p>
<p> </p>
<p>5.3.9</p>
<p> </p>
<p>EcuM_RequestPOST_RUN............................................................................ 60</p>
<p> </p>
<p>5.3.10</p>
<p> </p>
<p>EcuM_ReleasePOST_RUN ............................................................................ 60</p>
<p> </p>
<p>5.3.11</p>
<p> </p>
<p>EcuM_KillAllRUNRequests ............................................................................. 61</p>
<p> </p>
<p>5.3.12</p>
<p> </p>
<p>EcuM_SelectShutdownTarget......................................................................... 62</p>
<p> </p>
<p>5.3.13</p>
<p> </p>
<p>EcuM_GetState............................................................................................... 62</p>
<p> </p>
<p>5.3.14</p>
<p> </p>
<p>EcuM_GetShutdownTarget ............................................................................. 63</p>
<p> </p>
<p>5.3.15</p>
<p> </p>
<p>EcuM_GetLastShutdownTarget ...................................................................... 63</p>
<p> </p>
<p>5.3.16</p>
<p> </p>
<p>EcuM_GetPendingWakeupEvents.................................................................. 64</p>
<p> </p>
<p>5.3.17</p>
<p> </p>
<p>EcuM_ClearWakeupEvent .............................................................................. 65</p>
<p> </p>
<p>5.3.18</p>
<p> </p>
<p>EcuM_GetValidatedWakeupEvents ................................................................ 65</p>
<p> </p>
<p>5.3.19</p>
<p> </p>
<p>EcuM_GetExpiredWakeupEvents................................................................... 65</p>
<p> </p>
<p>5.3.20</p>
<p> </p>
<p>EcuM_GetStatusOfWakeupSource................................................................. 66</p>
<p> </p>
<p>5.3.21</p>
<p> </p>
<p>EcuM_SelectApplicationMode ........................................................................ 67</p>
<p> </p>
<p>5.3.22</p>
<p> </p>
<p>EcuM_GetApplicationMode ............................................................................ 67</p>
<p> </p>
<p>5.3.23</p>
<p> </p>
<p>EcuM_SelectBootTarget ................................................................................. 68</p>
<p> </p>
<p>5.3.24</p>
<p> </p>
<p>EcuM_GetBootTarget ..................................................................................... 68</p>
<p> </p>
<p>5.3.25</p>
<p> </p>
<p>EcuM_MainFunction ....................................................................................... 69</p>
<p> </p>
<p>5.3.26</p>
<p> </p>
<p>EcuM_StartupTwo........................................................................................... 69</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Services used by ECUM................................................................................. 70</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>Callback Functions ......................................................................................... 70</p>
<p> </p>
<p>5.5.1</p>
<p> </p>
<p>EcuM_CB_NfyNvMJobEnd............................................................................. 70</p>
<p> </p>
<p>5.5.2</p>
<p> </p>
<p>EcuM_SetWakeupEvent ................................................................................. 71</p>
<p> </p>
<p>5.5.3</p>
<p> </p>
<p>EcuM_ValidateWakeupEvent.......................................................................... 71</p>
<p> </p>
<p>5.6</p>
<p> </p>
<p>Configurable Interfaces................................................................................... 72</p>
<p> </p>
<p>5.6.1</p>
<p> </p>
<p>Notifications .................................................................................................... 72</p>
<p> </p>
<p>5.6.2</p>
<p> </p>
<p>Callout Functions ............................................................................................ 72</p>
<p> </p>
<p>5.6.2.1</p>
<p> </p>
<p>EcuM_AL_DriverInitZero ................................................................................ 72</p>
<p> </p>
<p>5.6.2.2</p>
<p> </p>
<p>EcuM_AL_DriverInitOne ................................................................................. 73</p>
<p> </p>
<p>5.6.2.3</p>
<p> </p>
<p>EcuM_AL_DriverInitTwo ................................................................................. 74</p>
<p> </p>
<p>5.6.2.4</p>
<p> </p>
<p>EcuM_AL_DriverInitThree .............................................................................. 75</p>
<p> </p>
<p>5.6.2.5</p>
<p> </p>
<p>EcuM_DeterminePbConfiguration .................................................................. 76</p>
<p> </p>
<p>5.6.2.6</p>
<p> </p>
<p>EcuM_AL_SwitchOff ....................................................................................... 76</p>
<p> </p>
<p>5.6.2.7</p>
<p> </p>
<p>EcuM_AL_DriverRestart ................................................................................. 77</p>
<p> </p>
<p>5.6.2.8</p>
<p> </p>
<p>EcuM_GenerateRamHash.............................................................................. 77</p>
<p> </p>
<p>5.6.2.9</p>
<p> </p>
<p>EcuM_CheckRamHash .................................................................................. 78</p>
<p> </p>
<p>5.6.2.10</p>
<p> </p>
<p>EcuM_OnRTEStartup ..................................................................................... 78</p>
<p> </p>
<p>5.6.2.11</p>
<p> </p>
<p>EcuM_OnEnterRun......................................................................................... 79</p>
<p> </p>
<p>5.6.2.12</p>
<p> </p>
<p>EcuM_OnExitRun ........................................................................................... 79</p>
<p> </p>
<p>5.6.2.13</p>
<p> </p>
<p>EcuM_OnExitPostRun .................................................................................... 80</p>
<p> </p>
<p>5.6.2.14</p>
<p> </p>
<p>EcuM_OnPrepShutdown ................................................................................ 80</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>9 / 117</p>
<p>5.6.2.15</p>
<p> </p>
<p>EcuM_OnGoSleep .......................................................................................... 81</p>
<p> </p>
<p>5.6.2.16</p>
<p> </p>
<p>EcuM_OnGoOffOne........................................................................................ 81</p>
<p> </p>
<p>5.6.2.17</p>
<p> </p>
<p>EcuM_OnGoOffTwo........................................................................................ 82</p>
<p> </p>
<p>5.6.2.18</p>
<p> </p>
<p>EcuM_OnWakeupReaction............................................................................. 82</p>
<p> </p>
<p>5.6.2.19</p>
<p> </p>
<p>EcuM_EnableWakeupSources ....................................................................... 83</p>
<p> </p>
<p>5.6.2.20</p>
<p> </p>
<p>EcuM_DisableWakeupSources ...................................................................... 84</p>
<p> </p>
<p>5.6.2.21</p>
<p> </p>
<p>EcuM_StartWakeupSources ........................................................................... 85</p>
<p> </p>
<p>5.6.2.22</p>
<p> </p>
<p>EcuM_StopWakeupSources ........................................................................... 86</p>
<p> </p>
<p>5.6.2.23</p>
<p> </p>
<p>EcuM_CheckWakeup ..................................................................................... 86</p>
<p> </p>
<p>5.6.2.24</p>
<p> </p>
<p>EcuM_CheckValidation ................................................................................... 87</p>
<p> </p>
<p>5.6.2.25</p>
<p> </p>
<p>EcuM_GeneratorCompatibilityError ................................................................ 87</p>
<p> </p>
<p>5.6.2.26</p>
<p> </p>
<p>EcuM_Appl_SelectBootTarget ........................................................................ 88</p>
<p> </p>
<p>5.6.2.27</p>
<p> </p>
<p>EcuM_Appl_GetBootTarget ............................................................................ 89</p>
<p> </p>
<p>5.6.2.28</p>
<p> </p>
<p>EcuM_McuSetMode ....................................................................................... 89</p>
<p> </p>
<p>5.6.3</p>
<p> </p>
<p>Mode switch notification functions .................................................................. 90</p>
<p> </p>
<p>5.6.3.1</p>
<p> </p>
<p>Appl_EcuM_currentMode_currentMode ......................................................... 90</p>
<p> </p>
<p>5.6.3.2</p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode ......................................................... 91</p>
<p> </p>
<p>5.7</p>
<p> </p>
<p>Service Ports .................................................................................................. 91</p>
<p> </p>
<p>5.7.1</p>
<p> </p>
<p>Client Server Interface .................................................................................... 91</p>
<p> </p>
<p>5.7.1.1</p>
<p> </p>
<p>Provide Ports on ECUM side .......................................................................... 91</p>
<p> </p>
<p>5.7.1.1.1</p>
<p> </p>
<p>StateRequest Port........................................................................................... 92</p>
<p> </p>
<p>5.7.1.1.2</p>
<p> </p>
<p>ShutdownTarget Port ...................................................................................... 92</p>
<p> </p>
<p>5.7.1.1.3</p>
<p> </p>
<p>BootTarget Port............................................................................................... 92</p>
<p> </p>
<p>5.7.1.1.4</p>
<p> </p>
<p>ApplicationMode Port...................................................................................... 92</p>
<p> </p>
<p>5.7.1.2</p>
<p> </p>
<p>Require Ports on ECUM side.......................................................................... 93</p>
<p> </p>
<p>5.7.1.2.1</p>
<p> </p>
<p>currentMode Port ............................................................................................ 93</p>
<p> </p>
<p>5.7.2</p>
<p> </p>
<p>Sender Receiver Interface .............................................................................. 93</p>
<p> </p>
<p>5.8</p>
<p> </p>
<p>Software Component Template....................................................................... 93</p>
<p> </p>
<p>5.8.1</p>
<p> </p>
<p>Generation by EAD......................................................................................... 93</p>
<p> </p>
<p>5.8.2</p>
<p> </p>
<p>Generation by DaVinci Configurator ............................................................... 94</p>
<p> </p>
<p>5.8.3</p>
<p> </p>
<p>Import into DaVinci Developer ........................................................................ 95</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Configuration ................................................................................................................ 96</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Configuration Variants..................................................................................... 96</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Configuration of ECUM with DaVinci Configurator/EAD................................. 96</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Start configuration of the ECUM ..................................................................... 96</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>ECUM Configuration Perspective ................................................................... 96</p>
<p> </p>
<p>6.2.2.1</p>
<p> </p>
<p>Node &quot;Startup&quot; ................................................................................................ 96</p>
<p> </p>
<p>6.2.2.1.1</p>
<p> </p>
<p>Node &quot;Used Module Configuration&quot; ................................................................ 96</p>
<p> </p>
<p>6.2.2.1.2</p>
<p> </p>
<p>Node &quot;Mcu&quot;..................................................................................................... 97</p>
<p> </p>
<p>6.2.2.1.3</p>
<p> </p>
<p>Node &quot;WdgM&quot; ................................................................................................. 97</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>10 / 117</p>
<p>6.2.2.1.4</p>
<p> </p>
<p>Node &quot;Nvm&quot; .................................................................................................... 97</p>
<p> </p>
<p>6.2.2.1.5</p>
<p> </p>
<p>Node &quot;Dem&quot; .................................................................................................... 98</p>
<p> </p>
<p>6.2.2.1.6</p>
<p> </p>
<p>Node &quot;Det&quot; ...................................................................................................... 98</p>
<p> </p>
<p>6.2.2.1.7</p>
<p> </p>
<p>Node &quot;ComM&quot; ................................................................................................. 98</p>
<p> </p>
<p>6.2.2.1.8</p>
<p> </p>
<p>Node &quot;Rte&quot; ...................................................................................................... 99</p>
<p> </p>
<p>6.2.2.1.9</p>
<p> </p>
<p>Node &quot;Os&quot; ....................................................................................................... 99</p>
<p> </p>
<p>6.2.2.1.10</p>
<p> </p>
<p>Node &quot;SchM&quot; ................................................................................................ 100</p>
<p> </p>
<p>6.2.2.1.11</p>
<p> </p>
<p>Node “Init Configuration Sets”....................................................................... 100</p>
<p> </p>
<p>6.2.2.1.12</p>
<p> </p>
<p>Nodes &quot;EcuMDriverInitListOne&quot;, &quot;EcuMDriverInitListTwo&quot;, </p>
<p>“EcuMDriverInitListThree”, &quot;EcuMDriverRestartList&quot; .................................... 100</p>
<p> </p>
<p>6.2.2.1.13</p>
<p> </p>
<p>Node Additional Includes .............................................................................. 101</p>
<p> </p>
<p>6.2.2.2</p>
<p> </p>
<p>Node &quot;EcuM User&quot;........................................................................................ 102</p>
<p> </p>
<p>6.2.2.3</p>
<p> </p>
<p>Node &quot;Time settings&quot; .................................................................................... 102</p>
<p> </p>
<p>6.2.2.4</p>
<p> </p>
<p>Node &quot;Wakeup&quot;............................................................................................. 102</p>
<p> </p>
<p>6.2.2.5</p>
<p> </p>
<p>WdgM Modes................................................................................................ 103</p>
<p> </p>
<p>6.2.2.6</p>
<p> </p>
<p>Node “Sleep Modes”..................................................................................... 104</p>
<p> </p>
<p>6.2.2.7</p>
<p> </p>
<p>Child Nodes of “Sleep Modes”...................................................................... 104</p>
<p> </p>
<p>6.2.2.8</p>
<p> </p>
<p>Node “TTII” ................................................................................................... 105</p>
<p> </p>
<p>6.2.2.9</p>
<p> </p>
<p>Node “Shutdown”.......................................................................................... 105</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>General Settings Perspective ....................................................................... 106</p>
<p> </p>
<p>6.2.4</p>
<p> </p>
<p>Module API Perspective................................................................................ 109</p>
<p> </p>
<p>6.2.5</p>
<p> </p>
<p>Module Callouts Perspective ........................................................................ 109</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>AUTOSAR Standard Compliance................................................................................111</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Deviations ...................................................................................................... 111</p>
<p> </p>
<p>7.1.1</p>
<p> </p>
<p>Service Port Generation ................................................................................111</p>
<p> </p>
<p>7.1.2</p>
<p> </p>
<p>Supervised Entity in WDGM ..........................................................................111</p>
<p> </p>
<p>7.1.3</p>
<p> </p>
<p>Parameter “EcuMWdgMStartupModeRef” not supported ..............................111</p>
<p> </p>
<p>7.1.4</p>
<p> </p>
<p>Signature and name of DriverInitLists in configuration variant “post-build”....111</p>
<p> </p>
<p>7.1.5</p>
<p> </p>
<p>Enabling/Disabling wakeup sources ..............................................................111</p>
<p> </p>
<p>7.1.6</p>
<p> </p>
<p>Execution flow in shutdown sequence...........................................................111</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Additions/ Extensions ....................................................................................112</p>
<p> </p>
<p>7.2.1</p>
<p> </p>
<p>Parameter Checking ......................................................................................112</p>
<p> </p>
<p>7.2.2</p>
<p> </p>
<p>State Request service port.............................................................................112</p>
<p> </p>
<p>7.2.3</p>
<p> </p>
<p>Wakeup validation in each state ....................................................................112</p>
<p> </p>
<p>7.2.4</p>
<p> </p>
<p>Callout EcuM_GeneratorCompatibilityError() ................................................112</p>
<p> </p>
<p>7.2.5</p>
<p> </p>
<p>Buffering of wakeup events until COMM is initialized ....................................112</p>
<p> </p>
<p>7.3</p>
<p> </p>
<p>Limitations......................................................................................................113</p>
<p> </p>
<p>7.3.1</p>
<p> </p>
<p>Link-time Configuration not supported...........................................................113</p>
<p> </p>
<p>7.3.2</p>
<p> </p>
<p>Configuration Check via Consistency Hash not implemented .......................113</p>
<p> </p>
<p>7.3.3</p>
<p> </p>
<p>Not implemented Callouts..............................................................................113</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>11 / 117</p>
<p>7.3.4</p>
<p> </p>
<p>References in ECUC File...............................................................................113</p>
<p> </p>
<p>7.3.5</p>
<p> </p>
<p>Not supported configuration parameters........................................................113</p>
<p> </p>
<p>7.3.6</p>
<p> </p>
<p>Polling of Wakeup Sources Is Not Supported................................................113</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Glossary and Abbreviations ...................................................................................... 114</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>Glossary.........................................................................................................114</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>Abbreviations .................................................................................................115</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Contact ......................................................................................................................... 117</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>12 / 117</p>
<p><b>Illustrations </b></p>
<p>Figure 2-1</p>
<p> </p>
<p>AUTOSAR architecture................................................................................... 16</p>
<p> </p>
<p>Figure 2-2</p>
<p> </p>
<p>Interfaces to adjacent modules of the EcuM................................................... 17</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>State diagram.................................................................................................. 21</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Include structure ............................................................................................. 30</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>Generate an ECUM software component template ........................................ 94</p>
<p> </p>
<p>Figure 5-2</p>
<p> </p>
<p>Import a new software component into DaVinci Developer ............................ 95</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>Table 1-1 </p>
<p> </p>
<p>History of the document.................................................................................... 4</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Reference documents....................................................................................... 4</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Supported SWS features ................................................................................ 18</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Not supported SWS features .......................................................................... 19</p>
<p> </p>
<p>Table 3-3 </p>
<p> </p>
<p>States .............................................................................................................. 20</p>
<p> </p>
<p>Table 3-4 </p>
<p> </p>
<p>Mapping of service IDs to services ................................................................. 25</p>
<p> </p>
<p>Table 3-5 </p>
<p> </p>
<p>Errors reported to DET ................................................................................... 26</p>
<p> </p>
<p>Table 3-6 </p>
<p> </p>
<p>Development Error detection: Assignment of checks to services ................... 27</p>
<p> </p>
<p>Table 3-7 </p>
<p> </p>
<p>Errors reported to DEM................................................................................... 28</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Static files........................................................................................................ 29</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Generated files ............................................................................................... 29</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>Compiler abstraction and memory mapping ................................................... 31</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>initialization order............................................................................................ 44</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Type definitions............................................................................................... 55</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>EcuM_Init ........................................................................................................ 56</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>EcuM_Shutdown............................................................................................. 56</p>
<p> </p>
<p>Table 5-4 </p>
<p> </p>
<p>EcuM_GetVersionInfo ..................................................................................... 57</p>
<p> </p>
<p>Table 5-5 </p>
<p> </p>
<p>EcuM_RequestRUN ....................................................................................... 57</p>
<p> </p>
<p>Table 5-6 </p>
<p> </p>
<p>EcuM_ReleaseRUN........................................................................................ 58</p>
<p> </p>
<p>Table 5-7 </p>
<p> </p>
<p>EcuM_ComM_RequestRUN ........................................................................... 58</p>
<p> </p>
<p>Table 5-8 </p>
<p> </p>
<p>EcuM_ComM_ReleaseRUN ........................................................................... 59</p>
<p> </p>
<p>Table 5-9 </p>
<p> </p>
<p>EcuM_ComM_HasRequestedRUN ................................................................ 59</p>
<p> </p>
<p>Table 5-10 </p>
<p> </p>
<p>EcuM_RequestPOST_RUN............................................................................ 60</p>
<p> </p>
<p>Table 5-11 </p>
<p> </p>
<p>EcuM_ReleasePOST_RUN ............................................................................ 60</p>
<p> </p>
<p>Table 5-12 </p>
<p> </p>
<p>EcuM_KillAllRUNRequests ............................................................................. 61</p>
<p> </p>
<p>Table 5-13 </p>
<p> </p>
<p>EcuM_SelectShutdownTarget......................................................................... 62</p>
<p> </p>
<p>Table 5-14 </p>
<p> </p>
<p>EcuM_GetState............................................................................................... 63</p>
<p> </p>
<p>Table 5-15 </p>
<p> </p>
<p>EcuM_GetShutdownTarget ............................................................................. 63</p>
<p> </p>
<p>Table 5-16 </p>
<p> </p>
<p>EcuM_GetLastShutdownTarget ...................................................................... 64</p>
<p> </p>
<p>Table 5-17 </p>
<p> </p>
<p>EcuM_GetPendingWakeupEvents.................................................................. 64</p>
<p> </p>
<p>Table 5-18 </p>
<p> </p>
<p>EcuM_GetPendingWakeupEvents.................................................................. 65</p>
<p> </p>
<p>Table 5-19 </p>
<p> </p>
<p>EcuM_GetValidatedWakeupEvents ................................................................ 65</p>
<p> </p>
<p>Table 5-20 </p>
<p> </p>
<p>EcuM_GetExpiredWakeupEvents................................................................... 66</p>
<p> </p>
<p>Table 5-21 </p>
<p> </p>
<p>EcuM_GetStatusOfWakeupSource................................................................. 66</p>
<p> </p>
<p>Table 5-22 </p>
<p> </p>
<p>EcuM_SelectApplicationMode ........................................................................ 67</p>
<p> </p>
<p>Table 5-23 </p>
<p> </p>
<p>EcuM_GetApplicationMode ............................................................................ 68</p>
<p> </p>
<p>Table 5-24 </p>
<p> </p>
<p>EcuM_SelectBootTarget ................................................................................. 68</p>
<p> </p>
<p>Table 5-25 </p>
<p> </p>
<p>EcuM_GetBootTarget ..................................................................................... 69</p>
<p> </p>
<p>Table 5-26 </p>
<p> </p>
<p>EcuM_MainFunction ....................................................................................... 69</p>
<p> </p>
<p>Table 5-27 </p>
<p> </p>
<p>EcuM_StartupTwo........................................................................................... 70</p>
<p> </p>
<p>Table 5-28 </p>
<p> </p>
<p>EcuM_CB_NfyNvMJobEnd............................................................................. 71</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>13 / 117</p>
<p>Table 5-29 </p>
<p> </p>
<p>EcuM_SetWakeupEvent ................................................................................. 71</p>
<p> </p>
<p>Table 5-30 </p>
<p> </p>
<p>EcuM_ValidateWakeupEvent.......................................................................... 72</p>
<p> </p>
<p>Table 5-31 </p>
<p> </p>
<p>EcuM_AL_DriverInitOne ................................................................................. 74</p>
<p> </p>
<p>Table 5-32 </p>
<p> </p>
<p>EcuM_AL_DriverInitTwo ................................................................................. 75</p>
<p> </p>
<p>Table 5-33 </p>
<p> </p>
<p>EcuM_AL_DriverInitThree .............................................................................. 75</p>
<p> </p>
<p>Table 5-34 </p>
<p> </p>
<p>EcuM_DeterminePbConfiguration .................................................................. 76</p>
<p> </p>
<p>Table 5-35 </p>
<p> </p>
<p>EcuM_AL_SwitchOff ....................................................................................... 77</p>
<p> </p>
<p>Table 5-36 </p>
<p> </p>
<p>EcuM_AL_DriverRestart ................................................................................. 77</p>
<p> </p>
<p>Table 5-37 </p>
<p> </p>
<p>EcuM_GenerateRamHash.............................................................................. 78</p>
<p> </p>
<p>Table 5-38 </p>
<p> </p>
<p>EcuM_CheckRamHash .................................................................................. 78</p>
<p> </p>
<p>Table 5-39 </p>
<p> </p>
<p>EcuM_OnRTEStartup ..................................................................................... 79</p>
<p> </p>
<p>Table 5-40 </p>
<p> </p>
<p>EcuM_OnEnterRun......................................................................................... 79</p>
<p> </p>
<p>Table 5-41 </p>
<p> </p>
<p>EcuM_OnExitRun ........................................................................................... 80</p>
<p> </p>
<p>Table 5-42 </p>
<p> </p>
<p>EcuM_OnExitPostRun .................................................................................... 80</p>
<p> </p>
<p>Table 5-43 </p>
<p> </p>
<p>EcuM_OnPrepShutdown ................................................................................ 81</p>
<p> </p>
<p>Table 5-44 </p>
<p> </p>
<p>EcuM_OnGoSleep .......................................................................................... 81</p>
<p> </p>
<p>Table 5-45 </p>
<p> </p>
<p>EcuM_OnGoOffOne ....................................................................................... 82</p>
<p> </p>
<p>Table 5-46 </p>
<p> </p>
<p>EcuM_OnGoOffTwo........................................................................................ 82</p>
<p> </p>
<p>Table 5-47 </p>
<p> </p>
<p>EcuM_OnWakeupReaction............................................................................. 83</p>
<p> </p>
<p>Table 5-48 </p>
<p> </p>
<p>EcuM_EnableWakeupSources ....................................................................... 84</p>
<p> </p>
<p>Table 5-49 </p>
<p> </p>
<p>EcuM_DisableWakeupSources ...................................................................... 85</p>
<p> </p>
<p>Table 5-50 </p>
<p> </p>
<p>EcuM_StartWakeupSources ........................................................................... 85</p>
<p> </p>
<p>Table 5-51 </p>
<p> </p>
<p>EcuM_StopWakeupSources ........................................................................... 86</p>
<p> </p>
<p>Table 5-52 </p>
<p> </p>
<p>EcuM_CheckWakeup ..................................................................................... 86</p>
<p> </p>
<p>Table 5-53 </p>
<p> </p>
<p>EcuM_CheckValidation ................................................................................... 87</p>
<p> </p>
<p>Table 5-54 </p>
<p> </p>
<p>EcuM_GeneratorCompatibilityError ................................................................ 88</p>
<p> </p>
<p>Table 5-55 </p>
<p> </p>
<p>EcuM_Appl_SelectBootTarget ........................................................................ 89</p>
<p> </p>
<p>Table 5-56 </p>
<p> </p>
<p>EcuM_Appl_GetBootTarget ............................................................................ 89</p>
<p> </p>
<p>Table 5-57 </p>
<p> </p>
<p>EcuM_McuSetMode ....................................................................................... 90</p>
<p> </p>
<p>Table 5-58 </p>
<p> </p>
<p>Appl_EcuM_currentMode_currentMode ......................................................... 90</p>
<p> </p>
<p>Table 5-59 </p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode ......................................................... 91</p>
<p> </p>
<p>Table 5-60 </p>
<p> </p>
<p>StateRequest Port........................................................................................... 92</p>
<p> </p>
<p>Table 5-61 </p>
<p> </p>
<p>ShutdownTarget Port ...................................................................................... 92</p>
<p> </p>
<p>Table 5-62 </p>
<p> </p>
<p>BootTarget Port............................................................................................... 92</p>
<p> </p>
<p>Table 5-63 </p>
<p> </p>
<p>ApplicationMode Port...................................................................................... 93</p>
<p> </p>
<p>Table 5-64 </p>
<p> </p>
<p>currentMode Port ............................................................................................ 93</p>
<p> </p>
<p>Table 6-1 </p>
<p> </p>
<p>Node &quot;Mcu&quot;..................................................................................................... 97</p>
<p> </p>
<p>Table 6-2 </p>
<p> </p>
<p>Node &quot;WdgM&quot; ................................................................................................. 97</p>
<p> </p>
<p>Table 6-3 </p>
<p> </p>
<p>Node &quot;Nvm&quot; .................................................................................................... 97</p>
<p> </p>
<p>Table 6-4 </p>
<p> </p>
<p>Node &quot;Dem&quot; .................................................................................................... 98</p>
<p> </p>
<p>Table 6-5 </p>
<p> </p>
<p>Node &quot;Det&quot; ...................................................................................................... 98</p>
<p> </p>
<p>Table 6-6 </p>
<p> </p>
<p>Node &quot;ComM&quot; ................................................................................................. 99</p>
<p> </p>
<p>Table 6-7 </p>
<p> </p>
<p>Node &quot;Rte&quot; ...................................................................................................... 99</p>
<p> </p>
<p>Table 6-8 </p>
<p> </p>
<p>Node &quot;Os&quot; ....................................................................................................... 99</p>
<p> </p>
<p>Table 6-9 </p>
<p> </p>
<p>Node &quot;SchM&quot; ................................................................................................ 100</p>
<p> </p>
<p>Table 6-10 </p>
<p> </p>
<p> Node “Init Configuration Sets” ..................................................................... 100</p>
<p> </p>
<p>Table 6-11 </p>
<p> </p>
<p>Nodes “EcuMDriverInitListOne”, “EcuMDriverInitListTwo”, </p>
<p>“EcuMDriverInitListThree”, “EcuMDriverRestartList”..................................... 101</p>
<p> </p>
<p>Table 6-12 </p>
<p> </p>
<p>Node &quot;Additional Includes&quot; ........................................................................... 101</p>
<p> </p>
<p>Table 6-13 </p>
<p> </p>
<p>Node &quot;EcuM User&quot;........................................................................................ 102</p>
<p> </p>
<p>Table 6-14 </p>
<p> </p>
<p>Node &quot;Time settings&quot; .................................................................................... 102</p>
<p> </p>
<p>Table 6-15 </p>
<p> </p>
<p>Node &quot;Wakeup Sources&quot; .............................................................................. 103</p>
<p> </p>
<p>Table 6-16 </p>
<p> </p>
<p> Node “WdgM Modes”................................................................................... 104</p>
<p> </p>
<p>Table 6-17 </p>
<p> </p>
<p>Child Nodes of “Sleep Modes”...................................................................... 104</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>14 / 117</p>
<p>Table 6-18 </p>
<p> </p>
<p>Node “TTII” ................................................................................................... 105</p>
<p> </p>
<p>Table 6-19 </p>
<p> </p>
<p>Node “Shutdown”.......................................................................................... 106</p>
<p> </p>
<p>Table 6-20 </p>
<p> </p>
<p>General Settings ........................................................................................... 109</p>
<p> </p>
<p>Table 6-21 </p>
<p> </p>
<p>Module API ................................................................................................... 109</p>
<p> </p>
<p>Table 6-22 </p>
<p> </p>
<p>Module Callouts .............................................................................................110</p>
<p> </p>
<p>Table 8-1 </p>
<p> </p>
<p>Glossary.........................................................................................................115</p>
<p> </p>
<p>Table 8-2 </p>
<p> </p>
<p>Abbreviations .................................................................................................116</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>15 / 117</p>
<p><b>2 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the functionality, API and configuration of the AUTOSAR BSW </p>
<p>module ECUM as specified in [1].  </p>
<p> </p>
<p><b>Supported AUTOSAR Release: </b></p>
<p>3 </p>
<p><b>Supported Configuration Variants: </b></p>
<p>post-build, pre-compile </p>
<p><b> </b></p>
<p> </p>
<p><b>Vendor ID: </b></p>
<p>ECUM_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>ECUM_MODULE_ID   </p>
<p>10 decimal </p>
<p>(according to ref. [4]) </p>
<p>For the precise AUTOSAR Release 3.x please see the release specific documentation. </p>
<p> </p>
<p>This document describes the functionality and API of the ECU State Manager (ECUM) as a </p>
<p>hardware independent module. </p>
<p>The main tasks of the ECUM are  </p>
<p></p>
<p> </p>
<p>Initialization </p>
<p>of </p>
<p>all </p>
<p>BSW </p>
<p>(Basis </p>
<p>Software) </p>
<p>modules </p>
<p>in </p>
<p>the </p>
<p>startup </p>
<p>phase </p>
<p>of </p>
<p>the </p>
<p>microcontroller including OS and RTE </p>
<p></p>
<p> </p>
<p>Preparation of the microcontroller for a sleep phase and the following wakeup </p>
<p></p>
<p> </p>
<p>Performing an ordered shutdown of the ECU </p>
<p>To fulfill this tasks the ECUM offers several mechanism which will be described later in this </p>
<p>document, e.g.:  </p>
<p></p>
<p> </p>
<p>RUN Request Protocol </p>
<p></p>
<p> </p>
<p>Time Triggered Increased Inoperation Protocol (TTII) </p>
<p></p>
<p> </p>
<p>Wakeup validation protocol </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>16 / 117</p>
<p><b>2.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the ECUM is located in the AUTOSAR architecture. </p>
<p> </p>
<p>Figure 2-1 AUTOSAR architecture </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>17 / 117</p>
<p> </p>
<p>The next figure shows the interfaces to adjacent modules of the ECUM. These interfaces </p>
<p>are described in chapter 5.  </p>
<p><b>cmp Architecture_Ov erv iew</b></p>
<p><b>SW-C / RTE</b></p>
<p><b>SchM</b></p>
<p><b>AUTOSAR OS</b></p>
<p><b>Dem</b></p>
<p><b>Det</b></p>
<p><b>WdgM</b></p>
<p><b>ComM</b></p>
<p><b>Nv M</b></p>
<p><b>Mcu</b></p>
<p><b>other BSW </b></p>
<p><b>Modules</b></p>
<p><b>EcuM</b></p>
<p>Rte_Switch_currentMode_currentMode</p>
<p>«optional»</p>
<p>NvM_Init()</p>
<p>«optional»</p>
<p>ComM_EcuM_WakeUpIndication()</p>
<p>«optional»</p>
<p>ComM_EcuM_RunModeIndication()</p>
<p>«optional»</p>
<p>ComM_DeInit()</p>
<p>«optional»</p>
<p>ComM_Init()</p>
<p>«optional»</p>
<p>WdgM_SetMode()</p>
<p>«optional»</p>
<p>WdgM_Init()</p>
<p>«optional»</p>
<p>Interrupt locking services</p>
<p>«optional»</p>
<p>Mcu_Init()</p>
<p>ReleaseResource()</p>
<p>NvM_ReadAll()</p>
<p>«optional»</p>
<p>EcuM_MainFunction()</p>
<p>«optional»</p>
<p>GetResource()</p>
<p>StartOS()</p>
<p>Interrupt locking services</p>
<p>«optional»</p>
<p>SchM_Init()</p>
<p>«optional»</p>
<p>&lt;BSW&gt;_Init()</p>
<p>«optional»</p>
<p>Mcu_PerformReset()</p>
<p>Mcu_SetMode()</p>
<p>ShutdownOS()</p>
<p>EcuM_BootTarget</p>
<p>«optional»</p>
<p>EcuM_KillAllRUNRequests</p>
<p>«optional»</p>
<p>EcuM_ComM_HasRequestedRUN</p>
<p>«optional»</p>
<p>EcuM_ComM_ReleaseRUN</p>
<p>«optional»</p>
<p>EcuM_ComM_RequestRUN</p>
<p>«optional»</p>
<p>NvM_KillWriteAll()</p>
<p>«optional»</p>
<p>Rte_Feedback_EcuM_currentMode_currentMode</p>
<p>«optional»</p>
<p>Mcu_GetResetReason</p>
<p>EcuM_StateRequest</p>
<p>«optional»</p>
<p>NvM_CancelWriteAll()</p>
<p>«optional»</p>
<p>Dem_ReportErrorStatus()</p>
<p>«optional»</p>
<p>NvM_WriteAll()</p>
<p>«optional»</p>
<p>EcuM_ShutdownTarget</p>
<p>«optional»</p>
<p>Rte_Start()</p>
<p>«optional»</p>
<p>Rte_Stop()</p>
<p>«optional»</p>
<p>Dem_Shutdown()</p>
<p>«optional»</p>
<p>Dem_Init()</p>
<p>«optional»</p>
<p>Dem_PreInit()</p>
<p>«optional»</p>
<p>Det_Init()</p>
<p>«optional»</p>
<p>Det_ReportError()</p>
<p>«optional»</p>
<p>EcuM_GetVersionInfo</p>
<p>«optional»</p>
<p>EcuM_ApplicationMode</p>
<p>«optional»</p>
<p> </p>
<p>Figure 2-2 Interfaces to adjacent modules of the EcuM </p>
<p>Applications do not access the services of the BSW modules directly. They use the service </p>
<p>ports provided by the BSW modules via the RTE. The service ports provided by the ECUM </p>
<p>are listed in chapter 5.7 and are defined in [1]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>18 / 117</p>
<p><b>3 </b></p>
<p><b>Functional Description </b></p>
<p><b>3.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in this chapter cover the complete functionality specified in [1]. </p>
<p>The  &quot;supported&quot;  and  &quot;not  supported&quot;  features  are  presented  in  the  following  two  tables. </p>
<p>For further information of not supported features also see chapter 7. </p>
<p> </p>
<p>The following features described in [1] are supported: </p>
<p><b>Feature </b></p>
<p>Support of Run Request Protocol. </p>
<p>Support of time triggered increased inoperation protocol (TTII). </p>
<p>Configuration of different wakeup sources. </p>
<p>Configuration of EcuM users. </p>
<p>Configuration of software component name. </p>
<p>Configurable startup sequence of the complete BSW stack. </p>
<p>Possibility to add additional initialization code into the initialization lists. </p>
<p>Notification of the Communication Manager every time when run state is entered. </p>
<p>Notification of the Communication Manager if a wakeup event occurs on communication </p>
<p>channels. </p>
<p>Assignment of communication channels to wakeup sources. </p>
<p>Configuration of different sleep modes. </p>
<p>Selection of different shutdown targets. </p>
<p>Configurable mechanism to protect critical sections is supported (e.g. by OS functions, by </p>
<p>SCHM, assembler statements, etc.). </p>
<p>Support of different kinds of parameter checks which can be switched on or off. </p>
<p>Generation of the SW-C description file needed for the generation of the RTE. </p>
<p>Additional port interface operation GetState provided. </p>
<p>Service Port: EcuM_StateRequest </p>
<p>Service Port: EcuM_CurrentMode </p>
<p>Service Port: EcuM_ShutdownTarget </p>
<p>Service Port: EcuM_BootTarget </p>
<p>Service Port: EcuM_ApplicationMode </p>
<p>Table 3-1   Supported SWS features </p>
<p>The following features described in [1] are not supported: </p>
<p><b>Feature </b></p>
<p>Callout EcuMDriverInitListZero is not in post-build structure. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>19 / 117</p>
<p><b>Feature </b></p>
<p>Callout </p>
<p>EcuM_SleepActivity()</p>
<p> is not supported. </p>
<p>Callout </p>
<p>EcuM_Errorhook()</p>
<p> is not supported. </p>
<p>Consistency hash checking according to AUTOSAR specification is not supported. </p>
<p>Handling of ECUM as supervised entity of WDGM is not supported. </p>
<p>Table 3-2   Not supported SWS features </p>
<p><b>3.2 </b></p>
<p><b>Initialization </b></p>
<p>The initialization of the ECUM is split into two parts: one part is the initialization before the </p>
<p>OS is up and running and the second part must be executed when the OS is started. </p>
<p> </p>
<p>The first part will be performed by the function </p>
<p>EcuM_Init()</p>
<p>. This function executes the </p>
<p>DriverInitLists “EcuMDriverInitListZero” and “EcuMDriverInitListOne” where the basic driver </p>
<p>initialization should be performed. </p>
<p>EcuM_Init()</p>
<p> starts the AUTOSAR OS by calling the </p>
<p>function </p>
<p>StartOS()</p>
<p>. </p>
<p> </p>
<p>The  second  part  of  the  initialization  sequence  will  be  executed  by  the  ECUM  API </p>
<p>EcuM_StartupTwo()</p>
<p>. The integrator must ensure that this function is called once right </p>
<p>after the start of the OS. Within this function the DriverInitLists “EcuMDriverInitListTwo” and </p>
<p>“EcuMDriverInitListThree” are executed.  When </p>
<p>EcuM_StartupTwo()</p>
<p> is left and the reset </p>
<p>reason which caused the startup needs no validation the ECU is in RUN state. </p>
<p><b>3.3 </b></p>
<p><b>Startup into wakeup validation state </b></p>
<p>The  startup  procedure  of  the  ECUM  provides  the  possibility  to  enter  wakeup  validation </p>
<p>state out of the startup state (refer to chapter 3.4) To use this feature some background </p>
<p>information is necessary which is described in the following chapters. </p>
<p> </p>
<p>At  startup  time  when </p>
<p>EcuM_Init()</p>
<p>  is  executed  the  ECUM  queries  the  MCU  module </p>
<p>which reset reason was responsible for that startup. These reset reasons are mapped to </p>
<p>wakeup  sources.  The  mapping  process  has  to  be  done  by  the  user  via  the  parameter </p>
<p>EcuMResetReason (6.2.2.4 Node &quot;Wakeup&quot;, GUI element “Mcu reset reason”). With this </p>
<p>mapping the ECUM has usually a valid reset reason or wakeup source respectively and </p>
<p>therefore the transitions will be from STARTUP to RUN. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>If a MCU reset reason is mapped to one of the preconfigured wakeup sources (refer to </p>
<p>5.2) the ECUM will transit always to RUN state if the user code, implemented in one of </p>
<p>the DriverInitLists, does not change this behavior. </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>20 / 117</p>
<p>This  behavior  is  probably  not  what  is  expected  for  ECU  layouts  which  use  a  CAN </p>
<p>transceiver with integrated power control and where wakeup events on the according bus </p>
<p>must be validated. In that cases the user must change the default behavior with use of the </p>
<p>API  functions </p>
<p>EcuM_GetValidatedWakeupEvents()</p>
<p>, </p>
<p>EcuM_ClearWakeupEvent()</p>
<p>, </p>
<p>EcuM_GetPendingWakeupEvents()</p>
<p>,  etc. by clearing the wakeup source from the reset </p>
<p>reason mapping if a pending wakeup event is on the hand.  </p>
<p><b>3.4 </b></p>
<p><b>States </b></p>
<p><b>Module State </b></p>
<p><b>Activities </b></p>
<p><b>Point in Time </b></p>
<p>ECUM_STATE_STARTUP_ONE </p>
<p>Initialization of driver modules </p>
<p>which need no OS. Drivers </p>
<p>could be initialized by </p>
<p>configuration (DriverInitOne) </p>
<p>Executed by </p>
<p>EcuM_Init()</p>
<p>. </p>
<p>ECUM_STATE_STARTUP_TWO </p>
<p>Initialization of driver or BSW </p>
<p>modules which need a running </p>
<p>OS </p>
<p>Executed by </p>
<p>EcuM_StartupTwo()</p>
<p>. </p>
<p>ECUM_STATE_APP_RUN </p>
<p>Check for RUN requests, ECUM </p>
<p>performs a self run request </p>
<p>when entering this state </p>
<p>Normal operation of the ECU. </p>
<p>ECUM_STATE_APP_POST_ RUN  Check for POST RUN requests </p>
<p>After RUN State, allows the SW-C to </p>
<p>do some preparation for the following </p>
<p>sleep mode. </p>
<p>ECUM_STATE_PREP_ </p>
<p>SHUTDOWN </p>
<p>Shutdown DEM. </p>
<p>All POST RUN request are released. </p>
<p>ECUM_STATE_GO_OFF_ONE </p>
<p>Write back non-volatile memory, </p>
<p>prepare system for the following </p>
<p>shutdown or reset </p>
<p> </p>
<p>ECUM_STATE_GO_SLEEP </p>
<p>write back non-volatile memory </p>
<p>contents </p>
<p> </p>
<p>ECUM_STATE_SLEEP </p>
<p>ECU is in physically sleep mode</p>
<p> </p>
<p>ECUM_STATE_WAKEUP_ONE </p>
<p>Set wakeup sources in normal </p>
<p>mode in callout </p>
<p>EcuM_AL_RestartDrivers()</p>
<p> </p>
<p>ECUM_STATE_WAKEUP_ </p>
<p>VALIDATION </p>
<p>Wait for the validation of a  </p>
<p>wakeup event </p>
<p>A wakeup event occurred. </p>
<p>ECUM_STATE_WAKEUP_ </p>
<p>WAKESLEEP </p>
<p>Result of </p>
<p>WAKEUP_REACTION</p>
<p> </p>
<p>state was none of TTII or RUN. </p>
<p> </p>
<p>ECUM_STATE_WAKEUP_ </p>
<p>REACTION </p>
<p>Computes the reaction of the </p>
<p>ECU after a valid wakeup (TTII,  </p>
<p>switch to RUN state) </p>
<p> </p>
<p>ECUM_STATE_TTII </p>
<p>Execute TTII protocol </p>
<p> </p>
<p>ECUM_STATE_WAKEUP_TWO </p>
<p>Initialize DEM after wakeup </p>
<p>phase. </p>
<p> </p>
<p>ECUM_STATE_GO_OFF_TWO </p>
<p>Activities implemented in API </p>
<p>EcuM_Shutdown()</p>
<p>. </p>
<p>Executed within the </p>
<p>ShutdownHook()</p>
<p>. </p>
<p>Table 3-3   States </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>21 / 117</p>
<p> </p>
<p>Figure 3-1 State diagram </p>
<p><b>3.5 </b></p>
<p><b>Main Functions </b></p>
<p><b>3.5.1 </b></p>
<p><b>Run Request Protocol </b></p>
<p>The  run  request  protocol  is  a  mechanism  where  applications  or  Software  Components </p>
<p>(SW-C) have to request RUN state explicitly. If the application has nothing to do anymore it </p>
<p>must  release  the  previous  requested  RUN  state.  If  no  other  SW-C  has  requested  RUN </p>
<p>state the ECU State Manger decides to initiate the shutdown process of the ECU. </p>
<p>If SW-C needs special preparation for one of the shutdown states (SLEEP, OFF, RESET) </p>
<p>the  SW-C  must  request  POST  RUN  state. This  is  the  same  mechanism  like  requesting </p>
<p>RUN state, which means that the POST RUN state has to be released after the job of the </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>22 / 117</p>
<p>application  is  finished.  It  is  very  important  for  SW-C’s  which  needs  POST  RUN  state </p>
<p>activities to request the POST RUN state before releasing the RUN request otherwise it is </p>
<p>possible that the application doesn't get the chance to execute its POST RUN activities.  </p>
<p>To request RUN or POST RUN state each SW-C must be a configured user of the ECU </p>
<p>State Manager. Therefore it is necessary to define one user for each SW-C to place run </p>
<p>requests. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>In production mode (EcuMDevErrorDetect equals to Off) the caller must assure </p>
<p>that the matching function pairs (requesting/releasing RUN) are called in the </p>
<p>expected order. I.e. RUN shall be requested only once per user until the RUN is </p>
<p>released and release RUN must also be executed once to release a previously </p>
<p>requested RUN state to prevent unexpected behavior of the ECUM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.5.2 </b></p>
<p><b>Time Triggered Increased Inoperation Protocol </b></p>
<p>This mechanism provides a way to enter a step by step decreasing power consumption </p>
<p>mode. To use the TTII feature the ECU has to fulfill the following prerequisite: </p>
<p></p>
<p> </p>
<p>The  ECU  must  support  several  sleep  modes  where  each  sleep  mode  presents  a </p>
<p>different level of low-power consumption. </p>
<p></p>
<p> </p>
<p>The  TTII  is  timer  based  therefore  the  available  timers  on  the  ECU  must  be  wakeup </p>
<p>capable. </p>
<p></p>
<p> </p>
<p>A timer has to be configured as wakeup source for TTII </p>
<p><b>3.5.3 </b></p>
<p><b>Wakeup Validation Protocol </b></p>
<p>The wakeup validation protocol provides a standardized way to recognize valid controller </p>
<p>wakeup after a sleep phase.  </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>When the ECUM transits to SLEEP state the service </p>
<p>NvM_WriteAll()</p>
<p> is executed </p>
<p>before the controller is set into sleep. If a subsequent wakeup validation fails and the </p>
<p>ECUM transits into SLEEP state again, the service </p>
<p>NvM_WriteAll()</p>
<p> will not be </p>
<p>executed again. </p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The validation of wakeup events is not done by the ECU State Manager. Only the </p>
<p>management of the validation is done by ECUM. This means that the </p>
<p>EcuM_SetWakeupEvent() </p>
<p>must be called when a wakeup event was detected. If the </p>
<p>wakeup event needs validation the module which performs this validation has to call </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>23 / 117</p>
<p>EcuM_ValidateWakeupEvent()</p>
<p> to indicate the ECU State Manager about a valid </p>
<p>wakeup event and to bring the ECU into RUN state. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p></p>
<p> </p>
<p>ECU is in sleep mode </p>
<p></p>
<p> </p>
<p>Wakeup source needs to be validated </p>
<p>1. </p>
<p>Wakeup </p>
<p>event </p>
<p>occurs, </p>
<p>the </p>
<p>driver </p>
<p>or </p>
<p>the </p>
<p>validating </p>
<p>module </p>
<p>calls </p>
<p>EcuM_CheckWakeup</p>
<p>(</p>
<p>wakeupsourceID</p>
<p>) </p>
<p>2. </p>
<p>In this callout the user/integrator of the module must implement a code sequence </p>
<p>which performs the correct action depending on the wakeup event ID. For example, </p>
<p>if  the  wake  event  ID  belongs  to  a  CAN  channel  the  code  must  execute  the </p>
<p>CanIf_CheckWakeup()</p>
<p> </p>
<p>API </p>
<p>function </p>
<p>which </p>
<p>should </p>
<p>call </p>
<p>the </p>
<p>EcuM_SetWakeupEvent()</p>
<p>. </p>
<p>3. </p>
<p>The ECUM checks whether this wakeup source needs validation =&gt; no validation </p>
<p>required, ECUM marks this wakeup event as valid </p>
<p>4.</p>
<p> </p>
<p>ECUM proceed to RUN state</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p></p>
<p> </p>
<p>ECU is in sleep mode </p>
<p></p>
<p> </p>
<p>Wakeup source needs validation </p>
<p>1. </p>
<p>Wakeup </p>
<p>event </p>
<p>occurs, </p>
<p>the </p>
<p>driver </p>
<p>or </p>
<p>the </p>
<p>validation </p>
<p>module </p>
<p>calls </p>
<p>EcuM_CheckWakeup(wakeupSourceID)</p>
<p> </p>
<p>2. </p>
<p>The  implementation  of  the  callout  must  call  the  appropriate  service  to  check  the </p>
<p>wakeup event by “asking” the corresponding driver. </p>
<p>3. </p>
<p>The  ECUM  checks  whether  this  wakeup  event  needs  validation  =&gt;  validation </p>
<p>required, EcuM starts timeout which limits the duration of wakeup validation (if the </p>
<p>timeout expires the EcuM sets the ECU in sleep mode again) </p>
<p>4. </p>
<p>The  ECUM  executes  the  callout  EcuM_StartWakeupSources(),  where  activities </p>
<p>must be implemented to start BSW modules for the wakeup validation, e.g. setting </p>
<p>the CAN transceiver in normal mode.  </p>
<p>5. </p>
<p>The ECUM executes the callout EcuM_CheckValidation(), where activities may be </p>
<p>implemented </p>
<p>to </p>
<p>perform </p>
<p>the </p>
<p>wakeup </p>
<p>validation, </p>
<p>e.g. </p>
<p>querying </p>
<p>the </p>
<p>CANIF </p>
<p>by </p>
<p>executing CanIf_CheckValidation(). </p>
<p>6. </p>
<p>If </p>
<p>the </p>
<p>validation </p>
<p>was </p>
<p>successful </p>
<p>the </p>
<p>validating </p>
<p>module </p>
<p>has </p>
<p>to </p>
<p>call </p>
<p>EcuM_ValidateWakeupEvent(wakeupSourceID)</p>
<p> </p>
<p>7. </p>
<p>If </p>
<p>the </p>
<p>validation </p>
<p>was </p>
<p>not </p>
<p>successful </p>
<p>the </p>
<p>ECUM </p>
<p>executes </p>
<p>the </p>
<p>callout </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>24 / 117</p>
<p>EcuM_StopWakeupSources(), where activities must be implemented to stop BSW </p>
<p>modules  which  where  necessary  for  the  wakeup  validation,  e.g.  setting  the  CAN </p>
<p>transceiver in sleep mode. </p>
<p>8. </p>
<p>The ECUM recognizes an valid wakeup </p>
<p>9.</p>
<p> </p>
<p>ECUM proceeds to RUN state</p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The wakeup validation protocol applies also for communication channels while the </p>
<p>ECUM is in RUN state. </p>
<p><b> </b></p>
<p> </p>
<p><b>3.6 </b></p>
<p><b>Error Handling </b></p>
<p><b>3.6.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>By </p>
<p>default, </p>
<p>development </p>
<p>errors </p>
<p>are </p>
<p>reported </p>
<p>to </p>
<p>the </p>
<p>DET </p>
<p>using </p>
<p>the </p>
<p>service </p>
<p>Det_ReportError()</p>
<p>as</p>
<p> </p>
<p>specified  in  [2],  if  development  error  reporting  is  enabled  (i.e. </p>
<p>pre-compile parameter </p>
<p>ECUM_DEV_ERROR_DETECT == STD_ON)</p>
<p>. </p>
<p>If  another  module  is  used  for  development  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Det_ReportError()</p>
<p>. </p>
<p>The reported ECUM ID can be found in chapter 2. </p>
<p>The  reported  service  IDs  identify  the  services  which  are  described  in  5.3. The  following </p>
<p>table presents the service IDs and the related services: </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x00 </p>
<p>EcuM_GetVersionInfo() </p>
<p>0x01 </p>
<p>EcuM_Init() </p>
<p>0x02 </p>
<p>EcuM_Shutdown()     </p>
<p>0x03 </p>
<p>EcuM_RequestRUN()    </p>
<p>0x04 </p>
<p>EcuM_ReleaseRUN() </p>
<p>0x05 </p>
<p>EcuM_KillAllRUNRequests() </p>
<p>0x06 </p>
<p>EcuM_SelectShutdownTarget() </p>
<p>0x07 </p>
<p>EcuM_GetState() </p>
<p>0x08 </p>
<p>EcuM_GetLastShutdownTarget()  </p>
<p>0x09 </p>
<p>EcuM_GetShutdownTarget()   </p>
<p>0x0A </p>
<p>EcuM_RequestPOST_RUN() </p>
<p>0x0B </p>
<p>EcuM_ReleasePOST_RUN() </p>
<p>0x0C </p>
<p>EcuM_SetWakeupEvent() </p>
<p>0x0D </p>
<p>EcuM_GetPendingWakeupEvents() </p>
<p>0x0E </p>
<p>EcuM_ComM_RequestRUN() </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>25 / 117</p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x0F </p>
<p>EcuM_SelectApplicationMode() </p>
<p>0x10 </p>
<p>EcuM_ComM_ReleaseRUN()  </p>
<p>0x11 </p>
<p>EcuM_GetApplicationMode() </p>
<p>0x12 </p>
<p>EcuM_SelectBootTarget() </p>
<p>0x13 </p>
<p>EcuM_GetBootTarget() </p>
<p>0x14 </p>
<p>EcuM_ValidateWakeupEvent() </p>
<p>0x15 </p>
<p>EcuM_GetValidatedWakeupEvents() </p>
<p>0x16 </p>
<p>EcuM_ClearWakeupEvent() </p>
<p>0x17 </p>
<p>EcuM_GetStatusOfWakeupSource() </p>
<p>0x18 </p>
<p>EcuM_MainFunction() </p>
<p>0x19 </p>
<p>EcuM_GetExpiredWakeupEvents() </p>
<p>0x1A </p>
<p>EcuM_StartupTwo() </p>
<p>0x1B </p>
<p>EcuM_ComM_HasRequestedRUN() </p>
<p>0x65 </p>
<p>EcuM_CB_NfyNvMJobEnd() </p>
<p>0xCA </p>
<p>EcuM_GeneratorCompatibilityError() </p>
<p>0xCB </p>
<p>EcuM_AL_DriverInitZero() </p>
<p>Table 3-4   Mapping of service IDs to services </p>
<p>The errors reported to DET are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>0x10 </p>
<p>ECUM_E_NOT_INITED </p>
<p>API service used in wrong context (without module </p>
<p>initialization) </p>
<p>0x11 </p>
<p>ECUM_E_SERVICE_DISABLED </p>
<p>Error code defined by AUTOSAR SWS (see [1]) but not used </p>
<p>in this implem</p>
<p>entation. </p>
<p>0x12 </p>
<p>ECUM_E_NULL_POINTER </p>
<p>API service called where pointer parameter is equal to </p>
<p>NULL_PTR</p>
<p> </p>
<p>0x13 </p>
<p>ECUM_E_INVALID_PAR </p>
<p>API service called with wrong parameter </p>
<p>0x14 </p>
<p>ECUM_E_MULTIPLE_RUN_ </p>
<p>REQUESTS </p>
<p>Multiple request of RUN or POST RUN state by the same </p>
<p>user ID </p>
<p>0x15 </p>
<p>ECUM_E_MISMATCHED_RUN_R</p>
<p>ELEASE </p>
<p>Run release with an user ID  without a matching request with </p>
<p>the same Id before </p>
<p>0x16 </p>
<p>ECUM_E_STATE_PAR_OUT_OF</p>
<p>_RANGE </p>
<p>API services EcuM_SelectShutdownTarget() or </p>
<p>EcuM_GetShutdownTarget()</p>
<p> called where parameter is </p>
<p>not in expected range  </p>
<p>0x17 </p>
<p>ECUM_E_UNKNOWN_ </p>
<p>WAKEUP_SOURCE </p>
<p>Wakeup source ID is not known by ECU State Manager </p>
<p>0x18 </p>
<p>ECUM_E_PARAM_VINFO </p>
<p>A null pointer has been given as parameter to the API service </p>
<p>EcuM_GetVersionInfo()</p>
<p>. </p>
<p>0x30 </p>
<p>ECUM_E_OS_NOT_STARTED_S</p>
<p>UCCESFULLY </p>
<p>This error will be reported if the invocation of </p>
<p>StartOS()</p>
<p> at </p>
<p>the end of </p>
<p>EcuM_Init()</p>
<p> was not successful (this means </p>
<p>EcuM_Init()</p>
<p> returns. </p>
<p>0x31 </p>
<p>ECUM_E_WRONG_ECUM_ </p>
<p>USAGE </p>
<p>This error will be reported if setting the ECU in OFF mode or </p>
<p>performing a reset does not lead in the expected behaviour.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>26 / 117</p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>0x32 </p>
<p>ECUM_E_WAKEUP_ </p>
<p>VALIDATION_PROT_ERROR </p>
<p>This error will be reported if </p>
<p>EcuM_ValidateWakeupEvent()</p>
<p> was invoked without </p>
<p>calling </p>
<p>EcuM_SetWakeupEvent()</p>
<p>. </p>
<p>0x33 </p>
<p>ECUM_E_OFF_STATE_ </p>
<p>EXPECTED </p>
<p>This error will be reported if the callout </p>
<p>EcuM_AL_SwitchOff()</p>
<p> does not switch off the ECU. This </p>
<p>means </p>
<p>EcuM_AL_SwitchOff()</p>
<p> returns. </p>
<p>0x34 </p>
<p>ECUM_E_MODULE_NOT_IN_RU</p>
<p>N_STATE </p>
<p>This error will be reported if </p>
<p>EcuM_SelectShutdownTarget()</p>
<p> is called while the </p>
<p>ECUM is not in RUN state. </p>
<p>0x35 </p>
<p>ECUM_E_GENERATOR_COMPAT</p>
<p>IBILITY </p>
<p>This error will be reported if the ECUM or another module </p>
<p>executes the EcuM_GeneratorCompatibilityError() callout. </p>
<p>This error code is additionally to AUTOSAR specification. </p>
<p>0x36 </p>
<p>ECUM_E_EXTENDED_LIB_VER</p>
<p>SION_CHECK_FAILED </p>
<p>This error will be reported if the delivery integrity check </p>
<p>function </p>
<p>VLibVersionCheck()</p>
<p> fails. This error code is not </p>
<p>specified by AUTOASR. It is an additional one used for error </p>
<p>reporting in library checks. </p>
<p>Table 3-5   Errors reported to DET </p>
<p> </p>
<p><b>3.6.1.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>AUTOSAR requires that API functions check the validity of their parameters. The checks in </p>
<p>Table  3-6  are  internal  parameter  checks  of  the  API  functions.  These  checks  are  for </p>
<p>development error reporting and can be en-/disabled separately. The configuration of en-</p>
<p>/disabling the checks is described in chapter 6.2.3. En-/disabling of single checks are an </p>
<p>addition to the AUTOSAR standard which requires to en-/disable the complete parameter </p>
<p>checking via the parameter </p>
<p>ECUM_DEV_ERROR_DETECT</p>
<p>. </p>
<p>The following table shows which parameter checks are performed on which services: </p>
<p><b>Check </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Service </b></p>
<p>ECUM_E_GENERATOR_COMPATIBILITY</p>
<p> </p>
<p>ECUM_E_NOT_INITED</p>
<p> </p>
<p>ECUM_E_PARAM_VINFO</p>
<p> </p>
<p>ECUM_E_STATE_PAR_OUT_OF_RANGE</p>
<p> </p>
<p>ECUM_E_NULL_POINTER</p>
<p> </p>
<p>ECUM_E_INVALID_PAR</p>
<p> </p>
<p>ECUM_E_UNKNOWN_ WAKEUP_SOURCE</p>
<p> </p>
<p>ECUM_E_MULTIPLE_RUN_ REQUESTS</p>
<p> </p>
<p>ECUM_E_MISMATCHED_RUN_RELEASE</p>
<p> </p>
<p>ECUM_E_OS_NOT_STARTED_SUCCESFULLY </p>
<p>ECUM_E_WRONG_ECUM_USAGE </p>
<p>ECUM_E_WAKEUP_VALIDATION_PROT_ERROR </p>
<p>ECUM_E_OFF_STATE_EXPECTED </p>
<p>ECUM_E_MODULE_NOT_IN_RUN_STATE </p>
<p>EcuM_Init </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_Shutdown </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>27 / 117</p>
<p><b>Check </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Service </b></p>
<p>ECUM_E_GENERATOR_COMPATIBILITY</p>
<p> </p>
<p>ECUM_E_NOT_INITED</p>
<p> </p>
<p>ECUM_E_PARAM_VINFO</p>
<p> </p>
<p>ECUM_E_STATE_PAR_OUT_OF_RANGE</p>
<p> </p>
<p>ECUM_E_NULL_POINTER</p>
<p> </p>
<p>ECUM_E_INVALID_PAR</p>
<p> </p>
<p>ECUM_E_UNKNOWN_ WAKEUP_SOURCE</p>
<p> </p>
<p>ECUM_E_MULTIPLE_RUN_ REQUESTS</p>
<p> </p>
<p>ECUM_E_MISMATCHED_RUN_RELEASE</p>
<p> </p>
<p>ECUM_E_OS_NOT_STARTED_SUCCESFULLY </p>
<p>ECUM_E_WRONG_ECUM_USAGE </p>
<p>ECUM_E_WAKEUP_VALIDATION_PROT_ERROR </p>
<p>ECUM_E_OFF_STATE_EXPECTED </p>
<p>ECUM_E_MODULE_NOT_IN_RUN_STATE </p>
<p>EcuM_GetVersionInfo </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_RequestRUN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_ReleaseRUN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_ComM_RequestRUN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_ComM_ReleaseRUN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_ComM_HasRequestedRUN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_RequestPOST_RUN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_ReleasePOST_RUN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_KillAllRUNRequests </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_SelectShutdownTarget </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetState </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetShutdownTarget </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetLastShutdownTarget </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_SetWakeupEvent </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetPendingWakeupEvents </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_ClearWakeupEvent </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_ValidateWakeupEvent </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetValidatedWakeupEvents </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetExpiredWakeupEvents </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetStatusOfWakeupSource </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_SelectApplicationMode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GetApplicationMode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_SelectBootTarget </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_MainFunction </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_StatupTwo </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_CB_NvyNvMJobEnd </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>EcuM_GeneratorCompatibility-</p>
<p>Error() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 3-6   Development Error detection: Assignment of checks to services </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>28 / 117</p>
<p><b>3.6.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>By  default,  production  code  related  errors  are  reported  to  the  DEM  using  the  service </p>
<p>Dem_ReportErrorStatus()</p>
<p> as specified in [3], if production error reporting is enabled </p>
<p>(i.e. pre-compile parameter </p>
<p>ECUM_PROD_ERROR_DETECT == STD_ON</p>
<p>). </p>
<p>If  another  module  is  used  for  production  code  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Dem_ReportErrorStatus()</p>
<p>. </p>
<p>The errors reported to DEM are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>ECUM_E_RAM_CHECK_FAILED </p>
<p>RAM Hash check after a sleep phase failed </p>
<p>ECUM_E_ALL_RUN_REQUESTS_KILLED </p>
<p>API service </p>
<p>EcuM_KillAllRUNRequest()</p>
<p> was </p>
<p>called </p>
<p>Table 3-7   Errors reported to DEM </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The production error codes listed above must be defined by the DEM and are included </p>
<p>into the ECU State Manager by the file </p>
<p>Dem.h</p>
<p> (by default). </p>
<p><b> </b></p>
<p><b>3.6.3 </b></p>
<p><b>Vector specific error reporting </b></p>
<p>The ECUM module provides an optional consistency check that can detect incompatible </p>
<p>configuration data. Eventual incompatibilities are detected during </p>
<p>EcuM_Init()</p>
<p> and are </p>
<p>reported </p>
<p>by </p>
<p>the </p>
<p>API </p>
<p>EcuM_GeneratorCompatibilityError()</p>
<p>. </p>
<p>After </p>
<p>calling </p>
<p>EcuM_GeneratorCompatibilityError()</p>
<p> the ECUM module will stop the initialization </p>
<p>causing the ECUM to remain uninitialized. </p>
<p> </p>
<p>The following check is provided: </p>
<p></p>
<p> </p>
<p>Generator  versions  are  compatible  to  the  implementation    and  compatible    to  the </p>
<p>versions  of previous configuration phases. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>29 / 117</p>
<p><b>4 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR ECUM into </p>
<p>an application environment of an ECU. </p>
<p><b>4.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the ECUM contains the files which are described in the chapter’s 4.1.1 and </p>
<p>4.1.2: </p>
<p><b>4.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>EcuM.h </p>
<p>Declares the interface of the MICROSAR module ECUM. </p>
<p>EcuM.c </p>
<p>Contains the implementation of the interfaces of the ECUM. </p>
<p>EcuM.lib </p>
<p>This is the library file of the ECUM (optional). </p>
<p>Table 4-1   Static files </p>
<p><b>4.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The dynamic files are generated by the configuration tool. </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>EcuM Cfg.h </p>
<p>Contains the static configuration part of this module. </p>
<p>EcuM_Callout_Stubs.c </p>
<p>Template for the callout code which has to be filled by the </p>
<p>integrator. </p>
<p>EcuM_Generated_Types.</p>
<p>h </p>
<p>Contains all provided types of the ECUM. </p>
<p>EcuM_Cbk.h </p>
<p>Contains the prototypes of the provided callback and callout </p>
<p>functions. </p>
<p>EcuM_PBcfg.c </p>
<p>Contains the post build configurations. </p>
<p>EcuM_PrivateCfg.h </p>
<p>Contains configuration data which is only relevant for the ECUM </p>
<p>implementation. This file must be only included in the ECUM </p>
<p>implementation files. </p>
<p>Table 4-2   Generated files </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>30 / 117</p>
<p><b>4.2 </b></p>
<p><b>Include Structure </b></p>
<p> </p>
<p>Figure 4-1 Include structure </p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p></p>
<p> </p>
<p>A BSW module which uses services for wakeup event reporting shall include </p>
<p>EcuM_Cbk.h</p>
<p> </p>
<p></p>
<p> </p>
<p>Other BSW module shall include </p>
<p>EcuM.h</p>
<p> </p>
<p></p>
<p> </p>
<p>Software Components shall include the generated file by Rte to use the services of the </p>
<p>ECUM (e.g. </p>
<p>Rte_EcuM.h</p>
<p>) </p>
<p><b> </b></p>
<p> </p>
<p><b>4.3 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions defined for the ECUM and illustrate their assignment among each other. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>31 / 117</p>
<p><b>Compiler Abstraction</b></p>
<p><b>Definitions</b></p>
<p><b> </b></p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>ECUM_CODE</p>
<p> </p>
<p>ECUM_API_CODE </p>
<p>ECUM_CODE_BOOT_TARGET </p>
<p>ECUM_APPL_DATA </p>
<p>ECUM_APPL_CONFIG </p>
<p>ECUM_CONST </p>
<p>ECUM_VAR_BOOT </p>
<p>ECUM_VAR_NOINIT </p>
<p>ECUM_VAR </p>
<p>ECUM_START_SEC_CODE </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_CODE_SET_BOOT_TARGET </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_CODE_GET_BOOT_TARGET </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_VAR_NOINIT_8BIT </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_VAR_NOINIT_16BIT </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_VAR_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_CONST_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_CONST_PBCFG </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ECUM_START_SEC_CONST_8BIT </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Application buffer memory section - access from ECUM </p>
<p>into application memory </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 4-3   Compiler abstraction and memory mapping </p>
<p><b>4.4 </b></p>
<p><b>Dependencies on SW modules </b></p>
<p><b>4.4.1 </b></p>
<p><b>AUTOSAR OS </b></p>
<p>This module depends on the AUTOSAR OS. It starts and performs the shutdown of OS. </p>
<p>The  ECUM  needs  a  valid  reference  within  the  EcuC  file  to  the  configured  application </p>
<p>modes. </p>
<p>The usage cannot be switched off. </p>
<p><b>4.4.2 </b></p>
<p><b>MCU </b></p>
<p>This module depends on the MCU driver. The ECUM uses the mode setting functionality </p>
<p>and the service to perform an ECU reset. If a sleep mode is configured within the ECUM a </p>
<p>valid configuration reference to MCU mode settings must exist within the EcuC. </p>
<p>This usage cannot be switched off. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>32 / 117</p>
<p><b>4.4.3 </b></p>
<p><b>DEM </b></p>
<p>The  ECUM  depends  on  the  DEM.  The  ECUM  performs  the  initialization  and  reports </p>
<p>production errors to the DEM. </p>
<p>Its initialization can be enabled or disabled by the switch “Use DEM”. The error reporting </p>
<p>can </p>
<p>be </p>
<p>en-/disabled </p>
<p>by </p>
<p>switching </p>
<p>the </p>
<p>configuration </p>
<p>switch </p>
<p>“Enable </p>
<p>Production </p>
<p>Error </p>
<p>Reporting” on. </p>
<p><b>4.4.4 </b></p>
<p><b>DET </b></p>
<p>The  ECUM  depends  on  the  DET.  The  ECUM  performs  the  initialization  and  reports </p>
<p>development errors for diagnostic purposes. </p>
<p>Its  initialization  can  be  enabled  or  disabled  by  the  configuration  switch  “Use  DET”.  The </p>
<p>error </p>
<p>reporting </p>
<p>can </p>
<p>be </p>
<p>en-/disabled </p>
<p>by </p>
<p>switching </p>
<p>the </p>
<p>configuration </p>
<p>switch </p>
<p>“Enable </p>
<p>Development Error Detection”. </p>
<p><b>4.4.5 </b></p>
<p><b>WDGM </b></p>
<p>This module depends on the WDGM. The ECUM performs the initialization and via callouts </p>
<p>it might be necessary to interact with the WDGM while entering sleep mode. Furthermore </p>
<p>the ECUM sets the mode of the WDGM in different ECU states. </p>
<p>Its usage can be enabled or disabled by the switch “Use Watchdog Manager”. </p>
<p><b>4.4.6 </b></p>
<p><b>COMM </b></p>
<p>This module depends on the COMM. The ECUM performs the initialization and manages </p>
<p>the wakeup of communication channels. Additional it indicates to this module when RUN </p>
<p>state is reached. </p>
<p>Its usage can be en-/disabled by the switch “Use ComM”. </p>
<p><b>4.4.7 </b></p>
<p><b>NVM </b></p>
<p>The  module  depends  on  the  NVM.  The  ECUM  performs  the  initialization  and  calls </p>
<p>NvM_ReadAll()</p>
<p>  and </p>
<p>NvM_WriteAll()</p>
<p>  in  the  start  up  respectively  in  the  shutdown </p>
<p>phase. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Note that the </p>
<p>NvM_ReadAll()</p>
<p>, </p>
<p>NvM_Init()</p>
<p> and the triggering of the memory </p>
<p>stack  has  to  be  implemented  manually  in  one  of  the  driver  init  lists.  Refer  to </p>
<p>chapter 4.8.2 for an example of how to initialize the memory stack. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Its usage can be enabled or disabled by the switch “Use NVRAM Manger”.  This switch </p>
<p>disables the execution of </p>
<p>NvM_WriteAll()</p>
<p> by ECUM module but does not prevent the </p>
<p>user to add module initialization in one of the driver init list. </p>
<p>If </p>
<p>NvM_WriteAll()</p>
<p> </p>
<p>is </p>
<p>enabled, </p>
<p>the </p>
<p>user </p>
<p>is </p>
<p>able </p>
<p>to </p>
<p>configure </p>
<p>a </p>
<p>timeout </p>
<p>for </p>
<p>NvM_CancelWriteAll()</p>
<p>. This timeout parameter specifies the time which EcuM waits </p>
<p>for before it calls the </p>
<p>NvM_KillWriteAll()</p>
<p> function (if available) or switches into ECU </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>33 / 117</p>
<p>RUN  state.  With  an  adequate  value  for  this  timeout  parameter,  the  synchronization </p>
<p>between NvM and EcuM is guaranteed. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p><b>NvM_CancelWriteAll Usage: </b></p>
<p><b> </b></p>
<p>Note  that  a  wait  mechanism  until  NvM  is  finished  has  to  be  implemented </p>
<p>manually in case </p>
<p>NvM_CancelWriteAll()</p>
<p> is called.  </p>
<p>This caution is only valid for <b>EcuMS.c SW version number </b>smaller or equal to </p>
<p><b>05.03.00</b>. </p>
<p>In  case </p>
<p>NvM_CancelWriteAll()</p>
<p>  is  called  by  EcuM  because  of  incoming </p>
<p>wakeup event during </p>
<p>NvM_WriteAll </p>
<p>processing, the NvM component do not </p>
<p>have to cancel destructive the currently running </p>
<p>NvM_WriteAll </p>
<p>job. Thus the </p>
<p>cancel mechanism can take some time. </p>
<p>The EcuM does not wait until the NvM finishes, instead it transits immediately </p>
<p>into ECU RUN state. </p>
<p>To </p>
<p>avoid </p>
<p>this, </p>
<p>a </p>
<p>wait </p>
<p>mechanism </p>
<p>for </p>
<p>NvM </p>
<p>shall </p>
<p>be </p>
<p>implemented </p>
<p>in </p>
<p>EcuM_DriverRestartList().</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.4.8 </b></p>
<p><b>RTE </b></p>
<p>The module depends on the RTE.  </p>
<p>The ECUM performs the start and stop of the RTE. Its usage can be enabled or disabled </p>
<p>by the switch “Use Rte”. </p>
<p>The ECUM ensures the synchronization to RTE at each important mode switch. </p>
<p>In  case  the  ECUM  leaves  the  RUN  state  or  enters  SLEEP/OFF  state  it  waits  for  the </p>
<p>feedback from RTE before the mode switch is performed. This mechanism is activated by </p>
<p>enabling the mode switch notification and the usage of acknowledgement mechanism to </p>
<p>RTE. </p>
<p><b>4.4.9 </b></p>
<p><b>SCHM </b></p>
<p>The module depends on the SCHM. The ECUM performs the initialization of that module. </p>
<p>Its usage can be enabled or disabled by the switch “Use SchM”. </p>
<p><b>4.4.10 </b></p>
<p><b>Other BSW Modules </b></p>
<p>The </p>
<p>module </p>
<p>depends </p>
<p>on </p>
<p>other </p>
<p>BSW </p>
<p>modules. </p>
<p>It </p>
<p>performs </p>
<p>their </p>
<p>initialization. </p>
<p>The </p>
<p>configuration  which  modules  should  be  initialized  could  be  done  over  the  configuration </p>
<p>Node  “EcuMDriverInitListOne”,    “EcuMDriverInitListTwo”,  “EcuMDriverInitListThree”  and </p>
<p>“EcuMDriverRestartList”. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>34 / 117</p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The  initialization  of  the  modules  described  above  must  be  configured  by  the </p>
<p>integrator in one of the DriverInitLists.  </p>
<p><b> </b></p>
<p><b>4.5 </b></p>
<p><b>Successive Adding of Modules </b></p>
<p>The MICROSAR ECUM allows the successive adding of  modules during the integration </p>
<p>phase.  This  means,  that  the  integrator  has  the  possibility  to  start  integration  with  a </p>
<p>minimum subset of modules, e.g. ECUM, MCU and OS and if the used configuration is </p>
<p>working, to add other modules like GPT, DEM, FIM etc.. </p>
<p><b>4.6 </b></p>
<p><b>Callout execution sequences </b></p>
<p>This chapter describes the execution order of callouts and important function. This may be </p>
<p>useful while integrating the software stack. </p>
<p><b>STARTUP – RUN </b></p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverInitZero() </p>
<p></p>
<p> </p>
<p>EcuM_DeterminePbConfiguration() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverInitOne() </p>
<p></p>
<p> </p>
<p>StartOS() </p>
<p></p>
<p> </p>
<p>SchM_Init() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverInitTwo() </p>
<p></p>
<p> </p>
<p>Rte_Start() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverInitThree()</p>
<p> </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(</p>
<p>RTE_MODE_EcuM_Mode_RUN) </p>
<p></p>
<p> </p>
<p>EcuM_OnEnterRun()</p>
<p> </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Run mode) </p>
<p></p>
<p> </p>
<p>ComM_RunModeIndication() </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>35 / 117</p>
<p><b>RUN – RESET </b></p>
<p></p>
<p> </p>
<p>EcuM_OnExitRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Post Run mode) </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_POST_RUN) </p>
<p></p>
<p> </p>
<p>EcuM_OnExitPostRun() </p>
<p></p>
<p> </p>
<p>EcuM_OnPrepShutdown() </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_SHUTDOWN) </p>
<p></p>
<p> </p>
<p>EcuM_OnGoOffOne() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Shutdown mode) </p>
<p></p>
<p> </p>
<p>System waits for finishing the </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>Rte_Stop() </p>
<p></p>
<p> </p>
<p>ComM_DeInit() </p>
<p></p>
<p> </p>
<p>ShutdownOS() </p>
<p></p>
<p> </p>
<p>EcuM_OnGoOffTwo() </p>
<p></p>
<p> </p>
<p>Mcu_PerformReset()</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>36 / 117</p>
<p><b>RUN – OFF </b></p>
<p></p>
<p> </p>
<p>EcuM_OnExitRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Post Run mode) </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_POST_RUN) </p>
<p></p>
<p> </p>
<p>EcuM_EnableWakeupSources() </p>
<p></p>
<p> </p>
<p>EcuM_OnExitPostRun() </p>
<p></p>
<p> </p>
<p>EcuM_OnPrepShutdown() </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_SHUTDOWN) </p>
<p></p>
<p> </p>
<p>EcuM_OnGoOffOne() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Shutdown mode) </p>
<p></p>
<p> </p>
<p>System waits for finishing the </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>Rte_Stop() </p>
<p></p>
<p> </p>
<p>ComM_DeInit() </p>
<p></p>
<p> </p>
<p>ShutdownOS() </p>
<p></p>
<p> </p>
<p>EcuM_OnGoOffTwo() </p>
<p></p>
<p> </p>
<p>EcuM_AL_SwitchOff()</p>
<p> </p>
<p></p>
<p> </p>
<p>Mcu_PerformReset()</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>37 / 117</p>
<p><b>RUN – SLEEP – RUN   </b></p>
<p></p>
<p> </p>
<p>EcuM_OnExitRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Post Run mode) </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_POST_RUN) </p>
<p></p>
<p> </p>
<p>EcuM_EnableWakeupSources() </p>
<p></p>
<p> </p>
<p>EcuM_OnExitPostRun() </p>
<p></p>
<p> </p>
<p>EcuM_OnPrepShutdown() </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_SLEEP) </p>
<p></p>
<p> </p>
<p>EcuM_OnGoSleep() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Shutdown mode) </p>
<p></p>
<p> </p>
<p>System waits for finishing the </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>GetResource(RES_SCHEDULER) </p>
<p></p>
<p> </p>
<p>EcuM_GenerateRamHash()</p>
<p> </p>
<p></p>
<p> </p>
<p>Mcu_SetMode() </p>
<p></p>
<p> </p>
<p>System is in sleep mode </p>
<p></p>
<p> </p>
<p>Occurrence of a valid wakeup event </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Wakeup mode) </p>
<p></p>
<p> </p>
<p>EcuM_CheckRamHash() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverRestart() </p>
<p></p>
<p> </p>
<p>ReleaseResource(RES_SCHEDULER) </p>
<p></p>
<p> </p>
<p>EcuM_OnWakeupReaction() </p>
<p></p>
<p> </p>
<p>EcuM_DisableWakeupSources() </p>
<p></p>
<p> </p>
<p>Dem_Init() </p>
<p></p>
<p> </p>
<p>EcuM_OnEnterRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Run mode) </p>
<p></p>
<p> </p>
<p>ComM_RunModeIndication() </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>38 / 117</p>
<p><b>RUN – SLEEP – WAKEUP VALIDATION – RUN </b></p>
<p></p>
<p> </p>
<p>EcuM_OnExitRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Post Run mode) </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_POST_RUN) </p>
<p></p>
<p> </p>
<p>EcuM_EnableWakeupSources() </p>
<p></p>
<p> </p>
<p>EcuM_OnExitPostRun() </p>
<p></p>
<p> </p>
<p>EcuM_OnPrepShutdown() </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_SLEEP) </p>
<p></p>
<p> </p>
<p>EcuM_OnGoSleep() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Shutdown mode) </p>
<p></p>
<p> </p>
<p>System waits for finishing the </p>
<p>NvM_WriteAll()</p>
<p> </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Sleep mode) </p>
<p></p>
<p> </p>
<p>GetResource(RES_SCHEDULER) </p>
<p></p>
<p> </p>
<p>EcuM_GenerateRamHash() </p>
<p></p>
<p> </p>
<p>Mcu_SetMode() </p>
<p></p>
<p> </p>
<p>System is in sleep mode </p>
<p></p>
<p> </p>
<p>Occurrence of a wakeup event </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Wakeup mode) </p>
<p></p>
<p> </p>
<p>EcuM_CheckRamHash() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverRestart() </p>
<p></p>
<p> </p>
<p>ReleaseResource(RES_SCHEDULER) </p>
<p></p>
<p> </p>
<p>Wakeup detected as valid </p>
<p></p>
<p> </p>
<p>EcuM_OnWakeupReaction() </p>
<p></p>
<p> </p>
<p>EcuM_DisableWakeupSources() </p>
<p></p>
<p> </p>
<p>Dem_Init() </p>
<p></p>
<p> </p>
<p>EcuM_OnEnterRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode() </p>
<p>(Run mode) </p>
<p></p>
<p> </p>
<p>ComM_RunModeIndication() </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>39 / 117</p>
<p><b>RUN – SLEEP – WAKEUP VALIDATION – SLEEP  </b></p>
<p></p>
<p> </p>
<p>EcuM_OnExitRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Post Run mode) </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_POST_RUN) </p>
<p></p>
<p> </p>
<p>EcuM_EnableWakeupSources() </p>
<p></p>
<p> </p>
<p>EcuM_OnExitPostRun() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Post Run mode) </p>
<p></p>
<p> </p>
<p>EcuM_OnPrepShutdown() </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_SLEEP) </p>
<p></p>
<p> </p>
<p>EcuM_OnGoSleep() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Shutdown mode) </p>
<p></p>
<p> </p>
<p>System waits for finishing the </p>
<p>NvM_WriteAll()</p>
<p> </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Sleep mode) </p>
<p></p>
<p> </p>
<p>GetResource(RES_SCHEDULER)</p>
<p> </p>
<p></p>
<p> </p>
<p>EcuM_GenerateRamHash()</p>
<p> </p>
<p></p>
<p> </p>
<p>Mcu_SetMode() </p>
<p>(Sleep mode)</p>
<p> </p>
<p></p>
<p> </p>
<p>System is in sleep mode </p>
<p></p>
<p> </p>
<p>Occurrence of a wakeup event </p>
<p></p>
<p> </p>
<p>WdgM_SetMode()</p>
<p> (Wakeup mode) </p>
<p></p>
<p> </p>
<p>EcuM_CheckRamHash() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverRestart() </p>
<p></p>
<p> </p>
<p>ReleaseResource(RES_SCHEDULER) </p>
<p></p>
<p> </p>
<p>Wakeup detected as not valid </p>
<p></p>
<p> </p>
<p>EcuM_OnWakeupReaction() </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE</p>
<p>_MODE_EcuM_Mode_WAKE_SLEEP</p>
<p>) </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode(RTE_MODE_EcuM_Mode_SLEEP) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>40 / 117</p>
<p></p>
<p> </p>
<p>EcuM_OnGoSleep() </p>
<p></p>
<p> </p>
<p>GetResource(RES_SCHEDULER) </p>
<p></p>
<p> </p>
<p>EcuM_GenerateRamHash() </p>
<p></p>
<p> </p>
<p>Mcu_SetMode() </p>
<p>(Sleep mode)</p>
<p> </p>
<p> </p>
<p><b>4.7 </b></p>
<p><b> Critical code sections </b></p>
<p> </p>
<p>The ECUM has the following defined critical code sections: </p>
<p></p>
<p> </p>
<p>ECUM_EXCLUSIVE_AREA_0:  Must  lock  task  interrupts  and  interrupt  sources  during </p>
<p>normal ECU modes like RUN and POST_RUN. </p>
<p></p>
<p> </p>
<p>ECUM_EXCLUSIVE_AREA_1:  Must  lock  SLEEP  mode  Interrupts.  Special  interrupt </p>
<p>control  functionality  has  to  be  implemented  for  ECU  SLEEP  mode.  Therefore  the </p>
<p>interrupt function set shall be used within the DaVinci Configuration tool to disable and </p>
<p>enable these interrupts. The reason why this second exclusive are is defined is that, if </p>
<p>the ECUM switches into SLEEP state not all interrupts are allowed to get disabled and </p>
<p>the instructions to do this are HW dependent.  </p>
<p> </p>
<p><b>4.7.1 </b></p>
<p><b>Wakeup Interrupt Source Handling – General Description </b></p>
<p> </p>
<p>Wakeup interrupt sources are disabled and enabled. </p>
<p>Before </p>
<p>Mcu_SetMode</p>
<p>  is  called,  because  the  ECU  will  change  in  SLEEP  mode,  the </p>
<p>EcuM  checks  whether  pending  wakeups  are  existent.  The  call  of  Mcu  API  and  this </p>
<p>check shall be done while interrupts are locked. </p>
<p>Before  it  is  checked  whether  pending  wakeups  are  existent  the  wakeup  interrupt </p>
<p>sources shall get disabled in order that no wakeup interrupts are detected, until ECU </p>
<p>goes into sleep mode.  </p>
<p>It  must  also  be  assured  that  in  case  a  wakeup  event  is  detected  as  PENDING  the </p>
<p>wakeup interrupt sources are enabled again. </p>
<p>In case hardware specific instructions  shall be used to disable or enable the wakeup </p>
<p>interrupt </p>
<p>sources </p>
<p>the </p>
<p>following </p>
<p>procedure </p>
<p>can </p>
<p>be </p>
<p>used. </p>
<p>In </p>
<p>other </p>
<p>case </p>
<p>the </p>
<p>SchM </p>
<p>functionality can be used for example. </p>
<p><i>To  be  able  to  use  hardware  specific  source  code,  an  ‘interrupt  function  set’  shall  be </i></p>
<p><i>defined </i></p>
<p><i>as </i></p>
<p><i>“Default </i></p>
<p><i>Interrupt </i></p>
<p><i>Settings” </i></p>
<p><i>in </i></p>
<p><i>configuration </i></p>
<p><i>tool, </i></p>
<p><i>for </i></p>
<p><i>example </i></p>
<p>InterruptFunctionSetEcuMWkupIsr</p>
<p><i>. </i></p>
<p><i>For </i></p>
<p><i>this </i></p>
<p><i>‘function </i></p>
<p><i>set’ </i></p>
<p><i>the </i></p>
<p><i>suspend </i></p>
<p><i>and </i></p>
<p><i>restore  functions  must  be  defined,  for  example </i></p>
<p>SuspendEcuMWkupInterrupts()</p>
<p><i> </i></p>
<p><i>and </i></p>
<p>ResumeEcuMWkpInterrupts().</p>
<p><i> </i></p>
<p><i>The </i></p>
<p><i>corresponding </i></p>
<p><i>header </i></p>
<p><i>file </i></p>
<p><i>must </i></p>
<p><i>get </i></p>
<p><i>inserted into “Include File” list. </i></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>41 / 117</p>
<p>Within the EcuM configuration this defined interrupt function set shall be chosen in the </p>
<p>drop down list “Sleep mode ISR handling” within the configuration tool.  </p>
<p> </p>
<p><b>4.7.2 </b></p>
<p><b>Interrupt Source Handling – Cautions and further Information </b></p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p></p>
<p> </p>
<p>OS functionalities must not be used for handling ECUM_EXCLUSIVE_AREA_1. </p>
<p></p>
<p> </p>
<p>In  case  the  ISRs  are  configured  to  category  1,  it  is  not  allowed  to  call  OS  API </p>
<p>services, </p>
<p>except </p>
<p>functions </p>
<p>DisableAlInterrupts</p>
<p>, </p>
<p>EnableAllInterrupts</p>
<p>, </p>
<p>SuspendAllInterrupts</p>
<p> and </p>
<p>ResumeAllInterrupts</p>
<p>.</p>
<p> </p>
<p></p>
<p> </p>
<p>If ‘interrupt function set’ is used the corresponding resume and restore function shall </p>
<p>be filled otherwise the system will not running.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The critical section handling apply the following parameter: </p>
<p>6.2.3 EcuMIrqHandling (Critical section handling)</p>
<p> for ECUM_EXCLUSIVE_AREA_0 – </p>
<p>SchM dependent </p>
<p>6.2.3 EcuMWkupIsrHandling (Sleep mode ISR handling) is used for </p>
<p>ECUM_EXCLUSIVE_AREA_1 – SchM independent </p>
<p><b> </b></p>
<p> </p>
<p><b>4.8 </b></p>
<p><b>AUTOSAR stack initialization </b></p>
<p><b>4.8.1 </b></p>
<p><b>Configuration set selection </b></p>
<p>The  AUTOSAR  compatible  mechanism  to  select  the  configuration  set  which  should  be </p>
<p>used for module initialization considers the following aspects: </p>
<p></p>
<p> </p>
<p>Most  of  the  AUTOSAR  modules  provide  a  configuration  reference  to  the  provided </p>
<p>configuration sets  </p>
<p></p>
<p> </p>
<p>Some  modules  are  initialized  without  a  configuration  pointer  (Init-function  signature </p>
<p>&lt;MSN&gt;_Init(void)</p>
<p>) </p>
<p></p>
<p> </p>
<p>Some modules have a Init-function signature with configuration pointer but make no use </p>
<p>of it and needs to be initialized with a NULL_PTR </p>
<p> </p>
<p>To use this mechanism within ECUM, the user must distinguish between the aspects given </p>
<p>above and make the correct configuration decision (see Ch. 6.2.2.1.11) </p>
<p></p>
<p> </p>
<p>Module uses a configuration pointer for its initialization: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>42 / 117</p>
<p></p>
<p> </p>
<p>Select the MSN to be initialized (e.g. Can) </p>
<p></p>
<p> </p>
<p>Select the corresponding configuration set (e.g. CanConfigSet) </p>
<p></p>
<p> </p>
<p>Select in one of the DriverInitList the MSN and the Init Function to be used (e.g. </p>
<p>Can_Init()</p>
<p> </p>
<p></p>
<p> </p>
<p>Result: The ECUM generates: “</p>
<p>Can_Init(&amp;CanConfigSet);</p>
<p>” in the specified </p>
<p>DriverInitList. </p>
<p></p>
<p> </p>
<p>Module has a void Init-function signature </p>
<p></p>
<p> </p>
<p>The configuration items described in Ch. 6.2.2.1.11 must not be used </p>
<p></p>
<p> </p>
<p>Select in one of the DriverInitList the MSN and the Init Function to be used (e.g. </p>
<p>ComM_Init()</p>
<p> </p>
<p></p>
<p> </p>
<p>Result: The ECUM generates: </p>
<p>ComM_Init();</p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Module needs to be initialized with NULL_PTR </p>
<p></p>
<p> </p>
<p>The configuration items described in Ch. 6.2.2.1.11 must not be used </p>
<p></p>
<p> </p>
<p>Select in one of the DriverInitList the MSN and the Init Function to be used (e.g. </p>
<p>Mcu_Init()</p>
<p>) </p>
<p></p>
<p> </p>
<p>Result: The ECUM generates: “</p>
<p>Mcu_Init(NULL_PTR);</p>
<p>” in the specified </p>
<p>DriverInitList </p>
<p> </p>
<p>Additional  to  the  AUTOSAR  mechanism  the  MICROSAR  implementation  provides  the </p>
<p>possibility to insert any kind of function into a DriverInitList by using the “Code-Segment” in </p>
<p>the driver init lists: </p>
<p></p>
<p> </p>
<p>The function </p>
<p>Mcu_InitClock()</p>
<p> must be executed in one of the DriverInitLists: </p>
<p></p>
<p> </p>
<p>Select or type “Code” into “Module ID” </p>
<p></p>
<p> </p>
<p>The code which should be executed must be inserted into </p>
<p>“EcuMAdditionalInitCode” parameter, e.g. </p>
<p>Mcu_InitClock(0);</p>
<p> </p>
<p></p>
<p> </p>
<p>Result: The ECUM generates: “</p>
<p>Mcu_InitClock(0);”</p>
<p>  in the specified </p>
<p>DriverInitList. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Generally, every function which does not match to the standard AUTOSAR naming and </p>
<p>behavior must be initialized with use of a “Code-Segement”. For example: </p>
<p></p>
<p> </p>
<p>Fee_30_Inst2_Init() </p>
<p></p>
<p> </p>
<p>Fls_30_ADBus01_Init() </p>
<p></p>
<p> </p>
<p>CanTrcv_30_Tja1041_Init()</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>43 / 117</p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.8.2 </b></p>
<p><b>Initialization order </b></p>
<p>Depending on the modules which are used within the BSW stack the following example </p>
<p>gives an overview of a possible initialization order. </p>
<p><b>Initialization Group </b></p>
<p><b>Comment </b></p>
<p><b>DriverInitListZero </b></p>
<p> </p>
<p>Det_Init() </p>
<p> </p>
<p><b>DriverInitListOne </b></p>
<p><b> </b></p>
<p>Mcu_Init() </p>
<p> </p>
<p>Dem_PreInit() </p>
<p> </p>
<p>Mcu_InitClock(0); </p>
<p>while(MCU_PLL_LOCKED != Mcu_GetPllStatus()); </p>
<p>Mcu_DistributePllClock(); </p>
<p>Sequence to initialize PLL clock </p>
<p>Port_Init() </p>
<p> </p>
<p><b>DriverInitListTwo </b></p>
<p> </p>
<p>Adc, Pwm, Icu, Spi, etc. </p>
<p>MCAL driver initialization </p>
<p>Eep </p>
<p>Fls </p>
<p>Ea </p>
<p>Fee </p>
<p>NvM_Init() </p>
<p>Memory stack initialization </p>
<p>NvM_ReadAll() </p>
<p>{ </p>
<p>  NvM_RequestResultType blockStatus; </p>
<p>  do </p>
<p>  { </p>
<p>    NvM_MainFunction(); </p>
<p>    Ea_MainFunction(); </p>
<p>    Fee_MainFunction(); </p>
<p>    Eep_MainFunction(); </p>
<p>    Fls_MainFunction(); </p>
<p>    NvM_GetErrorStatus(MultiBlockID,&amp;blockStatus); </p>
<p>  }  while (blockStatus == NVM_REQ_PENDING); </p>
<p>} </p>
<p>Read all sequence </p>
<p>CanTrcv </p>
<p>CanDrv </p>
<p>CanIf </p>
<p>CAN stack initialization </p>
<p>LinTrcv </p>
<p>LinDrv </p>
<p>LinIf </p>
<p>LIN stack initialization </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>44 / 117</p>
<p>LinIf_GotoSleepInternal </p>
<p>FrTrcv </p>
<p>FrDrv </p>
<p>FrIf </p>
<p>Flexray stack initialization </p>
<p>CanSM </p>
<p>LinSM </p>
<p>FrSM </p>
<p>Bus State Manager initialization </p>
<p>Com </p>
<p>NmIf </p>
<p>NmCan </p>
<p>NmFr </p>
<p>ComM </p>
<p> </p>
<p>DCM </p>
<p> </p>
<p>DEM </p>
<p>Could also be initialized in DriverInitListThree </p>
<p><b>DriverInitListThree </b></p>
<p> </p>
<p>DEM </p>
<p>Could also be initialized in DriverInitListTwo </p>
<p>Table 4-4   initialization order </p>
<p><b>4.9 </b></p>
<p><b>Handling of wakeup events after ShutdownOS() </b></p>
<p>When </p>
<p>shutdown </p>
<p>target </p>
<p>ECUM_STATE_OFF </p>
<p>is </p>
<p>selected </p>
<p>the </p>
<p>ECUM </p>
<p>waits </p>
<p>in </p>
<p>state </p>
<p>ECUM_STATE_GO_OFF_ONE  until  the  NVM  has  finished  with  writing  NVRAM  data.  In </p>
<p>this state the ECUM will react on occurring wakeup events. After the data is written the </p>
<p>function  ShutdownOS()  will  be  executed  and  EcuM_AL_SwitchOff()  will  switch  off  the </p>
<p>ECU, in this time space between wakeup events may occur and a ECU reset should be </p>
<p>the desired reaction in most cases. The integrator is responsible to implement the desired </p>
<p>behavior into EcuM_AL_SwitchOff(). </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The integrator is responsible to implement the wakeup event reaction handling after </p>
<p>ECUM_STATE_GO_OFF_ONE is left. </p>
<p><b> </b></p>
<p><b>4.10  Wakeup event handling and Wakeup Validation </b></p>
<p>The  handling  of  wakeup  sources  and  wakeup  validation  has  to  be  configured  and </p>
<p>implemented  specific  for  every  ECU. The  following  list  provides  a  short  overview  which </p>
<p>callouts are affected:  </p>
<p></p>
<p> </p>
<p>EcuM_EnableWakeupSources(), refer to Ch. 5.6.2.19 </p>
<p></p>
<p> </p>
<p>EcuM_DisableWakeupSources(), refer to Ch. 5.6.2.20 </p>
<p></p>
<p> </p>
<p>EcuM_CheckWakeup(), refer to Ch. 5.6.2.23 </p>
<p></p>
<p> </p>
<p>EcuM_ValidateWakeup(), refer to Ch. 5.6.2.24 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>45 / 117</p>
<p></p>
<p> </p>
<p>EcuM_StartWakeupSources(), refer to Ch. 5.6.2.21 </p>
<p></p>
<p> </p>
<p>EcuM_StopWakeupSources(), refer to Ch. 5.6.2.22 </p>
<p> </p>
<p>The  integration  task  is  to  fill  these  callouts  with  code  which  match  the  ECU  specific </p>
<p>requirements. To give an idea what must be implemented, the following paragraphs covers </p>
<p>three use cases: </p>
<p></p>
<p> </p>
<p>Wakeup after a physical sleep mode </p>
<p></p>
<p> </p>
<p>Handling of wakeup events while ECUM is in RUN state </p>
<p></p>
<p> </p>
<p>Wakeup validation of communication channels (ECUM in RUN state) </p>
<p> </p>
<p><b>4.10.1 </b></p>
<p><b>Wakeup after a physical sleep mode </b></p>
<p><b>4.10.1.1 </b></p>
<p><b>Use case description </b></p>
<p>A raising edge on an ICU channel shall bring the ECUM into RUN state. A wakeup source </p>
<p>“ECUM_WKSOURCE_ICU_CH0” is configured for that. The name of the configured ICU </p>
<p>channel is Icu_Channel0. No wakeup validation shall be performed on that wakeup event. </p>
<p>This wakeup event is the only active wakeup event for the desired sleep mode. </p>
<p><b>4.10.1.2 </b></p>
<p><b>Execution flow </b></p>
<p></p>
<p> </p>
<p>ECUM is in ECUM_APP_RUN no further RUN requests are existent  </p>
<p></p>
<p> </p>
<p>ECUM transits from ECUM_APP_RUN to ECUM_APP_POST_RUN </p>
<p></p>
<p> </p>
<p>Callout EcuM_EnableWakeupSources() is executed.  </p>
<p></p>
<p> </p>
<p>ECUM transits further to ECUM_STATE_SLEEP (ECU is physically in sleep mode) </p>
<p></p>
<p> </p>
<p>External event triggers ICU hardware to raise an interrupt </p>
<p></p>
<p> </p>
<p>Callout EcuM_CheckWakeup() is executed by ISR </p>
<p></p>
<p> </p>
<p>API function EcuM_SetWakeupEvent() is executed </p>
<p></p>
<p> </p>
<p>ECUM  executes  implicitly  EcuM_ValidateWakeupEvent()  because  wakeup  event  is </p>
<p>instantly valid </p>
<p></p>
<p> </p>
<p>ECUM transits from ECUM_STATE_SLEEP until ECUM_STATE_WAKEUP_TWO </p>
<p></p>
<p> </p>
<p>ECUM transits from ECUM_STATE_WAKEUP_TWO to ECUM_STATE_APP_RUN </p>
<p></p>
<p> </p>
<p>Callout EcuM_DisableWakeupSources() is executed </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>46 / 117</p>
<p><b>4.10.1.3 </b></p>
<p><b>Callout implementation examples </b></p>
<p>void EcuM_EnableWakeupSources(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  /* Check for each configured wakeup source the corresponding bit  </p>
<p>   * is set. Here the bit for the ICU wakeup source must be set </p>
<p> */ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_ICU_CH0) != 0) </p>
<p>  { </p>
<p>    Icu_EnableNotification(Icu_Channel0); </p>
<p>    Icu_EnableWakeup(Icu_Channel0); </p>
<p>    Icu_SetMode(ICU_MODE_SLEEP); </p>
<p>  } </p>
<p>  /* … */ </p>
<p>} </p>
<p> </p>
<p>void EcuM_CheckWakeup(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_ICU_CH0) != 0) </p>
<p>  { </p>
<p>      /* no validation necessary, so call EcuM_SetWakeupEvent() */ </p>
<p>      EcuM_SetWakeupEvent(ECUM_WKSOURCE_ICU_CH0); </p>
<p>  } </p>
<p>  /* … */ </p>
<p>} </p>
<p> </p>
<p>void EcuM_DisableWakeupSource(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_ICU_CH0) != 0) </p>
<p>  { </p>
<p>    Icu_DisableNotification(Icu_Channel0); </p>
<p>    Icu_DisableWakeup(Icu_Channel0); </p>
<p>    Icu_SetMode(ICU_MODE_NORMAL); </p>
<p>  }  </p>
<p>} </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>47 / 117</p>
<p> </p>
<p><b>4.10.2 </b></p>
<p><b>Handling of wakeup events while ECUM is in RUN state </b></p>
<p>For this use case it is assumed that wakeup events which occur while ECUM is in RUN </p>
<p>state are caused by communication channels. </p>
<p><b>4.10.2.1 </b></p>
<p><b>Use case description </b></p>
<p>A  wakeup  capable  CAN  hardware  is  assumed. A  message  on  a  CAN  channel  shall  be </p>
<p>recognized and set the CAN channel into normal operation mode (which will be triggered </p>
<p>by  COMM).  A  wakeup  source  ECUM_WKSOURCE_CAN0  is  configured  for  that.  No </p>
<p>wakeup validation will be performed.  </p>
<p><b>4.10.2.2 </b></p>
<p><b>Execution flow </b></p>
<p></p>
<p> </p>
<p>ECUM  is  in  RUN  state  and  the  CAN  channel  is  in  sleep  state  and  is  able  to  detect </p>
<p>wakeup events </p>
<p></p>
<p> </p>
<p>Callout EcuM_CheckWakeup() is executed by ISR </p>
<p></p>
<p> </p>
<p>API EcuM_SetWakeupEvent() is executed </p>
<p></p>
<p> </p>
<p>ECUM </p>
<p>executes </p>
<p>implicitly </p>
<p>executed </p>
<p>ComM_WakeUpIndication() </p>
<p>and </p>
<p>EcuM_ValidateWakeupEvent() because wakeup event is instantly valid. </p>
<p><b>4.10.2.3 </b></p>
<p><b>Callout implementation examples </b></p>
<p>void EcuM_CheckWakeup(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>  { </p>
<p>      /* check if the underlaying driver has a wakeup event detected.  </p>
<p>       * CanIf will execute EcuM_SetWakeupEvent() in this case. </p>
<p> */ </p>
<p>      CanIf_CheckWakeup(ECUM_WKSOURCE_CAN0); </p>
<p>  }  </p>
<p>} </p>
<p><b>4.10.3 </b></p>
<p><b>Wakeup validation of communication channels (ECUM in RUN state) </b></p>
<p><b>4.10.3.1 </b></p>
<p><b>Use case description </b></p>
<p>The same prerequisites as specified in Ch. 4.10.2.1 apply, but the wakeup event must be </p>
<p>validated. </p>
<p><b>4.10.3.2 </b></p>
<p><b>Execution flow </b></p>
<p></p>
<p> </p>
<p>ECUM  is  in  RUN  state  and  the  CAN  channel  is  in  sleep  state  and  is  able  to  detect </p>
<p>wakeup events </p>
<p></p>
<p> </p>
<p>Callout EcuM_CheckWakeup() is executed by ISR </p>
<p></p>
<p> </p>
<p>API EcuM_SetWakeupEvent() is executed, ECUM starts wakeup validation timeout </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>48 / 117</p>
<p></p>
<p> </p>
<p>EcuM_MainFunction() triggered by SCHM </p>
<p></p>
<p> </p>
<p>(a) ECUM detects a pending wakeup event and executes callout </p>
<p>EcuM_StartWakeupSources () </p>
<p></p>
<p> </p>
<p>(b) ECUM executes callout EcuM_CheckValidation() </p>
<p></p>
<p> </p>
<p>Note: step (b) may be executed several times, with each EcuM_MainFunction() </p>
<p>call until the wakeup event is validated or expired, but </p>
<p>EcuM_StartWakeupSources() is executed only once. </p>
<p></p>
<p> </p>
<p>Case Validation successful: </p>
<p></p>
<p> </p>
<p>API EcuM_ValidateWakeupEvent() is executed, ECUM implicitly executed </p>
<p>ComM_WakeUpIndication() </p>
<p></p>
<p> </p>
<p>EcuM_MainFunction() triggered by SCHM </p>
<p></p>
<p> </p>
<p>ECUM stops validation timeout </p>
<p></p>
<p> </p>
<p>Case Validation failed: </p>
<p></p>
<p> </p>
<p>ECUM executes callout EcuM_StopWakeupSources() </p>
<p></p>
<p> </p>
<p>No further wakeup related actions performed </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>49 / 117</p>
<p><b>4.10.3.3 </b></p>
<p><b>Callout implementation examples </b></p>
<p>void EcuM_CheckWakeup(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>  { </p>
<p>      CanIf_CheckWakeup(ECUM_WKSOURCE_CAN0); </p>
<p>  }  </p>
<p>} </p>
<p> </p>
<p>void EcuM_StartWakeupSources(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>  { </p>
<p>     /* determine in which is the current Can Controller state */ </p>
<p>     (void)CanIf_GetControllerMode(0, &amp;CanIfCtrlMode); </p>
<p>     /* in case the Can Controller is not CANIF_CS_STARTED*/ </p>
<p>     if (CANIF_CS_STARTED != CanIfCtrlMode) </p>
<p>     { </p>
<p>         /* Set the controller and transceiver mode into normal operation mode*/ </p>
<p>         CanIf_SetTransceiverMode(0, CANIF_TRCV_MODE_NORMAL);   </p>
<p>   CanIf_SetControllerMode(0, CANIF_CS_STOPPED); </p>
<p>   CanIf_SetControllerMode(0, CANIF_CS_STARTED);  </p>
<p>} </p>
<p>else </p>
<p>{ </p>
<p>    /* Stack already up and running */ </p>
<p>} </p>
<p> }  </p>
<p>} </p>
<p> </p>
<p>void EcuM_CheckValidation(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>  { </p>
<p>      /* Query the driver if the wakeup event was valid */ </p>
<p>      CanIf_CheckValidation(ECUM_WKSOURCE_CAN0); </p>
<p>  }  </p>
<p>} </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>50 / 117</p>
<p>void EcuM_StopWakeupSources(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>  { </p>
<p>      /* validation was not successful, set the CAN controller and </p>
<p> * Transceiver back to sleep mode.  </p>
<p> */ </p>
<p>CanIf_SetControllerMode(0, CANIF_CS_STOPPED); </p>
<p>CanIf_SetControllerMode(0, CANIF_CS_SLEEP); </p>
<p>CanIf_SetTransceiverMode(0, CANIF_TRCV_MODE_STANDBY); </p>
<p>  }  </p>
<p>} </p>
<p> </p>
<p><b>4.10.4 </b></p>
<p><b>Notes to Mcu_SetMode() </b></p>
<p>The execution of </p>
<p>Mcu_SetMode()</p>
<p> to enter sleep mode is one of the crucial actions which </p>
<p>are performed by ECUM. The AUTOSAR specifications are not so exact specified so that </p>
<p>every MCU driver supplier has the same knowledge which implicit requirements have to be </p>
<p>supported by the MCU driver.  </p>
<p>Important  to  know  is  that  the  ECUM  should  call </p>
<p>Mcu_SetMode()</p>
<p>  with  global  locked </p>
<p>interrupts, this can be configured with the second critical section described in  4.7. </p>
<p>If  MCU  driver  supplier  specific  action  are  necessary,  a  possibility  must  be  given  to  add </p>
<p>them  before  and  after  the </p>
<p>Mcu_SetMode()</p>
<p>  call</p>
<p>. </p>
<p>Therefore  the </p>
<p>Mcu_SetMode()</p>
<p>  is </p>
<p>called within the callout </p>
<p>EcuM_McuSetMode</p>
<p>. This callout is always available, it can not be </p>
<p>disabled.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Use this functionality with care.   </p>
<p>It is not allowed to remove the </p>
<p>Mcu_SetMode</p>
<p> function call from callout. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.11 </b></p>
<p><b>Multiple Identity ECUs </b></p>
<p><b>4.11.1 </b></p>
<p><b>Restrictions when implementation variant PreCompile is used </b></p>
<p>The following restrictions exists if the ECUM shall be used for initializing multiple identity </p>
<p>ECUs </p>
<p>when </p>
<p>the </p>
<p>implementation </p>
<p>variant </p>
<p>PreCompile </p>
<p>is </p>
<p>used.  To </p>
<p>use </p>
<p>the </p>
<p>ECUM </p>
<p>in </p>
<p>implementation variant PreCompile is not the normal use case for such ECUs but might be </p>
<p>considered to reduce ECU resources. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>51 / 117</p>
<p><b>4.11.1.1 </b></p>
<p><b>Initialization </b></p>
<p>The  description  in  Ch  4.8  does  not  apply.  The  user  is  responsible  to  implement  the </p>
<p>distinction which identity is currently selected and which modules initialization applies. It is </p>
<p>recommended to use the “Code” segment which can be selected in the DriverInitLists for </p>
<p>this task. </p>
<p><b>4.11.1.2 </b></p>
<p><b>EcuM configuration  </b></p>
<p>If </p>
<p>several </p>
<p>multiple </p>
<p>configuration </p>
<p>containers </p>
<p>(“/MICROSAR/EcuM/EcuMConfiguration”) </p>
<p>within  the  ECUM  configuration  exist,  the  ECUM  uses  the  first  multiple  configuration </p>
<p>container as reference for its generation. </p>
<p>This implies that some configuration parameters cannot differ between the configuration </p>
<p>sets, e.g.: </p>
<p></p>
<p> </p>
<p>Sleep modes </p>
<p></p>
<p> </p>
<p>Wakeup Sources </p>
<p></p>
<p> </p>
<p>ECUM Users </p>
<p></p>
<p> </p>
<p>ComM channels </p>
<p></p>
<p> </p>
<p>TTII successors and divisors </p>
<p></p>
<p> </p>
<p>DriverInitLists </p>
<p></p>
<p> </p>
<p>All </p>
<p>configuration </p>
<p>parameters </p>
<p>which </p>
<p>are </p>
<p>specified </p>
<p>within </p>
<p>the </p>
<p>“/MICROSAR/EcuM/EcuMConfiguration” – container. </p>
<p><b>4.12 </b></p>
<p><b>Generated Template Files </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This chapter is only applicable if DaVinci Configurator is used for ECUM generation. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>A generated template file in this document is a file which: </p>
<p></p>
<p> </p>
<p>is generated by the generation tool at every generation process  </p>
<p></p>
<p> </p>
<p>the user can modify this template for his needs  </p>
<p></p>
<p> </p>
<p>the changes made by the user will not be overwritten at the next generation process </p>
<p> </p>
<p>In order not to overwrite the changes made by the user, the template file contains special </p>
<p>comments,  where  the  user  must  insert  his  code  in  between.  The  comments  have  the </p>
<p>following format: </p>
<p>/********************************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT! &lt;USERBLOCK $Variable_Name&gt; DO NOT CHANGE THIS COMMENT               </p>
<p>***********************************************************************************/ </p>
<p> </p>
<p>/********************************************************************************** </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>52 / 117</p>
<p> * DO NOT CHANGE THIS COMMENT! &lt;/USERBLOCK&gt; DO NOT CHANGE THIS COMMENT     </p>
<p>***********************************************************************************/ </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Do not modify or delete the comments.  </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>Example: </b></p>
<p>The following example explains where code could be implemented: </p>
<p>FUNC(void, ECUM_CODE) EcuM_OnEnterRun(void) </p>
<p>{ </p>
<p>  /* A */ </p>
<p>/*************************************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!  &lt;USERBLOCK EcuM_OnEnterRun&gt;  DO NOT CHANGE THIS COMMENT! </p>
<p> **************************************************************************************/ </p>
<p>  /* B */ </p>
<p>  return; </p>
<p>/*************************************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!  &lt;/USERBLOCK&gt;               DO NOT CHANGE THIS COMMENT! </p>
<p> ***************************************************************************************/ </p>
<p> </p>
<p>  /* C */ </p>
<p>} /* End of EcuM_OnEnterRun() */ </p>
<p> </p>
<p>A and C: all modifications before and after will be deleted at the next generation process </p>
<p>B: all modifications will not be deleted </p>
<p> </p>
<p> </p>
<p>The ECUM provides the following generated template files: </p>
<p></p>
<p> </p>
<p>EcuM_Callout_Stubs.c  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>53 / 117</p>
<p><b>5 </b></p>
<p><b>API Description </b></p>
<p><b>5.1 </b></p>
<p><b>Interfaces Overview </b></p>
<p>See chapter 2.1. </p>
<p><b>5.2 </b></p>
<p><b>Type Definitions </b></p>
<p>ECUM types are described in the following tables: </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>ECUM_SUBSTATE_MASK  </p>
<p>Get the current state by ANDing the state </p>
<p>with this mask. All states are delivered </p>
<p>including substates. </p>
<p>ECUM_STATE_STARTUP </p>
<p>STARTUP super state </p>
<p>ECUM_STATE_STARTUP_ONE </p>
<p>Initialization of drivers which don’t need OS </p>
<p>support </p>
<p>ECUM_STATE_STARTUP_TWO </p>
<p>Initialization of drivers which need OS </p>
<p>support</p>
<p> </p>
<p>ECUM_STATE_WAKEUP </p>
<p>WAKEUP super state</p>
<p> </p>
<p>ECUM_STATE_WAKEUP_ONE </p>
<p>Reinitializing of drivers for normal </p>
<p>operation</p>
<p> </p>
<p>ECUM_STATE_WAKEUP_VALIDATION </p>
<p>Waits for validation of a wakeup event</p>
<p> </p>
<p>ECUM_STATE_WAKEUP_REACTION </p>
<p>Computes the appropriate wakeup reaction</p>
<p>ECUM_STATE_WAKEUP_TWO </p>
<p>Prepares the ECU for RUN state</p>
<p> </p>
<p>ECUM_STATE_WAKEUP_WAKESLEEP </p>
<p>A short system phase where the ECU </p>
<p>transit from a wakeup directly to sleep </p>
<p>again</p>
<p> </p>
<p>ECUM_STATE_WAKEUP_TTII </p>
<p>Performs the TTII protocol</p>
<p> </p>
<p>EcuM_StateType </p>
<p>uint8 </p>
<p>Encodes all states and </p>
<p>sub states provided by </p>
<p>the ECU State </p>
<p>Manager </p>
<p>ECUM_STATE_RUN </p>
<p>Normal ECU operation super state</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>54 / 117</p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>ECUM_STATE_APP_RUN </p>
<p>ECU is in normal operation state</p>
<p> </p>
<p>ECUM_STATE_APP_POST_RUN </p>
<p>ECU performs POST RUN activities</p>
<p> </p>
<p>ECUM_STATE_SHUTDOWN </p>
<p>Shutdown super state</p>
<p> </p>
<p>ECUM_STATE_PREP_SHUTDOWN </p>
<p>Prepares the ECU for the following </p>
<p>shutdown sequence</p>
<p> </p>
<p>ECUM_STATE_GO_SLEEP </p>
<p>Activation of the wakeup sources</p>
<p> </p>
<p>ECUM_STATE_GO_OFF_ONE </p>
<p>Shutdown of system services</p>
<p> </p>
<p>ECUM_STATE_GO_OFF_TWO </p>
<p>Performs a RESET or switches of the ECU</p>
<p>ECUM_STATE_SLEEP </p>
<p>ECU is in sleep state (this information </p>
<p>cannot be retrieved</p>
<p> </p>
<p>ECUM_STATE_OFF </p>
<p>ECU is without power supply (this </p>
<p>information cannot be retrieved) </p>
<p>EcuM_UserType </p>
<p>uint8 </p>
<p>ID of the User which </p>
<p>are able to request </p>
<p>RUN state. Each user </p>
<p>must have a unique Id.</p>
<p>0..255 </p>
<p>The Range depends on the number of </p>
<p>configured users </p>
<p>ECUM_WKSOURCE_POWER  </p>
<p>Identifies a power on reset (bit 0) </p>
<p>ECUM_WKSOURCE_RESET </p>
<p>Identifies a hardware reset (bit 1) </p>
<p>ECUM_WKSOURCE_INTERNAL_RESET  </p>
<p>Identifies resets which only reset the core </p>
<p>of the microcontroller but not the </p>
<p>peripherals. This source also indicates </p>
<p>unhandled exceptions (bit 2) </p>
<p>ECUM_WKSOURCE_INTERNAL_WDG  </p>
<p>Identifies a reset by internal watchdog (bit </p>
<p>3) </p>
<p>ECUM_WKSOURCE_EXTERNAL_WDG  </p>
<p>Identifies a reset by external watchdog (bit </p>
<p>4). (This is only possible if the hardware </p>
<p>supports this feature) </p>
<p>EcuM_WakeupS</p>
<p>ourceType </p>
<p>uint32 </p>
<p>Each bit in this type </p>
<p>identifies a wakeup </p>
<p>source. </p>
<p>... </p>
<p>Can be extended by configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>55 / 117</p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>ECUM_WKSOURCE_ALL_SOURCES  </p>
<p>Identifies each wakeup source </p>
<p>ECUM_WKSOURCE_NONE  </p>
<p>Value 0. This is a MICROSAR ECUM </p>
<p>extension and identifies an invalid wakeup </p>
<p>source. </p>
<p>ECUM_WKSTATUS_NONE  </p>
<p>No pending wakeup was detected </p>
<p>ECUM_WKSTATUS_PENDING  </p>
<p>The wakeup event was detected but not </p>
<p>yet validated </p>
<p>ECUM_WKSTATUS_VALIDATED  </p>
<p>The wakeup event is valid </p>
<p>EcuM_WakeupSt</p>
<p>atusType </p>
<p>uint8 </p>
<p>The type describes </p>
<p>possible outcomes of </p>
<p>the WAKEUP </p>
<p>VALIDATION state. </p>
<p>ECUM_WKSTATUS_EXPIRED  </p>
<p>The wakeup event has not been validated </p>
<p>and has expired before. </p>
<p>ECUM_WKACT_RUN  </p>
<p>Transit into RUN state </p>
<p>ECUM_WKACT_TTII  </p>
<p>Execute the TTII protocol </p>
<p>EcuM_WakeupR</p>
<p>eactionType </p>
<p>uint8 </p>
<p>The describes the </p>
<p>possible outcomes of </p>
<p>the WAKEUP </p>
<p>REACTION state </p>
<p>ECUM_WKACT_SHUTDOWN  </p>
<p>Directly transit to shutdown </p>
<p>ECUM_BOOT_TARGET_APP  </p>
<p>Boot into application mode </p>
<p>EcuM_BootTarge</p>
<p>tType </p>
<p>uint8 </p>
<p>Defines the boot target </p>
<p>which should be </p>
<p>chosen in the next </p>
<p>start up. </p>
<p>ECUM_BOOT_TARGET_BOOTLOADER  </p>
<p>Boot into boot loader mode </p>
<p>Table 5-1   Type definitions </p>
<p><b>5.3 </b></p>
<p><b>Services provided by ECUM </b></p>
<p>The ECUM API consists of services, which are realized by function calls. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>Most of the following API functions report errors as listed in chapter 3.6.1. If an error is </p>
<p>detected the concerning API function will be left without any further actions. </p>
<p><b> </b></p>
<p> </p>
<p><b>5.3.1 </b></p>
<p><b>EcuM_Init </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_Init </b></p>
<p>( void ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>56 / 117</p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This function initializes the ECUM and initializes basic drivers. In this function drivers which are configured </p>
<p>in DriverInitListZero and DriverInitListOne will be initialized. At the end of this function </p>
<p>StartOS()</p>
<p> is called </p>
<p>and therefore this function never returns. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called by an application. </p>
<p>Table 5-2   EcuM_Init </p>
<p><b>5.3.2 </b></p>
<p><b>EcuM_Shutdown </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_Shutdown </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This function performs a reset or switches off the ECU (depending on which shutdown target is currently </p>
<p>chosen). If the ECU should be switched off the callout </p>
<p>EcuM_AL_SwitchOff()</p>
<p> must implement the </p>
<p>specific code.  </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This function shall be called inside the OS </p>
<p>ShutdownHook()</p>
<p> routine. The </p>
<p>integrator is responsible to perform this task. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called by an application. </p>
<p>Table 5-3   EcuM_Shutdown </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>57 / 117</p>
<p><b>5.3.3 </b></p>
<p><b>EcuM_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_GetVersionInfo </b></p>
<p>( Std_VersionInfoType *versioninfo ) </p>
<p><b>Parameter </b></p>
<p>versioninfo </p>
<p>Pointer with the version information </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This service returns the version information of the ECU State Manager. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available, dependently on </p>
<p>ECUM_VERSION_INFO_API</p>
<p>. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called by an application. </p>
<p>Table 5-4   EcuM_GetVersionInfo </p>
<p><b>5.3.4 </b></p>
<p><b>EcuM_RequestRUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_RequestRUN </b></p>
<p>( EcuM_UserType user ) </p>
<p><b>Parameter </b></p>
<p>user </p>
<p>User ID which requests the RUN state </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>Places a RUN request for this user. Users are normally application and resource manager like </p>
<p>Communication Manager. The tracking of the requests is specific for each user.  </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>RUN request will be ignored after an API call to </p>
<p>EcuM_KillAllRUNRequest()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-5   EcuM_RequestRUN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>58 / 117</p>
<p><b>5.3.5 </b></p>
<p><b>EcuM_ReleaseRUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_ReleaseRUN </b></p>
<p>( EcuM_UserType user ) </p>
<p><b>Parameter </b></p>
<p>user </p>
<p>User ID which releases the run request </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Release accepted </p>
<p>E_NOT_OK </p>
<p>Release not accepted </p>
<p><b>Functional Description </b></p>
<p>Releases the RUN request previously done with a call to </p>
<p>EcuM_RequestRUN().</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-6   EcuM_ReleaseRUN </p>
<p><b>5.3.6 </b></p>
<p><b>EcuM_ComM_RequestRUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_ComM_RequestRUN </b></p>
<p>( NetworkHandleType channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>ID of the communication channel requesting the RUN state. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>This function shall be used by the Com Manager to request RUN state. The behavior is identical to </p>
<p>EcuM_RequestRUN().</p>
<p>RUN request will be ignored after an API call to </p>
<p>EcuM_KillAllRUNRequest()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The configured communication channels are obtained from the ECUC file. This means that a valid </p>
<p>COMM configuration must be available at generation time of the ECUM. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-7   EcuM_ComM_RequestRUN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>59 / 117</p>
<p><b>5.3.7 </b></p>
<p><b>EcuM_ComM_ReleaseRUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_ComM_ReleaseRUN </b></p>
<p>( NetworkHandleType channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>ID of the communication channel requesting the RUN state. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>Releases the RUN request previously done with a call to </p>
<p>EcuM_ComM_RequestRUN()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The configured communication channels are obtained from the ECUC file. This means that a valid </p>
<p>COMM configuration must be available at generation time of the ECUM. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-8   EcuM_ComM_ReleaseRUN </p>
<p><b>5.3.8 </b></p>
<p><b>EcuM_ComM_HasRequestedRUN </b></p>
<p><b>Prototype </b></p>
<p>Boolean </p>
<p><b>EcuM_ComM_HasRequestedRUN </b></p>
<p>( EcuM_ChannelHandleType channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>ID of the communication channel requesting the RUN state. </p>
<p><b>Return code </b></p>
<p>TRUE </p>
<p>the channel has requested RUN state </p>
<p>FALSE </p>
<p>the channel has not requested RUN state </p>
<p><b>Functional Description </b></p>
<p>This service returns </p>
<p>TRUE</p>
<p> if the channel given as parameter has actually requested RUN state, the service </p>
<p>returns </p>
<p>FALSE</p>
<p> in the other case. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The configured communication channels are obtained from the ECUC file. This means that a valid </p>
<p>COMM configuration must be available at generation time of the ECUM. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-9   EcuM_ComM_HasRequestedRUN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>60 / 117</p>
<p><b>5.3.9 </b></p>
<p><b>EcuM_RequestPOST_RUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_RequestPOST_RUN </b></p>
<p>( EcuM_UserType user ) </p>
<p><b>Parameter </b></p>
<p>User </p>
<p>User ID which requests the post run request. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>Places a POST RUN request for this user. Users are normally application and resource manager like COM </p>
<p>Manager. The tracking of the requests are specific for each user. POST RUN request will be ignored after </p>
<p>an API call to </p>
<p>EcuM_KillAllRUNRequest().</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-10 EcuM_RequestPOST_RUN </p>
<p><b>5.3.10 </b></p>
<p><b>EcuM_ReleasePOST_RUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_ReleasePOST_RUN </b></p>
<p>( EcuM_UserType user ) </p>
<p><b>Parameter </b></p>
<p>User </p>
<p>User ID which releases the post run request </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Release accepted </p>
<p>E_NOT_OK </p>
<p>Release not accepted </p>
<p><b>Functional Description </b></p>
<p>Releases POST RUN requests previously done with a call to </p>
<p>EcuM_RequestPOST_RUN().</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-11  EcuM_ReleasePOST_RUN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>61 / 117</p>
<p><b>5.3.11 </b></p>
<p><b>EcuM_KillAllRUNRequests </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_KillAllRUNRequests </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Deletes all RUN and POST RUN requests and initiates an ECU reset.   </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p> </p>
<p></p>
<p> </p>
<p>This service was introduced for the Com Manager to perform software </p>
<p>resets in the case of network errors. Only the Com Manager should use </p>
<p>this service. </p>
<p></p>
<p> </p>
<p>After a call to this function all RUN requests will be rejected and wakeup </p>
<p>events will be ignored. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p><b> </b></p>
<p><b>EcuM_KillAllRunRequests: </b></p>
<p> </p>
<p></p>
<p> </p>
<p>its usage is only intended for emergency shutdown </p>
<p></p>
<p> </p>
<p>it sets the shutdown target to RESET </p>
<p></p>
<p> </p>
<p>this shutdown target cannot be modified because: </p>
<p>EcuM_SelectShutDownTarget</p>
<p> </p>
<p>checks </p>
<p>whether </p>
<p>EcuM_KillAllRunRequest</p>
<p>was called before and in this case the function is left with NOT_OK </p>
<p>EcuM_SelectShutDownTarget</p>
<p> </p>
<p>call </p>
<p>before </p>
<p>EcuM_KillAllRunRequest</p>
<p>is </p>
<p>called makes no sense, because the shutdown target will be modified to </p>
<p>RESET within EcuM</p>
<p>_KillAllRunRequest.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available, dependently on </p>
<p>ECUM_KILL_ALL_RUNREQUEST_API</p>
<p>. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-12 EcuM_KillAllRUNRequests </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>62 / 117</p>
<p><b>5.3.12 </b></p>
<p><b>EcuM_SelectShutdownTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_SelectShutdownTarget </b></p>
<p>( EcuM_StateType target, </p>
<p>    uint8 mode ) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>The selected shutdown target must be one of: </p>
<p></p>
<p> </p>
<p>ECUM_STATE_SLEEP </p>
<p></p>
<p> </p>
<p>ECUM_STATE_RESET </p>
<p></p>
<p> </p>
<p>ECUM_STATE_OFF </p>
<p>mode </p>
<p>If the selected target is </p>
<p>ECUM_STATE_SLEEP</p>
<p> this parameter is an index into </p>
<p>the selected sleep mode. If the selected target is not </p>
<p>ECUM_STATE_SLEEP</p>
<p> </p>
<p>this parameter will be ignored, so the value of the parameter does not matter. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>the shutdown target was accepted  </p>
<p>E_NOT_OK </p>
<p>the shutdown target was not accepted </p>
<p><b>Functional Description </b></p>
<p>This service selects a shutdown target in which the shutdown sequence should switch. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>This service can only be used while the ECUM is in RUN state in order to enable the wakeup </p>
<p>sources. Please refer to 5.6.2.19 EcuM_EnableWakeupSources for more information. </p>
<p><b> </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The ECU State Manager does not define any mechanism to resolve issues arising from parallel </p>
<p>requests. It is rather assumed that there will be one application which is ECU specific and handles these </p>
<p>kinds of issues. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-13 EcuM_SelectShutdownTarget </p>
<p><b>5.3.13 </b></p>
<p><b>EcuM_GetState </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_GetState </b></p>
<p>( EcuM_StateType *state ) </p>
<p><b>Parameter </b></p>
<p>state </p>
<p>Reference to the current state of the ECUM. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>The parameter state was not a </p>
<p>NULL_PTR</p>
<p>. </p>
<p>E_NOT_OK </p>
<p>The parameter state was a </p>
<p>NULL_PTR</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>63 / 117</p>
<p><b>Functional Description </b></p>
<p>Returns the current module state of the ECUM. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called by an application. </p>
<p>Table 5-14 EcuM_GetState </p>
<p><b>5.3.14 </b></p>
<p><b>EcuM_GetShutdownTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_GetShutdownTarget </b></p>
<p>( EcuM_StateType *target, </p>
<p>    uint8 *sleepmode ) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>One of these values:</p>
<p> </p>
<p></p>
<p> </p>
<p>ECUM_STATE_SLEEP </p>
<p></p>
<p> </p>
<p>ECUM_STATE_RESET </p>
<p></p>
<p> </p>
<p>ECUM_STATE_OFF </p>
<p>sleepmode </p>
<p>If the target is </p>
<p>ECUM_STATE_SLEEP </p>
<p>the index of the chosen sleep mode is </p>
<p>returned else sleep mode is always set to 0. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>both parameters where not </p>
<p>NULL_PTR</p>
<p>   </p>
<p>E_NOT_OK </p>
<p>both parameters where </p>
<p>NULL_PTR</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Returns the current selected shutdown target. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-15 EcuM_GetShutdownTarget </p>
<p><b>5.3.15 </b></p>
<p><b>EcuM_GetLastShutdownTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_GetLastShutdownTarget </b></p>
<p>( EcuM_StateType *target, </p>
<p>    uint8 *sleepmode ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>64 / 117</p>
<p><b>Parameter </b></p>
<p>target </p>
<p>One of these values:</p>
<p> </p>
<p></p>
<p> </p>
<p>ECUM_STATE_SLEEP </p>
<p></p>
<p> </p>
<p>ECUM_STATE_RESET </p>
<p></p>
<p> </p>
<p>ECUM_STATE_OFF </p>
<p>sleepmode </p>
<p>If the target is </p>
<p>ECUM_STATE_SLEEP</p>
<p> the index of the chosen sleep mode is </p>
<p>returned else sleep mode is always set to 0. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>both parameters where not </p>
<p>NULL_PTR</p>
<p>   </p>
<p>E_NOT_OK </p>
<p>both parameters where </p>
<p>NULL_PTR</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>The return value describes the ECU state from which the last wakeup or power up occurred. This function </p>
<p>always shall return the same value until the next shutdown. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-16 EcuM_GetLastShutdownTarget </p>
<p><b>5.3.16 </b></p>
<p><b>EcuM_GetPendingWakeupEvents </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupSourceType </p>
<p><b>EcuM_GetPendingWakeupEvents </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>EcuM_WakeupSourceType </p>
<p>Every bit set in the return value indicates a wakeup source where the </p>
<p>validation is in progress. </p>
<p><b>Functional Description </b></p>
<p>Returns all wakeup events where the validation is in progress. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant and non interruptible. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in interrupt context. </p>
<p>Table 5-17 EcuM_GetPendingWakeupEvents </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>65 / 117</p>
<p><b>5.3.17 </b></p>
<p><b>EcuM_ClearWakeupEvent </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_ClearWakeupEvent </b></p>
<p>( EcuM_WakeupSourceType sources ) </p>
<p><b>Parameter </b></p>
<p>Sources </p>
<p>Every wakeup source set in the value will be cleared </p>
<p><b>Return code </b></p>
<p>void </p>
<p>--  </p>
<p><b>Functional Description </b></p>
<p>Clears the pending, validated and expired wakeup events which are passed by the parameter. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant and non interruptible. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in interrupt context. </p>
<p>Table 5-18 EcuM_GetPendingWakeupEvents </p>
<p><b>5.3.18 </b></p>
<p><b>EcuM_GetValidatedWakeupEvents </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupSourceType </p>
<p><b>EcuM_GetValidatedWakeupEvents </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>EcuM_WakeupSourceType </p>
<p>ID of the wakeup source which caused the wakeup of the ECU. </p>
<p><b>Functional Description </b></p>
<p>This function returns wakeup event which causes the wakeup of the microcontroller from the previous sleep </p>
<p>mode. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant and non interruptible. </p>
<p></p>
<p> </p>
<p>This service is available, dependently on </p>
<p>ECUM_GET_VALIDATED_WAKEUP_EVENTS_API</p>
<p>. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-19 EcuM_GetValidatedWakeupEvents </p>
<p><b>5.3.19 </b></p>
<p><b>EcuM_GetExpiredWakeupEvents </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupSourceType </p>
<p><b>EcuM_GetExpiredWakeupEvents </b></p>
<p>( void ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>66 / 117</p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>EcuM_WakeupSourceType </p>
<p>IDs of the wakeup sources where the validation has failed. </p>
<p><b>Functional Description </b></p>
<p>Returns all wakeup sources where the validation has failed from the previous wakeup phase. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available, dependently on </p>
<p>ECUM_GET_EXPIRED_WAKEUP_EVENTS_API.</p>
<p> </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-20 EcuM_GetExpiredWakeupEvents </p>
<p><b>5.3.20 </b></p>
<p><b>EcuM_GetStatusOfWakeupSource </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupStatusType </p>
<p><b>EcuM_GetStatusOfWakeupSource </b></p>
<p>( EcuM_WakeupSourceType </p>
<p>sources ) </p>
<p><b>Parameter </b></p>
<p>sources </p>
<p>ID of a wakeup source </p>
<p>or a mask with several encoded wakeup sources </p>
<p>or</p>
<p> ECUM_WKSOURCE_ALL_SOURCES </p>
<p><b>Return code </b></p>
<p>ECUM_WKSTATUS_NONE  </p>
<p>No pending wakeup event was detected for the passed wakeup source. </p>
<p>ECUM_WKSTATUS_VALIDATED </p>
<p>The wakeup source caused the ECU wakeup. </p>
<p>ECUM_WKSTATUS_PENDING </p>
<p>A wakeup event was detected but not yet validated. </p>
<p>ECUM_WKSTATUS_EXPIRED </p>
<p>A wakeup event has not been validated. </p>
<p><b>Functional Description </b></p>
<p>Returns the sum status all wakeup sources passed in the parameter. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available, dependently on </p>
<p>ECUM_GET_STATUS_OF_WAKEUP_SOURCE_API.</p>
<p> </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-21 EcuM_GetStatusOfWakeupSource </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>67 / 117</p>
<p><b>5.3.21 </b></p>
<p><b>EcuM_SelectApplicationMode </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_SelectApplicationMode </b></p>
<p>( AppModeType appmode ) </p>
<p><b>Parameter </b></p>
<p>appmode </p>
<p>Application mode for the next OS restart. Values depend on the OS </p>
<p>configuration. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>The service always succeeds, because no parameter checking can be </p>
<p>performed. </p>
<p><b>Functional Description </b></p>
<p>Sets the application mode of the OS for the next restart. The application mode will be set after an intended </p>
<p>reset. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>Deviation to AUTOSAR: return value E_NOT_OK is not provided. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-22 EcuM_SelectApplicationMode </p>
<p><b>5.3.22 </b></p>
<p><b>EcuM_GetApplicationMode </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_GetApplicationMode </b></p>
<p>( AppModeType *appmode ) </p>
<p><b>Parameter </b></p>
<p>appmode </p>
<p>Currently selected application mode of the OS. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Call was successful. </p>
<p>E_NOT_OK </p>
<p>Call was rejected (in the case if a </p>
<p>NULL_PTR</p>
<p> has been passed as </p>
<p>argument). </p>
<p><b>Functional Description </b></p>
<p>Returns the current selected application mode. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>68 / 117</p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-23 EcuM_GetApplicationMode </p>
<p><b>5.3.23 </b></p>
<p><b>EcuM_SelectBootTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_SelectBootTarget </b></p>
<p>( EcuM_BootTargetType target ) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>The selected boot target. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Call was accepted. </p>
<p>E_NOT_OK </p>
<p>Call was rejected. </p>
<p><b>Functional Description </b></p>
<p>This service sets the boot target to the specified value. Whenever this service is executed the callout </p>
<p>function EcuM_Appl_SelectBootTarget() will be executed implicitly</p>
<p>. In this callout the desired behavior has </p>
<p>to be implemented. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>This service does not perform any NULL_PTR check or UNINIT check. When such </p>
<p>functionality is required it must be implemented by the user in the specific callouts. </p>
<p><b> </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-24 EcuM_SelectBootTarget </p>
<p><b>5.3.24 </b></p>
<p><b>EcuM_GetBootTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_GetBootTarget </b></p>
<p>( EcuM_BootTargetType *target ) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>The current selected boot target. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Call was accepted. </p>
<p>E_NOT_OK </p>
<p>Call was rejected (in the case if a </p>
<p>NULL_PTR</p>
<p> has been passed as </p>
<p>argument). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>69 / 117</p>
<p><b>Functional Description </b></p>
<p>This service returns the current selected boot target. Whenever this service is executed the callout function </p>
<p>EcuM_Appl_GetBootTarget() will be executed implicitly</p>
<p>. In this callout the desired behavior has to be </p>
<p>implemented.  (See also description of 5.3.23). </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-25 EcuM_GetBootTarget </p>
<p><b>5.3.25 </b></p>
<p><b>EcuM_MainFunction </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_MainFunction </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This service implements all activities of the ECU State Manager while OS is up and running. This service </p>
<p>must be called on a periodic basis from an adequate OS task. To determine the period the SWS suggests </p>
<p>the following points: </p>
<p></p>
<p> </p>
<p>The period directly results in a possible latency for testing RUN requests. The largest acceptable </p>
<p>reaction time will therefore limit the maximum period for invocation. </p>
<p></p>
<p> </p>
<p>The service also carries out the wakeup validation protocol. The smallest validation timeout typically </p>
<p>should limit the period. </p>
<p></p>
<p> </p>
<p>As a rule of thumb, the period of this service should be in the order of half as long as the shortest time </p>
<p>constant mentioned in the topics above </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-26 EcuM_MainFunction </p>
<p><b>5.3.26 </b></p>
<p><b>EcuM_StartupTwo </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_StartupTwo </b></p>
<p>( void ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>70 / 117</p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This function initializes drivers and manager modules which are not initialized in </p>
<p>EcuM_Init()</p>
<p> function, </p>
<p>like Nvm, ComM, etc. The activities performed in this function are described in the ECU State Manager </p>
<p>specification as STARTUP II phase. The DriverInitListTwo and DriverInitListThree will be executed in this </p>
<p>function. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-27 EcuM_StartupTwo </p>
<p><b>5.4 </b></p>
<p><b>Services used by ECUM </b></p>
<p>In  the  following  table  services  provided  by  other  components,  which  are  used  by  the </p>
<p>ECUM are listed. For details about prototype and functionality refer to the documentation </p>
<p>of the providing component. </p>
<p>Refer to chapter 2.1  </p>
<p><b>5.5 </b></p>
<p><b>Callback Functions </b></p>
<p>This chapter describes the callback functions that are implemented by the ECUM and can </p>
<p>be invoked by other modules. The prototypes of the callback functions are provided in the </p>
<p>header file </p>
<p>EcuM_Cbk.h</p>
<p> by the ECUM. </p>
<p><b>5.5.1 </b></p>
<p><b>EcuM_CB_NfyNvMJobEnd </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_CB_NfyNvMJobEnd </b></p>
<p>( uint8 ServiceID, NvM_RequestResultType </p>
<p>JobResult ) </p>
<p><b>Parameter </b></p>
<p>ServiceID </p>
<p>Unique service ID of NVRAM manger service. </p>
<p>JobResult </p>
<p>Covers the job result of the previous processed multi block job. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Used to notify about the end of NVRAM jobs initiated by ECUM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>71 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is synchronous. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available, dependently on </p>
<p>ECUM_INCLUDE_NVRAM_MGR</p>
<p>. </p>
<p></p>
<p> </p>
<p>The NVRAM manager must be configured to call this callback as a multiple block job end notification. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This function is expected to be called in application context. </p>
<p>Table 5-28 EcuM_CB_NfyNvMJobEnd </p>
<p><b>5.5.2 </b></p>
<p><b>EcuM_SetWakeupEvent </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_SetWakeupEvent </b></p>
<p>( EcuM_WakeupSourceType event ) </p>
<p><b>Parameter </b></p>
<p>event </p>
<p>ID of the wakeup source </p>
<p><b>Return code </b></p>
<p>void </p>
<p>--   </p>
<p><b>Functional Description </b></p>
<p>The driver or the module which validates the appropriate wakeup event must call this service to start the </p>
<p>wakeup validation protocol. If the wakeup source needs validation the corresponding timeout will be </p>
<p>started. If no validation is required this function implicitly calls </p>
<p>EcuM_ValidateWakeupEvent().</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant and non interruptible. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in interrupt context. </p>
<p>Table 5-29 EcuM_SetWakeupEvent </p>
<p><b>5.5.3 </b></p>
<p><b>EcuM_ValidateWakeupEvent </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_ValidateWakeupEvent </b></p>
<p>( EcuM_WakeupSourceType event ) </p>
<p><b>Parameter </b></p>
<p>event </p>
<p>ID of wakeup source </p>
<p><b>Return code </b></p>
<p>void </p>
<p>--  </p>
<p><b>Functional Description </b></p>
<p>If the validation of the wakeup event was successful this service has to be called by the module which </p>
<p>performs the validation. If no validation is required the function will be called implicitly. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>72 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-30 EcuM_ValidateWakeupEvent </p>
<p> </p>
<p><b>5.6 </b></p>
<p><b>Configurable Interfaces </b></p>
<p><b>5.6.1 </b></p>
<p><b>Notifications </b></p>
<p>The ECUM does not provide notifications. </p>
<p><b>5.6.2 </b></p>
<p><b> Callout Functions </b></p>
<p>At its configurable interfaces the ECUM defines callout functions. The declarations of the </p>
<p>callout functions are provided by the BSW module, i.e. the ECUM. It is the integrator's task </p>
<p>to  provide  the  corresponding  function  definitions.  The  definitions  of  the  callouts  can  be </p>
<p>adjusted to the system's needs. The ECUM callout function declarations are described in </p>
<p>the following tables: </p>
<p><b>5.6.2.1 </b></p>
<p><b>EcuM_AL_DriverInitZero </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_AL_DriverInitZero </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>73 / 117</p>
<p><b>Functional Description </b></p>
<p>This callout shall provide driver initialization and other hardware-related startup activities for loading the </p>
<p>post-build configuration data.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the pre-compile switch </p>
<p>V_SUPRESS_EXTENDED_VERSION_CHECK</p>
<p> is defined </p>
<p>the default implementation of this callout executes the Vector specific function </p>
<p>VLibVersionCheck().</p>
<p>  This function ensures the integrity of the delivery.  </p>
<p>If the function call was not successful, one of the two following will occur: </p>
<p></p>
<p> </p>
<p>development </p>
<p>is </p>
<p>activated: </p>
<p>the </p>
<p>error </p>
<p>module </p>
<p>(usually </p>
<p>DET </p>
<p>module) </p>
<p>is </p>
<p>executed </p>
<p></p>
<p> </p>
<p>production mode is activated: an endless loop will be entered. This is part of </p>
<p>template code and shall be adapted by user to meet current system needs.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Only pre-compile and link-time configurable modules may be used. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in EcuM_Init(), task context </p>
<p> </p>
<p><b>5.6.2.2 </b></p>
<p><b>EcuM_AL_DriverInitOne </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_AL_DriverInitOne </b></p>
<p>(const EcuM_ConfigType *ConfigPtr ) </p>
<p><b>Parameter </b></p>
<p>ConfigPtr</p>
<p> </p>
<p>Pointer to ECUM configuration structure. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The ECUM executes this callout with a NULL_PTR as </p>
<p>argument. </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>74 / 117</p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout initializes all driver modules which should be initialized before the OS is up and running. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If the ECUM is delivered in post-build variant. The signature of this callout </p>
<p>changes into void EcuM_DriverInitOne_&lt;0..n&gt;(void), in order to provide the post-</p>
<p>build capability of the ECUM. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function is configured via configuration tool. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in </p>
<p>EcuM_Init()</p>
<p>, task context </p>
<p>Table 5-31 EcuM_AL_DriverInitOne </p>
<p><b>5.6.2.3 </b></p>
<p><b>EcuM_AL_DriverInitTwo </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_AL_DriverInitTwo </b></p>
<p>(const EcuM_ConfigType *ConfigPtr ) </p>
<p><b>Parameter </b></p>
<p>ConfigPtr</p>
<p> </p>
<p>Pointer to ECUM configuration structure. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The ECUM executes this callout with a NULL_PTR as </p>
<p>argument. </p>
<p><b> </b></p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Initializes driver modules which should be initialized after the OS has been started. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If the ECUM is delivered in post-build variant. The signature of this callout </p>
<p>changes into void EcuM_DriverInitTwo_&lt;0..n&gt;(void), in order to provide the post-</p>
<p>build capability of the ECUM. </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>75 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function is configured via configuration tool. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>invoked in </p>
<p>EcuM_StartupTwo()</p>
<p>, task context </p>
<p></p>
<p> </p>
<p>Invoked when module state = STARTUPII </p>
<p>Table 5-32 EcuM_AL_DriverInitTwo </p>
<p><b>5.6.2.4 </b></p>
<p><b>EcuM_AL_DriverInitThree </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_AL_DriverInitThree </b></p>
<p>(const EcuM_ConfigType *ConfigPtr ) </p>
<p><b>Parameter </b></p>
<p>ConfigPtr</p>
<p> </p>
<p>Pointer to ECUM configuration structure. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The ECUM executes this callout with a NULL_PTR as </p>
<p>argument. </p>
<p><b> </b></p>
<p><b>Return code </b></p>
<p>void  </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout shall provide driver initialization of drivers which need OS and need valid (if the </p>
<p>NvM_ReadAll()</p>
<p> job was successful) NVRAM data. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If the ECUM is delivered in post-build variant. The signature of this callout </p>
<p>changes into void EcuM_DriverInitOne_&lt;0..n&gt;(void), in order to provide the post-</p>
<p>build capability of the ECUM. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function is configured via configuration tool. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in EcuM_StartupTwo(), task context </p>
<p></p>
<p> </p>
<p>Invoked after Rte_Start() is executed </p>
<p>Table 5-33 EcuM_AL_DriverInitThree </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>76 / 117</p>
<p> </p>
<p><b>5.6.2.5 </b></p>
<p><b>EcuM_DeterminePbConfiguration </b></p>
<p><b>Prototype </b></p>
<p>EcuM_ConfigType* </p>
<p><b>EcuM_DeterminePbConfiguration</b></p>
<p> ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>EcuM_ConfigType </p>
<p>Pointer to the used configuration set. </p>
<p><b>Functional Description </b></p>
<p>This callout should determine which post-build configuration should be used by the ECUM. This has to be </p>
<p>done by the integrator. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This callout will only be activated when the implementation of the module is </p>
<p>delivered as post-build variant. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in </p>
<p>EcuM_Init()</p>
<p>, task context </p>
<p></p>
<p> </p>
<p>Invoked between </p>
<p>EcuM_AL_DriverInitZero()</p>
<p> and </p>
<p>EcuM_AL_DriverInitOne()</p>
<p> </p>
<p>Table 5-34 EcuM_DeterminePbConfiguration </p>
<p><b>5.6.2.6 </b></p>
<p><b>EcuM_AL_SwitchOff </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_AL_SwitchOff </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout shall take the code for shutting off the power supply of the ECU. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>77 / 117</p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in </p>
<p>EcuM_Shutdown()</p>
<p>, task context </p>
<p>Table 5-35 EcuM_AL_SwitchOff </p>
<p><b>5.6.2.7 </b></p>
<p><b>EcuM_AL_DriverRestart </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_AL_DriverRestart </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout shall provide driver initialization and other hardware related startup activities after a wakeup </p>
<p>event from SLEEP state. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If the ECUM is delivered in post-build variant. The signature of this callout </p>
<p>changes into void EcuM_DriverRestart_&lt;0..n&gt;(void), in order to provide the post-</p>
<p>build capability of the ECUM. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function is configured via configuration tool. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in </p>
<p>EcuM_MainFunction()</p>
<p>, task context </p>
<p></p>
<p> </p>
<p>Invoked directly after the wakeup phase </p>
<p>Table 5-36 EcuM_AL_DriverRestart </p>
<p><b>5.6.2.8 </b></p>
<p><b>EcuM_GenerateRamHash </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_GenerateRamHash </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout is intended to provide a RAM integrity test. The goal of this test is to ensure that after a long </p>
<p>SLEEP duration, RAM contents is still consistent. The RAM check itself must be provided by the integrator. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>78 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Invoked just before putting the ECU into sleep mode </p>
<p>Table 5-37 EcuM_GenerateRamHash </p>
<p><b>5.6.2.9 </b></p>
<p><b>EcuM_CheckRamHash </b></p>
<p><b>Prototype </b></p>
<p>uint8 </p>
<p><b>EcuM_CheckRamHash </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>0 </p>
<p>Integrity test failed </p>
<p>1..255 </p>
<p>Integrity test passed </p>
<p><b>Functional Description </b></p>
<p>This callout is intended to provide a RAM integrity check previously done with </p>
<p>EcuM_GenerateRamHash()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Directly called after the wakeup of the ECU. </p>
<p>Table 5-38 EcuM_CheckRamHash </p>
<p><b>5.6.2.10 </b></p>
<p><b>EcuM_OnRTEStartup </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnRTEStartup </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities before starting the RTE. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>79 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_RTESTARTUP_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called before </p>
<p>Rte_Start()</p>
<p> is executed. Module state: STARTUPII </p>
<p>Table 5-39 EcuM_OnRTEStartup </p>
<p><b>5.6.2.11 </b></p>
<p><b>EcuM_OnEnterRun </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnEnterRun </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities before entering RUN state. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_ENTER_RUN_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called just before entering RUN state. </p>
<p>Table 5-40 EcuM_OnEnterRun </p>
<p><b>5.6.2.12 </b></p>
<p><b>EcuM_OnExitRun </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnExitRun </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities while leaving RUN state. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>80 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_EXIT_RUN_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called at the transition from RUN to POST RUN state. </p>
<p>Table 5-41 EcuM_OnExitRun </p>
<p><b>5.6.2.13 </b></p>
<p><b>EcuM_OnExitPostRun </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnExitPostRun </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities while leaving POST RUN state. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_EXIT_RUN_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called while leaving POST RUN state. </p>
<p>Table 5-42 EcuM_OnExitPostRun </p>
<p><b>5.6.2.14 </b></p>
<p><b>EcuM_OnPrepShutdown </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnPrepShutdown </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities in PREP SHUTDOWN state. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>81 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_PREP_SHUTDOWN_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called just after entering PREP SHUTDOWN state. </p>
<p>Table 5-43 EcuM_OnPrepShutdown </p>
<p><b>5.6.2.15 </b></p>
<p><b>EcuM_OnGoSleep </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnGoSleep </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities while module is in GO SLEEP state. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_GO_SLEEP_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called after entering GO SLEEP state. </p>
<p>Table 5-44 EcuM_OnGoSleep </p>
<p><b>5.6.2.16 </b></p>
<p><b>EcuM_OnGoOffOne </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnGoOffOne </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities in GO OFF I state. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>82 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_GO_OFF_ONE_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called right after entering GO OFF I state. </p>
<p>Table 5-45 EcuM_OnGoOffOne </p>
<p><b>5.6.2.17 </b></p>
<p><b>EcuM_OnGoOffTwo </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_OnGoOffTwo </b></p>
<p>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities in GO OFF II state. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_GO_OFF_TWO_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called right after entering GO OFF II state. </p>
<p>Table 5-46 EcuM_OnGoOffTwo </p>
<p><b>5.6.2.18 </b></p>
<p><b>EcuM_OnWakeupReaction </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupReactionType </p>
<p><b>EcuM_OnWakeupReaction </b></p>
<p>( EcuM_WakeupReactionType </p>
<p>wact ) </p>
<p><b>Parameter </b></p>
<p>wact </p>
<p>Default wakeup reaction after a controller wakeup. </p>
<p><b>Return code </b></p>
<p>EcuM_WakeupReactionType </p>
<p>ECUM_WKACT_RUN </p>
<p>The ECUM should transit to RUN state. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>83 / 117</p>
<p>EcuM_WakeupReactionType </p>
<p>ECUM_WKACT_TTII </p>
<p>The ECUM should perform the TTII protocol (only possible if globally </p>
<p>enabled). </p>
<p>EcuM_WakeupReactionType </p>
<p>ECUM_WKACT_SHUTDOWN </p>
<p>The ECUM should transit into SHUTDOWN sequence. </p>
<p><b>Functional Description </b></p>
<p>Within this callout the System designer has the possibility to influence the default behavior of the ECU </p>
<p>State Manager after a wakeup phase. If desired the integrator has the ability to set the input parameter to a </p>
<p>value which is different as the default mechanism. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>It is not recommended to redefine the default values computed by the ECUM. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is optional. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is available dependently on </p>
<p>ECUM_ON_WAKEUP_REACTION_CALLOUT</p>
<p>. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called in </p>
<p>ECUM_STATE_WAKEUP_REACTION</p>
<p> state. </p>
<p>Table 5-47 EcuM_OnWakeupReaction </p>
<p><b>5.6.2.19 </b></p>
<p><b>EcuM_EnableWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_EnableWakeupSources </b></p>
<p>( EcuM_WakeupSourceType wakeupSource ) </p>
<p><b>Parameter </b></p>
<p>wakeupSource</p>
<p> </p>
<p>Every bit set in the parameter indicates a wakeup source which should be </p>
<p>enabled in the current sleep mode. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If the shutdown target is ECUM_STATE_OFF, this callout </p>
<p>is executed with parameter value  </p>
<p>ECUM_WKSOURCE_ALL_SOURCES. </p>
<p><b> </b></p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>84 / 117</p>
<p><b>Functional Description </b></p>
<p>This callout will be called whenever RUN state is left. Every bit set in the parameter indicates the wakeup </p>
<p>source which should be enabled. The integrator has to take care to implement the necessary activities to </p>
<p>enable the corresponding wakeup source. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>[1] proposed to execute this callout in GO OFF SLEEP II state. The time between </p>
<p>leaving RUN state and the possibility to detect wakeup event may take a relative </p>
<p>long long time where wakeup events can be lost. Therefore this implementation </p>
<p>executes this callout right after leaving RUN state. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called when RUN state is left. </p>
<p>Table 5-48 EcuM_EnableWakeupSources </p>
<p> </p>
<p><b>5.6.2.20 </b></p>
<p><b>EcuM_DisableWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_DisableWakeupSources </b></p>
<p>( EcuM_WakeupSourceType wakeupSource ) </p>
<p><b>Parameter </b></p>
<p>wakeupSource</p>
<p> </p>
<p>Every bit set in the parameter indicates a wakeup source which was active in </p>
<p>the previous sleep mode. </p>
<p> </p>
<p><b> </b></p>
<p><b>Info</b> </p>
<p>If the shutdown target is ECUM_STATE_OFF, this callout </p>
<p>is executed with parameter value  </p>
<p>ECUM_WKSOURCE_ALL_SOURCES. </p>
<p><b> </b></p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout will be called whenever RUN state is entered from a previous sleep state. Every bit set in the </p>
<p>parameter indicates the wakeup source which was enabled in the previous sleep mode. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>85 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called just before RUN state is entered </p>
<p>Table 5-49 EcuM_DisableWakeupSources </p>
<p> </p>
<p><b>5.6.2.21 </b></p>
<p><b>EcuM_StartWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_StartWakeupSources </b></p>
<p>( EcuM_WakeupSourceType wakeupSource ) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Every bit set in the parameter indicates a wakeup source which is enabled in </p>
<p>the current sleep mode. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The callout shall start the given wakeup source(s) so that they are ready to perform wakeup validation.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Within [1] is not clear how the parameter which is passed within the ECUM should be </p>
<p>derived, hence this imple</p>
<p>mentation passed the enabled wakeup sources for the actual </p>
<p>chosen sleep mode. The integrator has to take care about to implement the necessary </p>
<p>code in the corresponding wakeup sources. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called in WAKEUP ONE state </p>
<p>Table 5-50 EcuM_StartWakeupSources </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>86 / 117</p>
<p><b>5.6.2.22 </b></p>
<p><b>EcuM_StopWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_StopWakeupSources </b></p>
<p>( EcuM_WakeupSourceType wakeupSource ) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Every bit set in the parameter indicates a wakeup source which is enabled in </p>
<p>the current sleep mode. </p>
<p><b>Return code </b></p>
<p>void </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>This callout shall stop the given wakeup source(s) after unsuccessful wakeup validation. Refer to 5.6.2.21 </p>
<p>for the information how the parameter is derived. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called in WAKEUP WAKESLEEP state </p>
<p>Table 5-51 EcuM_StopWakeupSources </p>
<p><b>5.6.2.23 </b></p>
<p><b>EcuM_CheckWakeup </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_CheckWakeup </b></p>
<p>( EcuM_WakeupSourceType wakeupSource ) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>ID of a wakeup source. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout shall be called by the ISR of a wakeup source to set up the PLL and check other wakeup </p>
<p>sources that may be connected to the same interrupt.  Refer to [1] for more information. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Expected to be called in interrupt context. </p>
<p>Table 5-52 EcuM_CheckWakeup </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>87 / 117</p>
<p><b>5.6.2.24 </b></p>
<p><b>EcuM_CheckValidation </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_CheckValidation </b></p>
<p>( EcuM_WakeupSourceType wakeupSource ) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Wakeup IDs of pending wakeup events. </p>
<p><b>Return code </b></p>
<p>void  </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This callout is called by the ECUM when wakeup validation of a wakeup event is necessary. The pending </p>
<p>wakeup event(s) are passed by the parameter in order to allow the necessary reaction depending on the </p>
<p>wakeup source. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is mandatory. </p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>This function is always available. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Invoked in task context </p>
<p></p>
<p> </p>
<p>Called in WAKEUP VALIDATION state </p>
<p>Table 5-53 EcuM_CheckValidation </p>
<p><b>5.6.2.25 </b></p>
<p><b>EcuM_GeneratorCompatibilityError </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_GeneratorCompatibilityError </b></p>
<p>( uint16 ModuleId, uint8 InstanceId </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ModuleId </p>
<p>Module ID where the generator  compatibility check failed </p>
<p>InstanceId </p>
<p>Instance ID where the generator compatibility check failed </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>88 / 117</p>
<p><b>Functional Description </b></p>
<p>This callout was introduced additionally to the AUTOSAR standard. Every Vector AUTOSAR component </p>
<p>which has the generator compatibility check implemented calls this callout if for example the expected </p>
<p>generator version does not match the current used generator version. A detailed description when this </p>
<p>callout is executed can be found in the corresponding documentation of the BSW module. </p>
<p>The generator compatibility check was introduced by Vector to recognize version inconsistency in post-</p>
<p>build configuration data. The check is performed in the modules’ Init-function.  </p>
<p>The integrator has to implement the necessary actions to resolve such version conflicts.   </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The default implementation of this callout calls the development error module (usually </p>
<p>DET module) if the ECUM is in development mode or enters an endless loop if the </p>
<p>ECUM is in production mode. The endless loop is part of template code and shall be </p>
<p>adapted by user to meet current system needs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is non re-entrant. </p>
<p></p>
<p> </p>
<p>The availability of this callout depends on the customer license or the configuration parameter </p>
<p>EcuMGeneratorCompatibilityError. </p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-54 EcuM_GeneratorCompatibilityError </p>
<p><b>5.6.2.26 </b></p>
<p><b>EcuM_Appl_SelectBootTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_Appl_SelectBootTarget </b></p>
<p>( EcuM_BootTargetType target ) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>The selected boot target. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>The implementation must return E_OK if no error occurs. </p>
<p>E_NOT_OK </p>
<p>The implementation must return E_NOT_OK if an error occurs. </p>
<p><b>Functional Description </b></p>
<p>This callout was introduced additionally to the AUTOSAR standard. Its intention is to be able to write the </p>
<p>necessary code to select the boot target in which the ECU shall boot after the next reset. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The implementation of this callout depends strongly on the used boot loader and </p>
<p>memory stack. </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>89 / 117</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-55 EcuM_Appl_SelectBootTarget </p>
<p><b>5.6.2.27 </b></p>
<p><b>EcuM_Appl_GetBootTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p><b>EcuM_Appl_GetBootTarget </b></p>
<p>( EcuM_BootTargetType *target ) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>The current selected boot target. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>The implementation must return E_OK if no error occurs. </p>
<p>E_NOT_OK </p>
<p>The implementation must return E_NOT_OK if an error occurs. </p>
<p><b>Functional Description </b></p>
<p>This callout was introduced additionally to the AUTOSAR standard. Its intention is to be able to write the </p>
<p>necessary code to retrieve the selected boot target. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The implementation of this callout depends strongly on the used boot loader and </p>
<p>memory stack. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-56 EcuM_Appl_GetBootTarget </p>
<p><b>5.6.2.28 </b></p>
<p><b>EcuM_McuSetMode </b></p>
<p><b>Prototype </b></p>
<p>void </p>
<p><b>EcuM_McuSetMode </b></p>
<p>( uint8 mode_u8 ) </p>
<p><b>Parameter </b></p>
<p>mode_u8 </p>
<p>The desired MCU mode. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>90 / 117</p>
<p><b>Functional Description </b></p>
<p>This callout was introduced additionally to the AUTOSAR standard. Its intention is to be able to implement </p>
<p>the Sleep Mode ISR dependent from used HW. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The implementation of this callout depends strongly on the used microcontroller. </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-57 EcuM_McuSetMode </p>
<p> </p>
<p><b>5.6.3 </b></p>
<p><b>Mode switch notification functions </b></p>
<p><b>5.6.3.1 </b></p>
<p><b>Appl_EcuM_currentMode_currentMode </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType Appl_EcuM_currentMode_currentMode(EcuM_ModeType mode)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>mode </p>
<p></p>
<p> </p>
<p>ECUM_MODE_POST_RUN </p>
<p></p>
<p> </p>
<p>ECUM_MODE_RUN </p>
<p></p>
<p> </p>
<p>ECUM_MODE_SHUTDOWN </p>
<p></p>
<p> </p>
<p>ECUM_MODE_SLEEP </p>
<p></p>
<p> </p>
<p>ECUM_MODE_STARTUP </p>
<p></p>
<p> </p>
<p>ECUM_MODE_WAKE_SLEEP </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>The SW-C notified. </p>
<p>E_NOT_OK </p>
<p>The SW-C does not notified the mode. </p>
<p><b>Functional Description </b></p>
<p>This function informs the SW-C about a ECUM mode change. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is only available if no RTE is used. </p>
<p></p>
<p> </p>
<p>This function is only available if current mode port is enabled. </p>
<p>Call context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-58 Appl_EcuM_currentMode_currentMode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>91 / 117</p>
<p><b>5.6.3.2 </b></p>
<p><b>Rte_Switch_currentMode_currentMode </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType </p>
<p>Rte_Switch_currentMode_currentMode(Rte_ModeType_EcuM_Mode mode)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>mode </p>
<p></p>
<p> </p>
<p>RTE_MODE_EcuM_Mode_POST_RUN </p>
<p></p>
<p> </p>
<p>RTE_MODE_EcuM_Mode_RUN </p>
<p></p>
<p> </p>
<p>RTE_MODE_EcuM_Mode_SHUTDOWN </p>
<p></p>
<p> </p>
<p>RTE_MODE_EcuM_Mode_SLEEP </p>
<p></p>
<p> </p>
<p>RTE_MODE_EcuM_Mode_STARTUP </p>
<p></p>
<p> </p>
<p>RTE_MODE_EcuM_Mode_WAKE_SLEEP </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>The SW-C notified. </p>
<p>E_NOT_OK </p>
<p>The SW-C does not notified the mode. </p>
<p><b>Functional Description </b></p>
<p>This function informs the SW-C about a ECUM mode change. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function is only available if RTE is used. </p>
<p></p>
<p> </p>
<p>This function is only available if current mode port is enabled. </p>
<p>Call context </p>
<p></p>
<p> </p>
<p>Expected to be called in application context. </p>
<p>Table 5-59 Rte_Switch_currentMode_currentMode </p>
<p><b>5.7 </b></p>
<p><b>Service Ports </b></p>
<p>Via Service Ports the software components (SWC) have the possibility to execute services </p>
<p>of  the  ECUM  with  an  abstract  RTE  interface.  Hence,  the  software  components  are </p>
<p>independent from the underlying basic software stack. </p>
<p><b>5.7.1 </b></p>
<p><b>Client Server Interface </b></p>
<p>A client server interface is related to a Provide Port at the server side and a Require Port </p>
<p>at client side.  </p>
<p><b>5.7.1.1 </b></p>
<p><b>Provide Ports on ECUM side </b></p>
<p>At  the  Provide  Ports  of  the  ECUM  the API  functions  described  in  5.3  are  available  as </p>
<p>Runnable Entities. The Runnable Entities are invoked via Operations. The mapping from a </p>
<p>SWC client call to an Operation is performed by the RTE. In this mapping the RTE adds </p>
<p>Port Defined Argument Values to the client call of the SWC, if configured. </p>
<p>The  following  sub-chapters  present  the  Provide  Ports  defined  for  the  ECUM  and  the </p>
<p>Operations defined for the Provide Ports, the API functions related to the Operations and </p>
<p>the Port Defined Argument Values to be added by the RTE. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>92 / 117</p>
<p><b>5.7.1.1.1 StateRequest Port </b></p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>RequestRUN </p>
<p>EcuM_RequestRUN() </p>
<p>EcuM_UserType UserId </p>
<p>ReleaseRUN </p>
<p>EcuM_ReleaseRUN() </p>
<p>EcuM_UserType UserId </p>
<p>RequestPOSTRUN </p>
<p>EcuM_RequestPOST_RUN() </p>
<p>EcuM_UserType UserId </p>
<p>ReleasePOSTRUN </p>
<p>EcuM_ReleasePOST_RUN() </p>
<p>EcuM_UserType UserId </p>
<p>GetState </p>
<p>EcuM_GetStateWrapper() </p>
<p>EcuM_UserType UserId </p>
<p>Table 5-60 StateRequest Port </p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>The GetState runnable above is mapped to an additional API function </p>
<p>EcuM_GetStateWrapper()</p>
<p> which has to be introduced because of a specification </p>
<p>error of the ECUM. This API is not described in chapter 5.3 because the functionality is </p>
<p>the same as </p>
<p>EcuM_GetState()</p>
<p>, the only dif</p>
<p>ference is how the current state is given </p>
<p>back to the caller. </p>
<p>EcuM_GetStateWrapper()</p>
<p> returns the current state by reference </p>
<p>in its arguments. </p>
<p>The user does not have to care about which API name should be used. The generation </p>
<p>tools handle the correct API usage. </p>
<p><b> </b></p>
<p><b>5.7.1.1.2 ShutdownTarget Port </b></p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>SelectShutdownTarget </p>
<p>EcuM_SelectShutdownTarget() </p>
<p>- </p>
<p>GetLastShutdownTarget </p>
<p>EcuM_GetLastShutdownTarget()</p>
<p>- </p>
<p>GetShutdownTarget </p>
<p>EcuM_GetShutdownTarget() </p>
<p>- </p>
<p>Table 5-61 ShutdownTarget Port </p>
<p><b>5.7.1.1.3 BootTarget Port </b></p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>SelectBootTarget </p>
<p>EcuM_SelectBootTarget() </p>
<p>- </p>
<p>GetBootTarget </p>
<p>EcuM_GetBootTarget() </p>
<p>- </p>
<p>Table 5-62 BootTarget Port </p>
<p><b>5.7.1.1.4 ApplicationMode Port </b></p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>SelectApplicationMode </p>
<p>EcuM_SelectApplicationMode()</p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>93 / 117</p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>GetApplicationMode </p>
<p>EcuM_GetApplicationMode() </p>
<p>- </p>
<p>Table 5-63 ApplicationMode Port </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>For generating this service port the configuration tool needs a valid OS configuration </p>
<p>within the ECUC file. If no information about an OS is found, no service Port of this kind </p>
<p>will be generated even though the generation of ApplicationMode port is enabled in the </p>
<p>configuration tool (see 6.2.3). </p>
<p><b> </b></p>
<p><b>5.7.1.2 </b></p>
<p><b>Require Ports on ECUM side </b></p>
<p>At its Require Ports the ECUM calls Operations. These Operations have to be provided by </p>
<p>the SWCs by means of Runnable Entities. These Runnable Entities implement the </p>
<p>callback functions expected by the ECUM. </p>
<p> </p>
<p>The following sub-chapters present the Require Ports defined for the ECUM, the </p>
<p>Operations that are called from the ECUM and the related notifications, which are </p>
<p>described in chapter 5.6.3. </p>
<p><b>5.7.1.2.1 currentMode Port </b></p>
<p><b>Operation </b></p>
<p><b>Rte Interface </b></p>
<p><b>Mode Declaration Group </b></p>
<p>currentMode </p>
<p>Rte_Switch_currentMode_currentMode </p>
<p>STARTUP </p>
<p>RUN </p>
<p>POST_RUN </p>
<p>SLEEP </p>
<p>WAKE_SLEEP </p>
<p>SHUTDOWN </p>
<p>Table 5-64 currentMode Port </p>
<p><b>5.7.2 </b></p>
<p><b>Sender Receiver Interface </b></p>
<p>The ECUM does not provides any sender receiver interface </p>
<p><b>5.8 </b></p>
<p><b>Software Component Template </b></p>
<p>The  definition  of  the  Provide  Ports  is  described  in  an  XML  file.  This  file  describes  the </p>
<p>ECUM as a software component with ports to which other applications can connect.  </p>
<p><b>5.8.1 </b></p>
<p><b>Generation by EAD </b></p>
<p>The  XML  file  can  be  generated  by  MICROSAR  EAD  via  the  Menu  “Tools-&gt; AUTOSAR-</p>
<p>&gt;SW-C-&gt;EcuM”. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>94 / 117</p>
<p> </p>
<p>Figure 5-1 Generate an ECUM software component template </p>
<p><b>5.8.2 </b></p>
<p><b>Generation by DaVinci Configurator </b></p>
<p>The  XML  file  will  be  generated  in  each  generation  process  and  is  located  at  an  user </p>
<p>specified </p>
<p>location. </p>
<p>Please </p>
<p>consult </p>
<p>the </p>
<p>documentation </p>
<p>of </p>
<p>the </p>
<p>generation </p>
<p>tool </p>
<p>how </p>
<p>to </p>
<p>configure this path. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>95 / 117</p>
<p><b>5.8.3 </b></p>
<p><b>Import into DaVinci Developer </b></p>
<p>For further processing the generated software component template file has to be imported </p>
<p>into DaVinci Developer. This can be done while a DaVinci-project is open by clicking “File-</p>
<p>&gt;Import XML File...”. Choose the correct file for the import. </p>
<p> </p>
<p>Figure 5-2 Import a new software component into DaVinci Developer </p>
<p>After importing the ECUM as software component there is a new component type in the </p>
<p>library view available. After a double click on that component ECUM all configured ports </p>
<p>are presented. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>96 / 117</p>
<p><b>6 </b></p>
<p><b>Configuration </b></p>
<p>In the ECUM the attributes can be configured with the following tools: </p>
<p></p>
<p> </p>
<p>Configuration in DaVinci Configurator/EAD; for a detailed description see 6.2 </p>
<p></p>
<p> </p>
<p>Configuration with a Generic Configuration Editor. </p>
<p></p>
<p> </p>
<p>Configuration in GENy. </p>
<p><b>6.1 </b></p>
<p><b>Configuration Variants </b></p>
<p>The ECUM supports the configuration variants </p>
<p></p>
<p> </p>
<p>VARIANT-PRE-COMPILE </p>
<p></p>
<p> </p>
<p>VARIANT-POST-BUILD  </p>
<p>The configuration classes of the ECUM parameters depend on the supported configuration </p>
<p>variants. For their definitions please refer to the modules’ bswmd file which is part of the </p>
<p>delivered package. </p>
<p><b>6.2 </b></p>
<p><b>Configuration of ECUM with DaVinci Configurator/EAD </b></p>
<p>The ECUM is configured with the help of the configuration tool DaVinci Configurator/EAD. </p>
<p> </p>
<p><b>Info</b> </p>
<p>In case of object delivery modifications are without effect, if a parameter is specified as a </p>
<p>pre-compile value. Different object code is needed for different settings. Other object </p>
<p>files can be obtained at Vector Informatik. </p>
<p> </p>
<p><b>6.2.1 </b></p>
<p><b>Start configuration of the ECUM </b></p>
<p>The component name of the ECU State Manager in DaVinci Configurator/EAD is “EcuM”. </p>
<p>In the “Architecture view” (initial page) of the DaVinci Configurator/EAD, the EcuM can be </p>
<p>opened by its context menu to start its configuration. Optionally, the EcuM can be opened </p>
<p>for configuration with the component list under the “System” tab located at the left side of </p>
<p>the DaVinci Configurator/EAD. </p>
<p><b>6.2.2 </b></p>
<p><b>ECUM Configuration Perspective </b></p>
<p><b>6.2.2.1 </b></p>
<p><b>Node &quot;Startup&quot; </b></p>
<p><b>6.2.2.1.1 Node &quot;Used Module Configuration&quot; </b></p>
<p>This node represents the configuration options for modules which provide services used </p>
<p>by the ECUM. With the following child nodes the integrator has the possibility to specify </p>
<p>the header files of the used modules and if the module should be used by the ECUM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>97 / 117</p>
<p><b>6.2.2.1.2 Node &quot;Mcu&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Mcu Include File </p>
<p>header </p>
<p>file </p>
<p>include file; </p>
<p>default: </p>
<p><b>Mcu.h </b></p>
<p>In this FileEdit element select the MCU driver </p>
<p>include file. </p>
<p>Table 6-1   Node &quot;Mcu&quot; </p>
<p><b>6.2.2.1.3 Node &quot;WdgM&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use WdgM </p>
<p>boolean </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable/disable the use of the Watchdog </p>
<p>Manager. </p>
<p>WdgM Include File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>WdgM.h </b></p>
<p>In this FileEdit element select the WDGM </p>
<p>include file. </p>
<p>Table 6-2   Node &quot;WdgM&quot; </p>
<p><b>6.2.2.1.4 Node &quot;Nvm&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p> </p>
<p>Use NVRAM Manager </p>
<p>boolean </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable/disable the use of the NVRAM  </p>
<p>Manager. </p>
<p>Nvm Include File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>Nvm.h </b></p>
<p>In this FileEdit element select the NVM include </p>
<p>file. </p>
<p>Nvm Types File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>Nvm.h </b></p>
<p>Select the include file where the types of the </p>
<p>NVM are defined. </p>
<p>NvM_CancelWriteAll </p>
<p>Timeout </p>
<p>float </p>
<p>0.001..60 </p>
<p><b>60 </b></p>
<p>Contains the waiting time for ECUM in seconds. </p>
<p>It is the time which defines how long the ECUM </p>
<p>will wait for NVM before it cancels the </p>
<p>NvM_WriteAll</p>
<p> job and transits into ECU RUN </p>
<p>or power save state (depending from the </p>
<p>wakeup validation result). </p>
<p>Table 6-3   Node &quot;Nvm&quot; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>98 / 117</p>
<p><b>6.2.2.1.5 Node &quot;Dem&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use Dem </p>
<p>boolean </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable/disable the use of the DEM. </p>
<p>Dem Include File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>Dem.h </b></p>
<p>In this FileEdit element select the DEM include </p>
<p>file. </p>
<p>Table 6-4   Node &quot;Dem&quot; </p>
<p><b>6.2.2.1.6 Node &quot;Det&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Initialize Det </p>
<p>boolean </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable/disable the use of the DET. </p>
<p>Det Include File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>Det.h </b></p>
<p>In this FileEdit element select the DET include </p>
<p>file. </p>
<p>Table 6-5   Node &quot;Det&quot; </p>
<p><b>6.2.2.1.7 Node &quot;ComM&quot; </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>If COMM is enabled, then a valid configuration of the COMM must be present within </p>
<p>the ECUC file. The configuration/generation of the ECUM will not work as expected if </p>
<p>no configuration is available. </p>
<p><b> </b></p>
<p> </p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use COM Manager </p>
<p>boolean </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>This checkbox enables the use of the COM </p>
<p>Manager. </p>
<p>ComM Include File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>ComM.h </b></p>
<p>In this FileEdit element select the COM </p>
<p>Manager include file. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>99 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>ComM Callback File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>ComM_ </b></p>
<p><b>EcuM.h </b></p>
<p>In this FileEdit element select the call back </p>
<p>header file of the COM Manager. </p>
<p>Com Stack Types Include </p>
<p>File </p>
<p>header file </p>
<p>Include file; </p>
<p>default: </p>
<p>ComStack_T</p>
<p>ypes.h </p>
<p>This parameter specifies the name of the </p>
<p>include file of the basic type definitions for the </p>
<p>communication stack. </p>
<p>Table 6-6   Node &quot;ComM&quot; </p>
<p><b>6.2.2.1.8 Node &quot;Rte&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use Rte </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enable/disable the use of the Rte. </p>
<p>Rte Include File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>Rte_Main.h </b></p>
<p>In this FileEdit element select the Rte include </p>
<p>file. </p>
<p>Table 6-7   Node &quot;Rte&quot; </p>
<p><b>6.2.2.1.9 Node &quot;Os&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>EcuMDefaultApp Mode </p>
<p>AppMod</p>
<p>eType </p>
<p>Depends on </p>
<p>OS </p>
<p>configuration; </p>
<p>default: </p>
<p><b>OSDEFAULTA</b></p>
<p><b>PPMODE </b></p>
<p>This Edit field must be filled with the application </p>
<p>mode which should be used as default. </p>
<p>Os include name </p>
<p>header </p>
<p>file </p>
<p>include file; </p>
<p>default: </p>
<p><b>Os.h </b></p>
<p>Select with this FileEdit the name of the header </p>
<p>file of the OS. </p>
<p>Table 6-8   Node &quot;Os&quot; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>100 / 117</p>
<p><b>6.2.2.1.10  Node &quot;SchM&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use SchM </p>
<p>boolean </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enables/disable the use of the SCHM. </p>
<p>SchM include File </p>
<p>header file </p>
<p>include file; </p>
<p>default: </p>
<p><b>SchM.h </b></p>
<p>In this FileEdit element select the SCHM include </p>
<p>file. </p>
<p>Table 6-9   Node &quot;SchM&quot; </p>
<p><b>6.2.2.1.11  Node “Init Configuration Sets” </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Insert </p>
<p>-- </p>
<p>-- </p>
<p>Inserts a new configuration set item. </p>
<p>Delete </p>
<p>-- </p>
<p>-- </p>
<p>Deletes the selected configuration set item. </p>
<p>Module  </p>
<p>String </p>
<p>parameter </p>
<p>Depends on </p>
<p>the available </p>
<p>modules </p>
<p>within the </p>
<p>configuration </p>
<p>The Module short name of the module which </p>
<p>should be initialized. </p>
<p>ModuleRuntime </p>
<p>Reference </p>
<p>parameter </p>
<p>to a </p>
<p>configurati</p>
<p>on set </p>
<p>Depends on </p>
<p>the available </p>
<p>modules </p>
<p>within the </p>
<p>configuration </p>
<p>The corresponding configuration set which should </p>
<p>be used for the module initialization. </p>
<p>Table 6-10  Node “Init Configuration Sets” </p>
<p><b>6.2.2.1.12  Nodes &quot;EcuMDriverInitListOne&quot;, &quot;EcuMDriverInitListTwo&quot;, </b></p>
<p><b>“EcuMDriverInitListThree”, &quot;EcuMDriverRestartList&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Insert </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button inserts a new BSW module into the </p>
<p>table. </p>
<p>Delete </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button deletes the current selected BSW </p>
<p>module </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>101 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Move Up </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button moves the current selected BSW </p>
<p>module one row up. The order of the modules </p>
<p>influences the order in which the Init function will </p>
<p>be executed. </p>
<p>Move Down </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button moves the current selected BSW </p>
<p>module one row below. The order of the </p>
<p>modules influences the order in which the Init </p>
<p>function will be executed. </p>
<p>ModuleID (Table </p>
<p>column) </p>
<p>-- </p>
<p><b>-- </b></p>
<p><b>Code </b></p>
<p>In this combobox modules which are present in </p>
<p>the ecuc configuration file are displayed. Enter </p>
<p>the short name of the module to be initialized. </p>
<p>Enter the keyword “Code” here to enable the </p>
<p>field Code below. </p>
<p>ModuleID (Edit field) </p>
<p>-- </p>
<p><b>-- </b></p>
<p>Display of the current edited table item. </p>
<p>Init Function </p>
<p>C-function </p>
<p>identifier </p>
<p><b>-- </b></p>
<p><b> </b></p>
<p>This parameter specifies the Init function which </p>
<p>should be used for initialization of the </p>
<p>corresponding module. </p>
<p>Code </p>
<p>String </p>
<p>parameter </p>
<p><b>-- </b></p>
<p>This field allows adding extra code which is </p>
<p>necessary for the system initialization. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>It is not indented to use this </p>
<p>field as typical source code </p>
<p>editor. The insertion of one </p>
<p>line is proposed. </p>
<p><b> </b></p>
<p> </p>
<p>Table 6-11  Nodes “EcuMDriverInitListOne”, “EcuMDriverInitListTwo”, “EcuMDriverInitListThree”, “EcuMDriverRestartList” </p>
<p><b>6.2.2.1.13  Node Additional Includes </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Include file list </p>
<p>String </p>
<p>Paramet</p>
<p>er </p>
<p><b>-- </b></p>
<p>This parameter specifies additional files to be </p>
<p>included into EcuM_PBcfg.c, e.g. header files </p>
<p>where the Init() – functions are declared must </p>
<p>be specified here. </p>
<p>Table 6-12 Node &quot;Additional Includes&quot; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>102 / 117</p>
<p><b>6.2.2.2 </b></p>
<p><b>Node &quot;EcuM User&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Add User </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button adds a user of the ECU State </p>
<p>Manager which is able to request and release </p>
<p>RUN or POST RUN state. </p>
<p>Delete User </p>
<p>-- </p>
<p>-- </p>
<p>This button deletes the selected user of the </p>
<p>ECU State Manager. </p>
<p>Container Name </p>
<p>String </p>
<p>Paramet</p>
<p>er </p>
<p><b>EcuMUserCon</b></p>
<p><b>fig </b></p>
<p>Fill this field with unique ECU State Manager </p>
<p>user names.  </p>
<p>EcuMUserId </p>
<p>Integer </p>
<p>1..255 </p>
<p><b>1 </b></p>
<p>The ID of the corresponding user, this ID is the </p>
<p>port defined argument described in 5.7.1.1.1. </p>
<p>Table 6-13 Node &quot;EcuM User&quot; </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>For each configured user one service port will be defined. The name of the service port </p>
<p>corresponds exactly to the name provided here. </p>
<p><b> </b></p>
<p> </p>
<p><b>6.2.2.3 </b></p>
<p><b>Node &quot;Time settings&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Run Self Request Period </p>
<p>Float Unit </p>
<p>is second </p>
<p><b>0.100 </b></p>
<p>How long the self run request should last must </p>
<p>be filled in this Edit field expressed in seconds.</p>
<p>EcuM_ MainFunction() </p>
<p>Trigger Time </p>
<p>Float Unit </p>
<p>is second </p>
<p><b>0.010 </b></p>
<p>Select with this Edit the cycle time of the </p>
<p>EcuM_MainFunction()</p>
<p> in seconds. </p>
<p>Table 6-14 Node &quot;Time settings&quot; </p>
<p><b>6.2.2.4 </b></p>
<p><b>Node &quot;Wakeup&quot; </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Insert </p>
<p>-- </p>
<p>-- </p>
<p>This button adds a new wakeup source </p>
<p>Delete </p>
<p>-- </p>
<p>-- </p>
<p>This button deletes the selected wakeup </p>
<p>source. Per default five wakeup sources are </p>
<p>already inserted which it is not possible to </p>
<p>delete them. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>103 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Move Up </p>
<p>-- </p>
<p>-- </p>
<p>This button moves the selected entry one row </p>
<p>up. </p>
<p>Move Down </p>
<p>-- </p>
<p>-- </p>
<p>This button moves the selected entry down. </p>
<p>Wakeup Source Name </p>
<p>String </p>
<p>paramete</p>
<p>r </p>
<p>-- </p>
<p>This field should be filled with a valid name for </p>
<p>the wakeup source.  </p>
<p>Wakeup Source Id </p>
<p>Integer </p>
<p>-- </p>
<p>The ID of the corresponding wakeup source. </p>
<p>Validation Timeout </p>
<p>Float, </p>
<p>unit is </p>
<p>second </p>
<p><b>0.000 </b></p>
<p> </p>
<p>This parameter specifies the maximum </p>
<p>validation timeout for a wakeup source. If the </p>
<p>timeout expires the ECU is going into sleep </p>
<p>state. Wakeup sources which don’t need </p>
<p>validation must have a value of 0.  </p>
<p>ComM Channel handle </p>
<p>-- </p>
<p><b> </b></p>
<p>Select the ComM channel handle if the wakeup </p>
<p>source if a ComM channel.  If the wakeup </p>
<p>source is no communication channel don’t </p>
<p>select any value. </p>
<p>Mcu Reset Reason </p>
<p>Integer </p>
<p><b>-1 </b></p>
<p>(these values </p>
<p>depend on Mcu </p>
<p>module </p>
<p>implementation</p>
<p>) </p>
<p>This parameter describes the mapping of reset </p>
<p>reasons detected by the MCU driver into </p>
<p>wakeup sources.  </p>
<p>Please enter the value returned by </p>
<p>Mcu_GetResetReason() which should mapped </p>
<p>to the according wakeup source.  </p>
<p>Let this field free or enter &quot;-1&quot; if the value is </p>
<p>unknown.  </p>
<p>If no value is configured or &quot;-1&quot; is inserted the </p>
<p>reset reason will be mapped to </p>
<p>ECUM_WKSOURCE_RESET. </p>
<p>Table 6-15 Node &quot;Wakeup Sources&quot; </p>
<p><b>6.2.2.5 </b></p>
<p><b>WdgM Modes </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in </p>
<p>bold </p>
<p><b>Description </b></p>
<p>WdgM Post Run </p>
<p>Mode </p>
<p>Reference </p>
<p>to WDGM </p>
<p>mode </p>
<p><b>-- </b></p>
<p>This WDGM mode will be selected whenever POST RUN </p>
<p>state is entered. </p>
<p>WdgM Run Mode </p>
<p>Reference </p>
<p>to WDGM </p>
<p>mode </p>
<p><b>-- </b></p>
<p>This WDGM mode will be selected whenever RUN state </p>
<p>is entered. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>104 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in </p>
<p>bold </p>
<p><b>Description </b></p>
<p>WdgM Shutdown </p>
<p>Mode </p>
<p>Reference </p>
<p>to WDGM </p>
<p>mode </p>
<p><b>-- </b></p>
<p>This WDGM mode will be selected whenever </p>
<p>SHUTDOWN phase is entered. </p>
<p>WdgM Wakeup </p>
<p>Mode </p>
<p>Reference </p>
<p>to WDGM </p>
<p>mode </p>
<p><b>-- </b></p>
<p>This WDGM mode will be selected whenever WAKEUP </p>
<p>VALIDATION state is entered. </p>
<p>Table 6-16  Node “WdgM Modes” </p>
<p><b>6.2.2.6 </b></p>
<p><b>Node “Sleep Modes” </b></p>
<p>This Node does not directly display any configuration possibilities. A right click on this node </p>
<p>will open a context menu, where sleep modes can be configured. The new configuration </p>
<p>will be shown as a child node of “Sleep Modes”.  </p>
<p>A  right  click  on  the  child  node  opens  a  context  menu,  where  items  can  be  deleted  or </p>
<p>renamed. </p>
<p><b>6.2.2.7 </b></p>
<p><b>Child Nodes of “Sleep Modes” </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Name </p>
<p>-- </p>
<p><b>-- </b></p>
<p>Display the name of the current sleep mode </p>
<p>configuration </p>
<p>EcuMSleepModeId </p>
<p>Integer </p>
<p><b>0 </b></p>
<p>0..255 </p>
<p>This parameter specifies the ID of the sleep </p>
<p>mode. </p>
<p>Mcu Mode </p>
<p>-- </p>
<p>Depends on </p>
<p>MCU </p>
<p>configuration </p>
<p>This parameter specifies the MCU mode which </p>
<p>should the ECUM select when the sleep mode </p>
<p>is entered. </p>
<p>WdgM mode </p>
<p>-- </p>
<p>Depends on </p>
<p>WDGM </p>
<p>configuration </p>
<p>This parameter specifies the WDGM mode </p>
<p>which should be selected by the ECUM when </p>
<p>the sleep mode is entered. </p>
<p>Enabled Wakeup Sources</p>
<p>-- </p>
<p>Depends on </p>
<p>configured </p>
<p>wakeup </p>
<p>sources </p>
<p>This parameter specifies the wakeup sources </p>
<p>which should be enabled when the sleep mode </p>
<p>is selected. </p>
<p>Table 6-17 Child Nodes of “Sleep Modes” </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>105 / 117</p>
<p><b>6.2.2.8 </b></p>
<p><b>Node “TTII” </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in </p>
<p>bold </p>
<p><b>Description </b></p>
<p>Enable TTII </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>This checkbox enables the use of the TTII protocol. </p>
<p>TTII Wakeup Source </p>
<p>Reference </p>
<p>parameter </p>
<p>to </p>
<p>configured </p>
<p>wakeup </p>
<p>sources </p>
<p>Depends </p>
<p>on the </p>
<p>wakeup </p>
<p>source </p>
<p>configura</p>
<p>tion. </p>
<p>Default: </p>
<p><b>ECUM_</b></p>
<p><b>WKSOU</b></p>
<p><b>RCE_PO</b></p>
<p><b>WER </b></p>
<p>Select in this DropDownList the wakeup source which </p>
<p>should act as wakeup source for TTII.  </p>
<p><b> </b></p>
<p><b>Info</b> </p>
<p>The selected wakeup </p>
<p>source should be a </p>
<p>timer. </p>
<p><b> </b></p>
<p> </p>
<p>Insert </p>
<p>-- </p>
<p>-- </p>
<p>This Button inserts a new successor sleep mode for TTII </p>
<p>use. </p>
<p>Delete </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This Button deletes the selected sleep mode from the </p>
<p>table. </p>
<p>EcuMSuccessor </p>
<p>Reference </p>
<p>parameter </p>
<p>to </p>
<p>configured </p>
<p>sleep </p>
<p>modes. </p>
<p>Depends </p>
<p>on the </p>
<p>sleep </p>
<p>mode </p>
<p>configura</p>
<p>tion. </p>
<p>A click into the field opens a DropDownList of the </p>
<p>configured sleep mode. Select one from the list. The TTII </p>
<p>will use each sleep mode from top to bottom in this list.  </p>
<p>Therefore order this list from more power consuming to </p>
<p>less power consuming. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The integrator has the </p>
<p>responsibility to order </p>
<p>this list from more </p>
<p>power consuming to </p>
<p>less power consuming. </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>EcuMDivisor </p>
<p>Integer </p>
<p>1 </p>
<p>This field must be filled with the divisor value for this </p>
<p>sleep mode. </p>
<p>Table 6-18 Node “TTII” </p>
<p><b>6.2.2.9 </b></p>
<p><b>Node “Shutdown” </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Default State </p>
<p>EcuM_</p>
<p>StateTy</p>
<p>pe </p>
<p>Sleep </p>
<p><b>Reset </b></p>
<p>Off </p>
<p>This parameter specifies the default shutdown target </p>
<p>state. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>106 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Default Sleep Mode </p>
<p>-- </p>
<p> </p>
<p>This parameter specifies the sleep mode which should </p>
<p>be selected when the default shutdown target state is </p>
<p>“Sleep”. </p>
<p>Table 6-19 Node “Shutdown” </p>
<p><b>6.2.3 </b></p>
<p><b>General Settings Perspective </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in bold</p>
<p><b>Description </b></p>
<p>Enable Development </p>
<p>Error Detection </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>It is the main switch over following buttons: </p>
<p></p>
<p> </p>
<p>Check Parameter </p>
<p></p>
<p> </p>
<p>Check Uninit </p>
<p></p>
<p> </p>
<p>Det Errorhook include file </p>
<p></p>
<p> </p>
<p>Det Errorhook Function </p>
<p>The checks simplify the search for errors. In production </p>
<p>mode, this switch should be disabled to save RAM and to </p>
<p>speed up the module. </p>
<p>Check Parameter </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>This check is the main switch over: </p>
<p></p>
<p> </p>
<p>Check Pointer Parameter </p>
<p></p>
<p> </p>
<p>Check State Parameter </p>
<p></p>
<p> </p>
<p>Check Wakeup Source Parameter </p>
<p></p>
<p> </p>
<p>Check BootTarget Parameter </p>
<p></p>
<p> </p>
<p>Check SleepMode Parameter </p>
<p></p>
<p> </p>
<p>Check User Parameter </p>
<p></p>
<p> </p>
<p>Check ConfigType </p>
<p>Check Pointer </p>
<p>Parameter </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If the check is activated, it will be verified that a pointer </p>
<p>parameter is not equal to </p>
<p>NULL_PTR</p>
<p>. </p>
<p>Check State </p>
<p>Parameter </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If the check is activated, it will be verified that a </p>
<p>parameter of type EcuM_StateType is within the </p>
<p>expected range. </p>
<p>Check Wakeup </p>
<p>Source Parameter </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If the check is activated, it will be verified that a </p>
<p>parameter of Type EcuM_WakeupSourceType is within </p>
<p>the expected range. </p>
<p>Check BootTarget </p>
<p>Parameter </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If the check is activated, it will be verified that a </p>
<p>parameter of Type EcuM_BootTargetType is within the </p>
<p>expected range. </p>
<p>Check SleepMode </p>
<p>Parameter </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If the check is activated, it will be verified that a </p>
<p>parameter of Type EcuM_SleepModeType is within the </p>
<p>expected range. </p>
<p>Check User </p>
<p>Parameter </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If the check is activated, it will be verified that a </p>
<p>parameter of Type EcuM_UserType is within the </p>
<p>expected range. </p>
<p>Check ConfigType </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>If the check is activated, it will be verified that the </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>107 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in bold</p>
<p><b>Description </b></p>
<p>OFF </p>
<p>configuration structure of ECUM is not a </p>
<p>NULL_PTR</p>
<p>. </p>
<p>Det Errorhook </p>
<p>Function </p>
<p>C-</p>
<p>function </p>
<p>identifier </p>
<p>Valid C-</p>
<p>function </p>
<p>identifier, </p>
<p>default: </p>
<p><b>Det_Repo</b></p>
<p><b>rtError  </b></p>
<p>Defines the function that is to be called in case of a </p>
<p>Development Error. </p>
<p>Det Include File </p>
<p>header </p>
<p>file </p>
<p>Valid </p>
<p>header file, </p>
<p>default: </p>
<p><b>Det.h </b></p>
<p>Include this header to get the declaration of </p>
<p>Det_ReportError</p>
<p>. </p>
<p>Enable Production </p>
<p>Error Reporting </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enable this identifier in production mode, for reporting </p>
<p>production’s errors. </p>
<p>Dem Errorhook </p>
<p>function </p>
<p>C-</p>
<p>function </p>
<p>identifier </p>
<p>Valid C-</p>
<p>function </p>
<p>identifier, </p>
<p>default: </p>
<p><b>Dem_ </b></p>
<p><b>ReportErr</b></p>
<p><b>orStatus </b></p>
<p>Defines the function that is to be called in case of a </p>
<p>production error. </p>
<p>Dem Errorhook </p>
<p>include file </p>
<p>header </p>
<p>file </p>
<p>Valid </p>
<p>header file, </p>
<p>default: </p>
<p><b>Dem.h </b></p>
<p>Select the name of the include file where the used DEM </p>
<p>is declared. </p>
<p>Critical Section </p>
<p>Handling </p>
<p>-- </p>
<p><b>UseSuspe</b></p>
<p><b>ndFunctio</b></p>
<p><b>ns </b></p>
<p>UseOSFun</p>
<p>ctions </p>
<p>UseEnable</p>
<p>Functions </p>
<p>Specifies the function set that shall be called when critical </p>
<p>sections are entered or left. </p>
<p><b>Info</b> </p>
<p>This dropdown list is </p>
<p>disabled if the BSW </p>
<p>Scheduler is enabled </p>
<p>within the OS </p>
<p>configuration tab of </p>
<p>the ECU </p>
<p>configuration. Hence, </p>
<p>the functions of the </p>
<p>Schedule Manager </p>
<p>are used by the ECU </p>
<p>State Manager to </p>
<p>protect the critical </p>
<p>sections. </p>
<p> </p>
<p><b> </b></p>
<p>Generate </p>
<p>StateRequest Ports </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enables the generation of StateRequest Ports. If enabled </p>
<p>for each ECUM user a StateRequest port will be </p>
<p>generated. </p>
<p>Generate </p>
<p>ApplicationMode </p>
<p>Port </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enables the generation of the ApplicationMode Port. If </p>
<p>enabled one Port of this kind will be generated. </p>
<p>Generate BootTarget </p>
<p>Port </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enables the generation of the BootTarget Port. If enabled </p>
<p>one Port of this kind will be generated. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>108 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in bold</p>
<p><b>Description </b></p>
<p>Generate </p>
<p>ShutdownTarget Port </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enables the generation of the ShutdownTarget Port. If </p>
<p>enabled one Port of this kind will be generated. </p>
<p>Generate Current </p>
<p>Mode Port </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>This parameter enables the generation of the </p>
<p>EcuM_CurrentMode sender-receiver interface within the </p>
<p>SW-C description and the usage of a callback function </p>
<p>for mode switch notification.  </p>
<p>The used notification function depends on the ECUM </p>
<p>parameter EcuMIncludeRte:  </p>
<p></p>
<p> </p>
<p>If this parameter is set to ON the ECUM will use the </p>
<p>provided </p>
<p>RTE </p>
<p>function </p>
<p>Rte_Switch_currentMode_currentMode().  </p>
<p></p>
<p> </p>
<p>If  the  parameter  EcuMIncludeRte  is  set  to  OFF  the </p>
<p>callback </p>
<p>function </p>
<p>EcuM_Appl_currentMode_currentMode() will be used </p>
<p>to notify mode switch event.</p>
<p> </p>
<p>Enables the </p>
<p>Acknowledge </p>
<p>Mechanism </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>This parameter enables the feedback mechanism from </p>
<p>RTE. The ECUM leaves its main states (RUN, </p>
<p>POST_RUN, GO_SLEEP and GO_OFF_ONE) only in </p>
<p>case the RTE achieves the current state and has </p>
<p>informed the ECUM about it by sending a feedback. </p>
<p>This parameter is dependent from “Generate Current </p>
<p>Mode Port” parameter. </p>
<p> </p>
<p><b>Info</b> </p>
<p>This parameter is used for </p>
<p>synchronization between RTE </p>
<p>and ECUM. </p>
<p> </p>
<p>Service Component </p>
<p>Name </p>
<p>-- </p>
<p>service </p>
<p>component</p>
<p>'s name; </p>
<p>default: </p>
<p><b>EcuM </b></p>
<p>In this field specify the Name of the service component </p>
<p>which will be displayed in the Rte generation tool. </p>
<p> </p>
<p><b>Info</b> </p>
<p>Please choose different names of </p>
<p>the service component ECUM if </p>
<p>one DaVinci project has more </p>
<p>than one ECUM. </p>
<p> </p>
<p>Sleep mode ISR </p>
<p>handling </p>
<p> </p>
<p>-- </p>
<p> </p>
<p>This parameter should reference an appropriate function </p>
<p>set which disables/enables the global interrupts. </p>
<p> </p>
<p> </p>
<p><b>Caution</b> </p>
<p>Do not use an OS function for </p>
<p>this parameter </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>109 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in bold</p>
<p><b>Description </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This parameter is ECU specific </p>
<p>and depends strongly on the </p>
<p>used platform. </p>
<p>No transformation of the value of </p>
<p>this parameter will be performed, </p>
<p>i.e. the user is responsible to </p>
<p>enter the correct syntax of this </p>
<p>parameter. </p>
<p> </p>
<p>Table 6-20 General Settings </p>
<p><b>6.2.4 </b></p>
<p><b>Module API Perspective </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The </p>
<p>default </p>
<p>value is </p>
<p>written in </p>
<p>bold </p>
<p><b>Description </b></p>
<p>Enable </p>
<p>EcuM_GetVersion </p>
<p>Info </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>EcuM_GetVersionInfo()</p>
<p> use will be enabled. </p>
<p>Enable </p>
<p>EcuM_KillAllRUN </p>
<p>Requests </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>EcuM_KillAllRUNRequest()</p>
<p> use will be enabled </p>
<p>Enable </p>
<p>EcuM_GetValidated</p>
<p>WakeupEvents </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>EcuM_GetValidatedWakeupEvents()</p>
<p> use will be </p>
<p>enabled </p>
<p>Enable </p>
<p>EcuM_GetExpired </p>
<p>WakeupEvents </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>EcuM_GetExpiredWakeupEvents()</p>
<p> use will be enabled </p>
<p>Enable </p>
<p>EcuM_GetStatusOf </p>
<p>WakeupSource </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>EcuM_GetStatusOfWakeupSource()</p>
<p> use will be enabled</p>
<p>Table 6-21 Module API </p>
<p><b>6.2.5 </b></p>
<p><b>Module Callouts Perspective </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Enable </p>
<p>EcuM_OnRTE </p>
<p>Startup </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnRTEStartup()</p>
<p> will be </p>
<p>enabled.. </p>
<p>Enable </p>
<p>EcuM_OnEnterRun </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnEnterRun()</p>
<p> will be enabled. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>110 / 117</p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Enable </p>
<p>EcuM_OnExitRun </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnExitRun()</p>
<p> will be enabled. </p>
<p>Enable </p>
<p>EcuM_OnExitPost </p>
<p>Run </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnExitPostRun()</p>
<p> will be </p>
<p>enabled. </p>
<p>Enable </p>
<p>EcuM_OnPrep </p>
<p>Shutdown </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnPrepShutdown()</p>
<p> will be </p>
<p>enabled. </p>
<p>Enable </p>
<p>EcuM_OnGoSleep </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnGoSleep()</p>
<p> will be enabled. </p>
<p>Enable </p>
<p>EcuM_OnGoOffOne </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnGoOffOne()</p>
<p> will be enabled. </p>
<p>Enable </p>
<p>EcuM_OnGoOffTwo </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnGoOffTwo()</p>
<p> will be enabled. </p>
<p>Enable </p>
<p>EcuM_OnWakeupRe</p>
<p>action </p>
<p>boolean </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use of callout </p>
<p>EcuM_OnWakeupReaction()</p>
<p> will be </p>
<p>enabled. </p>
<p>Enable </p>
<p>EcuM_GeneratorCo</p>
<p>mpatibilityError </p>
<p>boolean </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Use of callout </p>
<p>EcuM_GeneratorCompatibilityError()</p>
<p> will be </p>
<p>enabled. </p>
<p>Table 6-22 Module Callouts </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>111 / 117</p>
<p><b>7 </b></p>
<p><b>AUTOSAR Standard Compliance </b></p>
<p><b>7.1 </b></p>
<p><b>Deviations </b></p>
<p><b>7.1.1 </b></p>
<p><b>Service Port Generation </b></p>
<p>Export of SWC Description assumes an AppModeType with 8 bit data width (uint8). </p>
<p><b>7.1.2 </b></p>
<p><b>Supervised Entity in WDGM </b></p>
<p>The configuration of the ECUM as a supervised entity of the WDGM is not supported. </p>
<p><b>7.1.3 </b></p>
<p><b>Parameter “EcuMWdgMStartupModeRef” not supported </b></p>
<p>The configuration parameter EcuMWdgMStartupModeRef is not supported.  </p>
<p><b>7.1.4 </b></p>
<p><b>Signature and name of DriverInitLists in configuration variant “post-build” </b></p>
<p>The method signature of the callouts  </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverInitOne() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverInitTwo() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverInitThree() </p>
<p></p>
<p> </p>
<p>EcuM_AL_DriverRestart() </p>
<p>are different as specified in [1] to provide more flexibility and library capability. </p>
<p>These  callouts  are  replaced  by  function  pointers  stored  in  the  EcuM_ConfigType.  The </p>
<p>configuration is transparent to the user. </p>
<p><b>7.1.5 </b></p>
<p><b>Enabling/Disabling wakeup sources </b></p>
<p>The  callout  EcuM_EnableWakeupSources()  is  executed  whenever  RUN  state  is  left  and </p>
<p>shutdown target is ECUM_STATE_SLEEP or ECUM_STATE_OFF. </p>
<p>The callout EcuM_DisableWakeupSources() is executed whenever RUN state is entered </p>
<p>and the shutdown target is ECUM_STATE_SLEEP or ECUM_STATE_OFF. </p>
<p><b>7.1.6 </b></p>
<p><b>Execution flow in shutdown sequence </b></p>
<p>The ECUM SWS specifies the following execution flow when shutdown target ECUM_-</p>
<p>STATE_OFF is selected: </p>
<p> </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p></p>
<p> </p>
<p>Rte_Stop() </p>
<p></p>
<p> </p>
<p>ComM_DeInit() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>Wait until NvM_WriteAll() has finished. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>112 / 117</p>
<p></p>
<p> </p>
<p>ShutdownOS() </p>
<p> </p>
<p>To enable a fast reaction time for wakeup events while NVRAM data is written this ECUM </p>
<p>implementation </p>
<p>changed </p>
<p>this </p>
<p>execution </p>
<p>flow </p>
<p>into </p>
<p>the </p>
<p>following </p>
<p>sequence: </p>
<p> </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>Wait until NvM_WriteAll() has finished </p>
<p></p>
<p> </p>
<p>Rte_Stop() </p>
<p></p>
<p> </p>
<p>ComM_DeInit() </p>
<p></p>
<p> </p>
<p>ShutdownOS() </p>
<p><b>7.2 </b></p>
<p><b>Additions/ Extensions </b></p>
<p><b>7.2.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>The  internal  parameter  checks  of  the API  functions  can  be  en-/disabled  separately. The </p>
<p>AUTOSAR standard requires en-/disabling of the complete parameter checking only. For </p>
<p>details see chapter 3.6.1.1. </p>
<p><b>7.2.2 </b></p>
<p><b>State Request service port </b></p>
<p>The ECUM provides an additional operation in the StateRequest port. The current state of </p>
<p>the ECUM can be retrieved by the GetState operation. </p>
<p><b>7.2.3 </b></p>
<p><b>Wakeup validation in each state </b></p>
<p>This ECUM implementation provides the possibility to perform a wakeup validation in each </p>
<p>state, especially the validation of communication channels while ECUM is in RUN state. </p>
<p><b>7.2.4 </b></p>
<p><b>Callout EcuM_GeneratorCompatibilityError() </b></p>
<p>This callout is additional to the AUTOSAR standard. Further information can be found in </p>
<p>chapter 5.6.2.25. </p>
<p><b>7.2.5 </b></p>
<p><b>Buffering of wakeup events until COMM is initialized </b></p>
<p>The  ECUM  buffers  wakeup  events  until  it  is  assured  that  COMM  is  initialized.  Wakeup </p>
<p>events  on  communication  channels  are  propagated  to  COMM  module.  The  AUTOSAR </p>
<p>standard can not require that COMM module is already initialized when a wakeup event </p>
<p>occur  in  startup  phase,  because  of  the  different  initialization  phases  and  component </p>
<p>modularization. </p>
<p>After </p>
<p>finishing </p>
<p>DriverInitListThree</p>
<p> </p>
<p>all </p>
<p>wakeup </p>
<p>events </p>
<p>on </p>
<p>communication channels are reported to COMM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>113 / 117</p>
<p><b>7.3 </b></p>
<p><b>Limitations </b></p>
<p><b>7.3.1 </b></p>
<p><b>Link-time Configuration not supported </b></p>
<p>The ECUM module supports only post-build and pre-compile configuration. </p>
<p><b>7.3.2 </b></p>
<p><b>Configuration Check via Consistency Hash not implemented </b></p>
<p>The  consistency  check  as  proposed  by  AUTOSAR  is  not  implemented  because  this </p>
<p>feature is not clearly stated enough.  </p>
<p><b>7.3.3 </b></p>
<p><b>Not implemented Callouts </b></p>
<p>The </p>
<p>callouts </p>
<p>EcuM_Errorhook()</p>
<p> </p>
<p>and </p>
<p>EcuM_SleepActivity()</p>
<p> </p>
<p>are </p>
<p>currently </p>
<p>not </p>
<p>supported. </p>
<p><b>7.3.4 </b></p>
<p><b>References in ECUC File </b></p>
<p>The ECUM uses references within the ECUC file. If one of the referenced modules does </p>
<p>not support the ECUC file the DaVinci Configurator/EAD generates a warning. Referenced </p>
<p>modules are: OS, COMM, WDGM, MCU and BSW modules which should be initialized. </p>
<p><b>7.3.5 </b></p>
<p><b>Not supported configuration parameters </b></p>
<p>Some of the specified configuration parameters are not supported. These parameters are </p>
<p>marked  with  the  addition  “Not  used”  in  the  corresponding  parameter  description.  The </p>
<p>description is located within the modules bswmd file which is part of the delivery. </p>
<p><b>7.3.6 </b></p>
<p><b>Polling of Wakeup Sources Is Not Supported </b></p>
<p>This ECUM implementation does not support the polling of wakeup sources, i.e. the callout </p>
<p>EcuM_CheckWakeup()  will  not  be  executed  by  the  ECUM  itself  to  query  the  wakeup </p>
<p>sources if a wakeup event has occurred. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>114 / 117</p>
<p><b>8 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>8.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>EAD </p>
<p>Embedded Architecture Designer; generation tool for MICROSAR </p>
<p>components </p>
<p>DaVinci </p>
<p>The DaVinci Tool Suite is a design environment for the development of </p>
<p>distributed electronic systems in the automotive domain. It consists of </p>
<p>several tools, which may be used standalone or in combination. The </p>
<p>DaVinci Tool Suite provides you with a seamless support throughout the </p>
<p>development process. The functionality goes from design of distributed </p>
<p>functions to the definition of network communication to the application </p>
<p>development, configuration and generation (since DaVinci Configurator </p>
<p>Pro) of networked ECUs. </p>
<p>For each working step a dedicated tool is available: </p>
<p><b>Tool </b></p>
<p><b>Description </b></p>
<p>DaVinci System Architect </p>
<p>With DaVinci System Architect you may </p>
<p>define the distributed SW architecture of </p>
<p>vehicles according to the AUTOSAR </p>
<p>methodology. </p>
<p>DaVinci Network Designer </p>
<p> </p>
<p>With the DaVinci Network Designer tools </p>
<p>you design the network architecture of the </p>
<p>vehicles and the data communication on </p>
<p>the networks. The networking data are the </p>
<p>base for subsequent development steps </p>
<p>like system simulation, configuration of the </p>
<p>ECU software as well as ECU and system </p>
<p>integration tests. </p>
<p>DaVinci Developer  </p>
<p> </p>
<p>During the ECU development you may use </p>
<p>DaVinci Developer to design AUTOSAR </p>
<p>compliant applications and to integrate </p>
<p>them based on an AUTOSAR RTE (runtime </p>
<p>environment). </p>
<p>DaVinci Configurator Pro </p>
<p>For MICROSAR components configuration </p>
<p>and generation you may use the DaVinci </p>
<p>Configurator Pro. It is the successor from </p>
<p>EAD. </p>
<p> </p>
<p>DriverInitList </p>
<p>A list of basic software init functions which are executed by the EcuM in </p>
<p>the startup phase. The ECUM provides four DriverInitList’s:  </p>
<p></p>
<p> </p>
<p>EcuMDriverInitListZero </p>
<p></p>
<p> </p>
<p>EcuMDriverInitListOne </p>
<p></p>
<p> </p>
<p>EcuMDriverInitListTwo </p>
<p></p>
<p> </p>
<p>EcuMDriverInitListThree </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>115 / 117</p>
<p>MSN </p>
<p>Module Short name, the AUTOSAR short name of the module, e.g. Can, </p>
<p>CanIf, EcuM, etc… </p>
<p>GENy </p>
<p>Generation tool for CANbedded and MICROSAR components </p>
<p>Configuration Tool </p>
<p>Could be EAD, DaVinci Configurator or GENy in this document. </p>
<p>Table 8-1   Glossary </p>
<p><b>8.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>CAN </p>
<p>Controller Area Network </p>
<p>COMM </p>
<p>Communication Manager </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>EAD </p>
<p>Embedded Architecture Designer </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>EcuC </p>
<p>ECU configuration description </p>
<p>ECUM </p>
<p>ECU Manager </p>
<p>GPT </p>
<p>General Purpose Timer </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>ICU </p>
<p>Input Capture Unit </p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>MCU </p>
<p>Microprocessor Control Unit </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR </p>
<p>solution) </p>
<p>NVM </p>
<p>NVRAM Manager </p>
<p>NVRAM </p>
<p>Non Volatile Random Access Memory </p>
<p>OS </p>
<p>Operating System </p>
<p>Pport </p>
<p>Provide Port </p>
<p>Rport </p>
<p>Require Port </p>
<p>RTE </p>
<p>Runtime Environment </p>
<p>SCHM </p>
<p>Scheduling Manager </p>
<p>SRS </p>
<p>Software Requirement Specification </p>
<p>SWC </p>
<p>Software Component </p>
<p>SWS </p>
<p>Software Specification </p>
<p>WDGM </p>
<p>Watchdog Manager </p>
<p>PLL </p>
<p>Phase-locked loop </p>
<p>TTII </p>
<p>Time Triggered Increased Inoperation </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>116 / 117</p>
<p>MSN </p>
<p>Module Short Name </p>
<p>Table 8-2   Abbreviations </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR ECUM  </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 2.07.02 </p>
<p>based on template version 3.1 </p>
<p>117 / 117</p>
<p><b>9 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector-informatik.com </b></p>
<p> </p>
<p> </p>
</body>
</html>
{% endraw %}