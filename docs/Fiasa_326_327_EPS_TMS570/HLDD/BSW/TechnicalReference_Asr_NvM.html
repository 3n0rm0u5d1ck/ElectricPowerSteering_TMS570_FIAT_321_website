---
layout: default
title: TechnicalReference_Asr_NvM
nav_order: 25
parent: Fiasa_326_327_EPS_TMS570
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR NVM </b></p>
<p>Technical Reference </p>
<p> </p>
<p> </p>
<p>Version 3.07.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Manfred Duschinger </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>1 </b></p>
<p><b>Document Information </b></p>
<p><b>1.1 </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Christian Kaiser </p>
<p>2007-08-20 </p>
<p>1.4 </p>
<p>AUTOSAR 2.1, </p>
<p>updated for EAD3.1 usage, </p>
<p>conversion to new template   </p>
<p>Christian Kaiser </p>
<p>2007-12-06 </p>
<p>3.01.00 </p>
<p>Change of the document's versioning </p>
<p>scheme to correspond to the module's </p>
<p>major and minor, </p>
<p>update of parameter description in </p>
<p>chapter 'Graphical Configuration of NvM' </p>
<p>and service port generation description, </p>
<p>remove of DATASET ROM, feature not </p>
<p>supported anymore, </p>
<p>remove of introduction paragraphs from </p>
<p>'Description of Memory Mapping and </p>
<p>Compiler Abstraction', not subject of this </p>
<p>document, </p>
<p>simplified 'Block Management Types' </p>
<p>naming, </p>
<p>formal changes    </p>
<p>Christian Kaiser </p>
<p>2008-01-11 </p>
<p>3.01.01 </p>
<p>New chapter to clarify the dependency on </p>
<p>the CRC library, </p>
<p>stated explicitly that DET is optional, </p>
<p>corrected default values   </p>
<p>Manfred Duschinger, </p>
<p>Heike Bischof </p>
<p>2008-05-23 </p>
<p>3.02.00 </p>
<p>AUTOSAR 3, </p>
<p>conversion to Technical Reference </p>
<p>Manfred Duschinger </p>
<p>2008-12-08 </p>
<p>3.03.00 </p>
<p>ESCAN00027300: Description of </p>
<p>NvM_ServiceIdType </p>
<p>in </p>
<p>SingleBlockCallbackFunction and </p>
<p>MultiBlockCallbackFunction </p>
<p>Description and expected caller context </p>
<p>of NvM_SetBlockLockStatus-API </p>
<p>reworked. </p>
<p>Chapter 4.4.17 ‘Concurrent access to NV </p>
<p>data for DCM’ added. </p>
<p>Chapter 4.4.5.2: Write order at redundant </p>
<p>blocks added. </p>
<p>Expansion of glossary. </p>
<p>Chapter 7.2.2: Description of ‘Dataset </p>
<p>Selection Bits’ added. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>2 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Manfred Duschinger </p>
<p>2009-02-25 </p>
<p>3.03.01 </p>
<p>ESCAN00031177: Manufacturer specific </p>
<p>requirements attribute for traceability </p>
<p>resons </p>
<p>Manfred Duschinger </p>
<p>2009-03-24 </p>
<p>3.03.02 </p>
<p>ESCAN00032480: Missing information in </p>
<p>documentation: </p>
<p>Chapter 6.4.5: ‘Description of </p>
<p>NvM_RequestResultType added’. </p>
<p>Chapters 6.4.15 and 6.4.16: ‘Services are </p>
<p>multiblock requests’. </p>
<p>Manfred Duschinger </p>
<p>2009-06-03 </p>
<p>3.04.00 </p>
<p>ESCAN00032480: Update of History of </p>
<p>version 3.03.02: Updated changed </p>
<p>chapters.  </p>
<p>Chapter  6.2: ‘Block ID 0 is only allowed </p>
<p>for API NvM_GetErrorStatus()’ </p>
<p>ESCAN00033075: Chapter 4.5.1.1: </p>
<p>DataIndex Check in NvM_ReadBlock() </p>
<p>added. DataIndex Check was also added </p>
<p>to NvM_InvalidateNvBlock() and </p>
<p>NvM_EraseNvBlock(). </p>
<p>ESCAN00033900: Chapter 4.4.17: </p>
<p>“Priority Handling of DCM-Blocks” </p>
<p>ESCAN00035089: Chapters 4.1, 7.2.2 </p>
<p>“Callbacks NvM_JobEndNotification, </p>
<p>NvM_JobErrorNotification implemented” </p>
<p>ESCAN00034073: Chpaters 2, 4.4.5.1, </p>
<p>7.2.2 “Crc Handling is configurable: Either </p>
<p>an internal buffer is used or Crc is stored </p>
<p>at the end of RAM Block.” </p>
<p>ESCAN00035891: Chapter 7.1.1 </p>
<p>“Integrate SWC-Generation into CFG </p>
<p>Pro's Generation process” </p>
<p>Chapter 3.1: update AUTOSAR </p>
<p>architecture figure. </p>
<p>Christian Kaiser </p>
<p>2010-01-25 </p>
<p>3.04.01 </p>
<p>ESCAN00039648 – Rebuilt document; </p>
<p>made hyperlinks working. Updated Logo; </p>
<p>No changes in content. </p>
<p>Christian Kaiser </p>
<p>2010-03-26 </p>
<p>3.05.00 </p>
<p>Updated Component history </p>
<p>Whole document: “EAD” </p>
<p>Æ</p>
<p> “DaVinci </p>
<p>Configurator” </p>
<p>Added Ch. 7.3 “Attributes only </p>
<p>configurable using GCE” </p>
<p>Updated Ch. 5.6.1 – “RAM Usage” </p>
<p>ESCAN00040662: Chapter 4.4.3: Added </p>
<p>note about restricted access to RAM </p>
<p>block during job execution. </p>
<p>ESCAN00035134: Chapter 5.1.2 </p>
<p>reworked </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>3 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>ESCAN00039749: Ch. 4.4.10, 8.2.4: </p>
<p>Guaranteed CRC values; Ch 6.4.7: note </p>
<p>about asynchronous CRC calculation </p>
<p>ESCAN00031315: added Ch. 4.2.1, Ch  </p>
<p>8.2.3; updated Ch. 7.2.5 </p>
<p>ESCAN00042745 – corrected Ch. 4.5.2 </p>
<p>Manfred Duschinger </p>
<p>2011-01-25 </p>
<p>3.07.00 </p>
<p>ESCAN00047171: Ch. 6.4.18: </p>
<p>NvM_KillWriteAll; Abbreviations: ECUM </p>
<p>ESCAN00045141: Ch. 4.4.5.1: </p>
<p>information about names of Block </p>
<p>Handles </p>
<p>Table 1-1   History of the document </p>
<p><b>1.2 </b></p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> </p>
<p>AUTOSAR_SWS_NVRAMManager.pdf </p>
<p>V 2.2.0 </p>
<p>[2] </p>
<p> </p>
<p>AUTOSAR_SWS_DET.pdf </p>
<p>V 2.2.0 </p>
<p>[3] </p>
<p> </p>
<p>AUTOSAR_SWS_DEM.pdf </p>
<p>V 2.2.1 </p>
<p>[4] </p>
<p> </p>
<p>AUTOSAR_BasicSoftwareModules.pdf </p>
<p>V 1.2.0 </p>
<p>Table 1-2   Reference documents </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>4 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Document Information.................................................................................................... 2</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>History............................................................................................................... 2</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Reference Documents ...................................................................................... 4</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Component History....................................................................................................... 11</b></p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Introduction ................................................................................................................... 12</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Architecture Overview..................................................................................... 13</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Functional Description ................................................................................................. 15</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Features.......................................................................................................... 15</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Initialization ..................................................................................................... 15</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>Block Size Checks .......................................................................................... 16</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>Start-up ........................................................................................................... 17</p>
<p> </p>
<p>4.2.3</p>
<p> </p>
<p>Initialization of the Data Blocks....................................................................... 17</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>States .............................................................................................................. 18</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Main Functions ............................................................................................... 18</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>Hardware Independence ................................................................................ 18</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>Synchronous Requests................................................................................... 18</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>Asynchronous Requests................................................................................. 18</p>
<p> </p>
<p>4.4.4</p>
<p> </p>
<p>API Configuration Classes and additional API Services ................................. 19</p>
<p> </p>
<p>4.4.5</p>
<p> </p>
<p>Block Handling................................................................................................ 20</p>
<p> </p>
<p>4.4.5.1</p>
<p> </p>
<p>NV Blocks and Block Handles ........................................................................ 20</p>
<p> </p>
<p>4.4.5.2</p>
<p> </p>
<p>Different Types of NV Blocks .......................................................................... 21</p>
<p> </p>
<p>4.4.5.3</p>
<p> </p>
<p>Permanent and non-permanent RAM Blocks ................................................. 22</p>
<p> </p>
<p>4.4.5.4</p>
<p> </p>
<p>ROM Defaults ................................................................................................. 23</p>
<p> </p>
<p>4.4.5.5</p>
<p> </p>
<p>Checksum ....................................................................................................... 23</p>
<p> </p>
<p>4.4.6</p>
<p> </p>
<p>Prioritized or non-prioritized Queuing of asynchronous Requests.................. 23</p>
<p> </p>
<p>4.4.7</p>
<p> </p>
<p>Asynchronous Job-End Polling....................................................................... 23</p>
<p> </p>
<p>4.4.8</p>
<p> </p>
<p>Asynchronous Job-End Notification................................................................ 23</p>
<p> </p>
<p>4.4.9</p>
<p> </p>
<p>Immediate Priority Jobs and Cancellation of current Jobs.............................. 24</p>
<p> </p>
<p>4.4.10</p>
<p> </p>
<p>Asynchronous CRC Calculation ..................................................................... 24</p>
<p> </p>
<p>4.4.11</p>
<p> </p>
<p>Write Protection .............................................................................................. 25</p>
<p> </p>
<p>4.4.12</p>
<p> </p>
<p>Erase and Invalidate ....................................................................................... 25</p>
<p> </p>
<p>4.4.13</p>
<p> </p>
<p>Init Callbacks .................................................................................................. 25</p>
<p> </p>
<p>4.4.14</p>
<p> </p>
<p>Define Locking/ Unlocking Services ............................................................... 25</p>
<p> </p>
<p>4.4.15</p>
<p> </p>
<p>Interrupts......................................................................................................... 26</p>
<p> </p>
<p>4.4.16</p>
<p> </p>
<p>Data Corruption .............................................................................................. 26</p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>5 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>4.4.17</p>
<p> </p>
<p>Concurrent access to NV data for DCM.......................................................... 26</p>
<p> </p>
<p>4.4.18</p>
<p> </p>
<p>Removed Functionality ................................................................................... 26</p>
<p> </p>
<p>4.4.19</p>
<p> </p>
<p>Changed Functionality .................................................................................... 27</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Error Handling................................................................................................. 27</p>
<p> </p>
<p>4.5.1</p>
<p> </p>
<p>Development Error Reporting ......................................................................... 27</p>
<p> </p>
<p>4.5.1.1</p>
<p> </p>
<p>Parameter Checking ....................................................................................... 28</p>
<p> </p>
<p>4.5.2</p>
<p> </p>
<p>Production Code Error Reporting ................................................................... 29</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Integration ..................................................................................................................... 31</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Scope of Delivery............................................................................................ 31</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>Static Files ...................................................................................................... 31</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>Dynamic Files ................................................................................................. 32</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Include Structure............................................................................................. 32</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping................................................... 33</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Dependencies on SW Modules ...................................................................... 34</p>
<p> </p>
<p>5.4.1</p>
<p> </p>
<p>OSEK / AUTOSAR OS.................................................................................... 34</p>
<p> </p>
<p>5.4.2</p>
<p> </p>
<p>DEM ................................................................................................................ 34</p>
<p> </p>
<p>5.4.3</p>
<p> </p>
<p>DET................................................................................................................. 34</p>
<p> </p>
<p>5.4.4</p>
<p> </p>
<p>MEMIF ............................................................................................................ 34</p>
<p> </p>
<p>5.4.5</p>
<p> </p>
<p>CRC Library .................................................................................................... 34</p>
<p> </p>
<p>5.4.6</p>
<p> </p>
<p>Callback Functions ......................................................................................... 34</p>
<p> </p>
<p>5.4.7</p>
<p> </p>
<p>RTE................................................................................................................. 35</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>Integration Steps............................................................................................. 35</p>
<p> </p>
<p>5.6</p>
<p> </p>
<p>Estimating Resource Consumption ................................................................ 35</p>
<p> </p>
<p>5.6.1</p>
<p> </p>
<p>RAM Usage .................................................................................................... 36</p>
<p> </p>
<p>5.6.2</p>
<p> </p>
<p>ROM Usage .................................................................................................... 36</p>
<p> </p>
<p>5.6.3</p>
<p> </p>
<p>NV Usage ....................................................................................................... 36</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>API Description ............................................................................................................. 38</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Interfaces Overview ........................................................................................ 38</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Type Definitions .............................................................................................. 38</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Global API Constants...................................................................................... 40</p>
<p> </p>
<p>6.4</p>
<p> </p>
<p>Services provided by NVM ............................................................................. 40</p>
<p> </p>
<p>6.4.1</p>
<p> </p>
<p>NvM_Init.......................................................................................................... 40</p>
<p> </p>
<p>6.4.2</p>
<p> </p>
<p>NvM_SetDataIndex......................................................................................... 41</p>
<p> </p>
<p>6.4.3</p>
<p> </p>
<p>NvM_GetDataIndex ........................................................................................ 41</p>
<p> </p>
<p>6.4.4</p>
<p> </p>
<p>NvM_SetBlockProtection ................................................................................ 42</p>
<p> </p>
<p>6.4.5</p>
<p> </p>
<p>NvM_GetErrorStatus....................................................................................... 43</p>
<p> </p>
<p>6.4.6</p>
<p> </p>
<p>NvM_GetVersionInfo....................................................................................... 43</p>
<p> </p>
<p>6.4.7</p>
<p> </p>
<p>NvM_SetRamBlockStatus............................................................................... 44</p>
<p> </p>
<p>6.4.8</p>
<p> </p>
<p>NvM_SetBlockLockStatus............................................................................... 45</p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>6 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>6.4.9</p>
<p> </p>
<p>NvM_MainFunction ......................................................................................... 46</p>
<p> </p>
<p>6.4.10</p>
<p> </p>
<p>NvM_ReadBlock ............................................................................................. 46</p>
<p> </p>
<p>6.4.11</p>
<p> </p>
<p>NvM_WriteBlock ............................................................................................. 47</p>
<p> </p>
<p>6.4.12</p>
<p> </p>
<p>NvM_RestoreBlockDefaults ............................................................................ 48</p>
<p> </p>
<p>6.4.13</p>
<p> </p>
<p>NvM_EraseNvBlock ........................................................................................ 49</p>
<p> </p>
<p>6.4.14</p>
<p> </p>
<p>NvM_InvalidateNvBlock .................................................................................. 50</p>
<p> </p>
<p>6.4.15</p>
<p> </p>
<p>NvM_ReadAll .................................................................................................. 51</p>
<p> </p>
<p>6.4.16</p>
<p> </p>
<p>NvM_WriteAll .................................................................................................. 52</p>
<p> </p>
<p>6.4.17</p>
<p> </p>
<p>NvM_CancelWriteAll ....................................................................................... 52</p>
<p> </p>
<p>6.4.18</p>
<p> </p>
<p>NvM_KillWriteAll ............................................................................................. 53</p>
<p> </p>
<p>6.5</p>
<p> </p>
<p>Services used by NVM ................................................................................... 53</p>
<p> </p>
<p>6.6</p>
<p> </p>
<p>Callback Functions ......................................................................................... 54</p>
<p> </p>
<p>6.6.1</p>
<p> </p>
<p>NvM_JobEndNotification ................................................................................ 54</p>
<p> </p>
<p>6.6.2</p>
<p> </p>
<p>NvM_JobErrorNotification ............................................................................... 55</p>
<p> </p>
<p>6.7</p>
<p> </p>
<p>Configurable Interfaces................................................................................... 55</p>
<p> </p>
<p>6.7.1</p>
<p> </p>
<p>SingleBlockCallbackFunction ......................................................................... 55</p>
<p> </p>
<p>6.7.2</p>
<p> </p>
<p>MultiBlockCallbackFunction ............................................................................ 56</p>
<p> </p>
<p>6.7.3</p>
<p> </p>
<p>InitBlockCallbackFunction............................................................................... 56</p>
<p> </p>
<p>6.8</p>
<p> </p>
<p>Service Ports .................................................................................................. 57</p>
<p> </p>
<p>6.8.1</p>
<p> </p>
<p>Client Server Interface .................................................................................... 57</p>
<p> </p>
<p>6.8.1.1</p>
<p> </p>
<p>Provide Ports on NVM side............................................................................. 57</p>
<p> </p>
<p>6.8.1.1.1</p>
<p> </p>
<p>PAdmin_&lt;BlockName&gt; ................................................................................... 57</p>
<p> </p>
<p>6.8.1.1.2</p>
<p> </p>
<p>PS_&lt;BlockName&gt; .......................................................................................... 57</p>
<p> </p>
<p>6.8.1.2</p>
<p> </p>
<p>Require Ports.................................................................................................. 58</p>
<p> </p>
<p>6.8.1.2.1</p>
<p> </p>
<p>NvM_RpNotifyFinished_Id&lt;BlockName&gt; ....................................................... 58</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Configuration ................................................................................................................ 59</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Software Component Template....................................................................... 59</p>
<p> </p>
<p>7.1.1</p>
<p> </p>
<p>Generation ...................................................................................................... 59</p>
<p> </p>
<p>7.1.2</p>
<p> </p>
<p>Import into DaVinci Developer ........................................................................ 61</p>
<p> </p>
<p>7.1.3</p>
<p> </p>
<p>Dependencies on Configuration of NVM Attributes......................................... 62</p>
<p> </p>
<p>7.1.3.1</p>
<p> </p>
<p>Naming of Service Port Interfaces .................................................................. 62</p>
<p> </p>
<p>7.1.4</p>
<p> </p>
<p>Service Port Prototypes .................................................................................. 62</p>
<p> </p>
<p>7.1.4.1</p>
<p> </p>
<p>Port Prototype Naming ................................................................................... 63</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Configuration of NVM Attributes ..................................................................... 63</p>
<p> </p>
<p>7.2.1</p>
<p> </p>
<p>Start configuration of the NVM........................................................................ 64</p>
<p> </p>
<p>7.2.2</p>
<p> </p>
<p>General Settings ............................................................................................. 65</p>
<p> </p>
<p>7.2.3</p>
<p> </p>
<p>Special NVRAM Blocks................................................................................... 67</p>
<p> </p>
<p>7.2.4</p>
<p> </p>
<p>User Block Description ................................................................................... 69</p>
<p> </p>
<p>7.2.5</p>
<p> </p>
<p>Error Detection................................................................................................ 76</p>
<p> </p>
<p>7.2.6</p>
<p> </p>
<p>Module API ..................................................................................................... 78</p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>7 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>7.2.6.1</p>
<p> </p>
<p>Provided API group......................................................................................... 78</p>
<p> </p>
<p>7.3</p>
<p> </p>
<p>Attributes only configurable using GCE .......................................................... 78</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>AUTOSAR Standard Compliance................................................................................. 80</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>Deviations ....................................................................................................... 80</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>Additions/ Extensions ..................................................................................... 80</p>
<p> </p>
<p>8.2.1</p>
<p> </p>
<p>Parameter Checking ....................................................................................... 80</p>
<p> </p>
<p>8.2.2</p>
<p> </p>
<p>Concurrent access to NV data........................................................................ 80</p>
<p> </p>
<p>8.2.3</p>
<p> </p>
<p>RAM-/ROM Block Size checks ....................................................................... 80</p>
<p> </p>
<p>8.2.4</p>
<p> </p>
<p>Calculated CRC value does not depend on number of calculation steps....... 80</p>
<p> </p>
<p>8.3</p>
<p> </p>
<p>Limitations....................................................................................................... 81</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Glossary and Abbreviations ........................................................................................ 82</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>Glossary.......................................................................................................... 82</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>Abbreviations .................................................................................................. 83</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Contact ........................................................................................................................... 84</b></p>
<p> </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>8 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>Illustrations </b></p>
<p>Figure 3-1</p>
<p> </p>
<p>AUTOSAR architecture................................................................................... 13</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>Interfaces to adjacent modules of the NVM.................................................... 14</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>The file structure of the NVM sections module ............................................... 32</p>
<p> </p>
<p>Figure 7-1</p>
<p> </p>
<p>Generate an NVM software component template........................................... 59</p>
<p> </p>
<p>Figure 7-2</p>
<p> </p>
<p>Change target directory for all generated SW-C files of NvM. ........................ 60</p>
<p> </p>
<p>Figure 7-3</p>
<p> </p>
<p>Import a new software component into DaVinci Developer ............................ 61</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>  </p>
<p>Table 1-1 </p>
<p> </p>
<p>History of the document.................................................................................... 4</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Reference documents....................................................................................... 4</p>
<p> </p>
<p>Table 2-1 </p>
<p> </p>
<p>Component history...........................................................................................11</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Supported SWS features ................................................................................ 15</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Not supported SWS features .......................................................................... 15</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>Block concept ................................................................................................. 22</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>Mapping of service IDs to services ................................................................. 27</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>Errors reported to DET ................................................................................... 28</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>Development Error Checking: Assignment of checks to services................... 29</p>
<p> </p>
<p>Table 4-7 </p>
<p> </p>
<p>Errors reported to DEM................................................................................... 30</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Static files........................................................................................................ 31</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>Generated files ............................................................................................... 32</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>Compiler abstraction and memory mapping ................................................... 33</p>
<p> </p>
<p>Table 6-1 </p>
<p> </p>
<p>Type definitions............................................................................................... 39</p>
<p> </p>
<p>Table 6-2 </p>
<p> </p>
<p>NvM_Init.......................................................................................................... 40</p>
<p> </p>
<p>Table 6-3 </p>
<p> </p>
<p>NvM_SetDataIndex......................................................................................... 41</p>
<p> </p>
<p>Table 6-4 </p>
<p> </p>
<p>NvM_GetDataIndex ........................................................................................ 42</p>
<p> </p>
<p>Table 6-5 </p>
<p> </p>
<p>NvM_SetBlockProtection ................................................................................ 42</p>
<p> </p>
<p>Table 6-6 </p>
<p> </p>
<p>NvM_GetErrorStatus....................................................................................... 43</p>
<p> </p>
<p>Table 6-7 </p>
<p> </p>
<p>NvM_GetVersionInfo....................................................................................... 44</p>
<p> </p>
<p>Table 6-8 </p>
<p> </p>
<p>NvM_SetRamBlockStatus............................................................................... 44</p>
<p> </p>
<p>Table 6-9 </p>
<p> </p>
<p>NvM_SetBlockLockStatus............................................................................... 45</p>
<p> </p>
<p>Table 6-10 </p>
<p> </p>
<p>NvM_MainFunction ......................................................................................... 46</p>
<p> </p>
<p>Table 6-11 </p>
<p> </p>
<p>NvM_ReadBlock ............................................................................................. 47</p>
<p> </p>
<p>Table 6-12 </p>
<p> </p>
<p>NvM_WriteBlock ............................................................................................. 47</p>
<p> </p>
<p>Table 6-13 </p>
<p> </p>
<p>NvM_RestoreBlockDefaults ............................................................................ 48</p>
<p> </p>
<p>Table 6-14 </p>
<p> </p>
<p>NvM_EraseNvBlock ........................................................................................ 49</p>
<p> </p>
<p>Table 6-15 </p>
<p> </p>
<p>NvM_InvalidateNvBlock .................................................................................. 50</p>
<p> </p>
<p>Table 6-16 </p>
<p> </p>
<p>NvM_ReadAll .................................................................................................. 51</p>
<p> </p>
<p>Table 6-17 </p>
<p> </p>
<p>NvM_WriteAll .................................................................................................. 52</p>
<p> </p>
<p>Table 6-18 </p>
<p> </p>
<p>NvM_CancelWriteAll ....................................................................................... 53</p>
<p> </p>
<p>Table 6-19 </p>
<p> </p>
<p>NvM_KilllWriteAll............................................................................................. 53</p>
<p> </p>
<p>Table 6-19 </p>
<p> </p>
<p>Services used by the NVM ............................................................................. 54</p>
<p> </p>
<p>Table 6-20 </p>
<p> </p>
<p>NvM_JobEndNotification ................................................................................ 54</p>
<p> </p>
<p>Table 6-21 </p>
<p> </p>
<p>NvM_JobErrorNotification ............................................................................... 55</p>
<p> </p>
<p>Table 6-22 </p>
<p> </p>
<p>SingleBlockCallbackFunction ......................................................................... 56</p>
<p> </p>
<p>Table 6-23</p>
<p> </p>
<p>MultiBlockCallbackFunction ............................................................................ 56</p>
<p> </p>
<p>Table 6-24</p>
<p> </p>
<p>InitBlockCallbackFunction............................................................................... 57</p>
<p> </p>
<p>Table 6-25</p>
<p> </p>
<p>Operations of Port Prototype PAdmin_&lt;BlockName&gt; .................................... 57</p>
<p> </p>
<p>Table 6-26</p>
<p> </p>
<p>Operations of Port Prototype PS_&lt;BlockName&gt;............................................ 58</p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>9 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Table 6-27</p>
<p> </p>
<p>Operation of Port prototype NvM_RpNotifyFinished_Id&lt;BlockName&gt; ........... 58</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>General Settings ............................................................................................. 66</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>Special NVRAM blocks ................................................................................... 69</p>
<p> </p>
<p>Table 7-3 </p>
<p> </p>
<p>User block description .................................................................................... 75</p>
<p> </p>
<p>Table 7-4 </p>
<p> </p>
<p>Error Detection................................................................................................ 78</p>
<p> </p>
<p>Table 7-5 </p>
<p> </p>
<p>Provided API ................................................................................................... 78</p>
<p> </p>
<p>Table 9-1 </p>
<p> </p>
<p>Glossary.......................................................................................................... 82</p>
<p> </p>
<p>Table 9-2 </p>
<p> </p>
<p>Abbreviations .................................................................................................. 83</p>
<p> </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>10 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>2 </b></p>
<p><b>Component History </b></p>
<p><b>Component </b></p>
<p><b>Version </b></p>
<p><b>New Features </b></p>
<p>3.05.xx </p>
<p>Calculated CRC32 value does not depend anymore on configuration of </p>
<p>parameter NvmCrcNumOfBytes. </p>
<p>Added RAM and ROM block size checks: The NvM can be configured to </p>
<p>check each RAM block’s and/or each ROM block’s size against the configured </p>
<p>NV block length, considering CRC setting, internal buffering, etc. </p>
<p>3.04.xx </p>
<p>Crc Handling is configurable: Either the internal buffer, available since </p>
<p>component version 3.02, is used or Crc is stored at the end of RAM Block. </p>
<p>3.03.xx </p>
<p>At processing a redundant NVRAM Block NvM determines an appropriate </p>
<p>write order, depending on the NV Block’s current state/content. A defect NV </p>
<p>block is written in preference to a valid one. </p>
<p>NVM provides possibility for DCM to access NV data concurrently with NVM’s </p>
<p>applications. </p>
<p>3.02.xx </p>
<p>Update to AUTOSAR 3 specification. </p>
<p>Additional API NvM_SetBlockLockStatus. </p>
<p>Storing each NVRAM block’s CRC internally: RAM Blocks provided by the </p>
<p>application don’t have to allocate additional space for CRC. </p>
<p>Configurability, whether the NVM shall create the RAM Block associated with </p>
<p>the ConfigID NVRAM Block on its own, or the user creates the RAM block. </p>
<p>Table 2-1   Component history </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>11 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>3 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the functionality, API and configuration of the AUTOSAR BSW </p>
<p>module NVM as specified in [1].  </p>
<p> </p>
<p><b>Supported AUTOSAR Release*: </b></p>
<p>3 </p>
<p><b>Supported Configuration Variants: </b></p>
<p>link-time </p>
<p><b> </b></p>
<p> </p>
<p><b>Vendor ID: </b></p>
<p>NVM_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>NVM_MODULE_ID   </p>
<p>20 decimal </p>
<p>(according to ref. [4]) </p>
<p>* For the precise AUTOSAR Release 3.x please see the release specific documentation.  </p>
<p> </p>
<p>The  module  NVM  is  created  to  abstract  the  usage  of  non-volatile  memory,  such  as </p>
<p>EEPROM or Flash, from application. All access to NV memory is block based. To avoid </p>
<p>conflicts and inconsistent data the NVM shall be the only module to access non-volatile </p>
<p>memory. </p>
<p>The  NVM  accesses  the  module  MEMIF  (Memory Abstraction  Interface)  which  abstracts </p>
<p>the modules FEE (Flash EEPROM Emulation) and EA (EEPROM Abstraction). Thus, the </p>
<p>NVM is hardware independent. The modules FEE and EA abstract the access to Flash or </p>
<p>EEPROM driver. To select the appropriate device (FEE or EA) the NVM uses a handle that </p>
<p>is provided by the MEMIF.  </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>MICROSAR FEE and MICROSAR EA are different products that are not part of </p>
<p>MICROSAR NVM! </p>
<p><b> </b></p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>12 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>3.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the NVM is located in the AUTOSAR architecture. </p>
<p> </p>
<p>Figure 3-1 AUTOSAR architecture </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>13 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p> </p>
<p>The next figure shows the interfaces to adjacent modules of the NVM. These interfaces </p>
<p>are described in chapter 6.  </p>
<p> </p>
<p>Figure 3-2 Interfaces to adjacent modules of the NVM </p>
<p>Applications normally do not access the services of the BSW modules directly. They use </p>
<p>the service ports provided by the BSW modules via the RTE. The service ports provided </p>
<p>by the NVM are listed in chapter 6.8 and are defined in [1]. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>14 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>4 </b></p>
<p><b>Functional Description </b></p>
<p><b>4.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in this chapter cover the complete functionality specified in [1]. </p>
<p>The  &quot;supported&quot;  and  &quot;not  supported&quot;  features  are  presented  in  the  following  two  tables. </p>
<p>For further information on not supported features also see chapter 8. </p>
<p> </p>
<p>The following features described in [1] are supported: </p>
<p><b>Supported Feature </b></p>
<p>Complete API </p>
<p>Block Management Types (Native, Redundant, Dataset) </p>
<p>CRC handling (CRC16, CRC32) </p>
<p>Priority handling, including Immediate (Crash) Data write </p>
<p>Job queuing </p>
<p>ROM defaults (ROM defaults block, Init callback) </p>
<p>Config Id handling </p>
<p>RAM block valid/modified handling </p>
<p>Re-Validation of RAM blocks during start up using CRC </p>
<p>Job end notifications </p>
<p>Skipping Blocks during Start-Up </p>
<p>API Configuration Classes </p>
<p>Service Ports – Generation of Software Component Description </p>
<p>Concurrent access to NV data for DCM </p>
<p>Table 4-1   Supported SWS features </p>
<p>The following features described in [1] are not supported: </p>
<p><b>Not Supported Feature </b></p>
<p>Dataset ROM blocks (Management Type Dataset, multiple ROM blocks) </p>
<p>Disabling Set/Get_DataIndex API </p>
<p>Table 4-2   Not supported SWS features </p>
<p><b>4.2 </b></p>
<p><b>Initialization </b></p>
<p>Before the module NVM can be used it has to be initialized. All modules on which the NVM </p>
<p>depends  need  to  be  initialized  before.  The  initialization  of  all  these  modules  should  be </p>
<p>done by the ECU State Manager. If the NVM is not used in an AUTOSAR environment it </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>15 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>should be done by a different entity. Pay attention that the NVM <b>will not </b>initialize the used </p>
<p>modules by its own. </p>
<p>Depending  on  the  configuration  of  the  NVM  stack,  different  modules  might  need  to  be </p>
<p>initialized. It is advised to use a bottom up strategy for initialization: </p>
<p></p>
<p> </p>
<p>NV device drivers for internal devices (FLS/EEP) </p>
<p></p>
<p> </p>
<p>Low level driver that an external NV device driver might depend on (e.g. DIO, SPI) </p>
<p></p>
<p> </p>
<p>Drivers for external NV devices (e.g. external EEP or FLS) </p>
<p></p>
<p> </p>
<p>NV device abstraction modules (EA/FEE) </p>
<p></p>
<p> </p>
<p>Non-Volatile  Manager  (NVM).  The  NVM  “initialization”  is  twofold: </p>
<p>NvM_Init()</p>
<p>  and </p>
<p>NvM_ReadAll()</p>
<p>. </p>
<p>NvM_ReadAll()</p>
<p> needs to be the last initialization step! </p>
<p>Initializing the modules in this sequence ensures that as soon as a module is used, the </p>
<p>modules it depends on are ready. </p>
<p><b>4.2.1 </b></p>
<p><b>Block Size Checks </b></p>
<p>In Development Mode the NvM can be configured to check the size of every configured </p>
<p>NVRAM  block’s  permanent  RAM  block  as  well  as  its  ROM  block.  It  compares  the </p>
<p>configured NVRAM block length to the sizes of the RAM block and/or ROM block symbols. </p>
<p>If  the  check  fails  on  one  NVRAM  block,  an  error  is  reported  to  the  DET,  and  the  NvM </p>
<p>remains uninitialized. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b>. </p>
<p>If “Development Error Detection” is enabled, the RAM/ROM block length checks will </p>
<p>always be generated into NvM_Cfg.c (</p>
<p>NvM_CfgCheckRomBlockLengths </p>
<p>and </p>
<p>NvM_CfgCheckRamBlockLengths</p>
<p>), and NvM_Init will always call them from NvM_Init. </p>
<p>If RAM and/or ROM block checking was disabled, the corresponding function will be </p>
<p>generated to always report “check passed” to the NvM. Hence these checks can be </p>
<p>configured at link-time. </p>
<p>Since the functions are “implemented” in generated NvM_Cfg.c, they can be debugged, </p>
<p>even if NvM was delivered as library. Both checks always iterate over all configured </p>
<p>blocks, i.e. they don’t abort upon a detected mismatch. Accordingly the NVM always </p>
<p>performs both checks, and then aborts in case of detected mismatch. This allows you </p>
<p>to easily detect all mismatching RAM block lengths. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The NVM makes use of the </p>
<p>sizeof</p>
<p> operator. Therefore your ROM block and permanent </p>
<p>RAM block symbols must be declared in the header files using complete types</p>
<p>. </p>
<p>Especially declarations like that are not allowed: </p>
<p></p>
<p> </p>
<p>Arrays of unknown size (</p>
<p>[]</p>
<p>) </p>
<p></p>
<p> </p>
<p>Structures of unknown contents (</p>
<p>struct x;</p>
<p>)</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>16 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>By default the NvM performs strict checks, i.e. all sizes must exactly match. While too </p>
<p>small RAM blocks usually will cause serious issues because the NVM would overwrite </p>
<p>other SW’s RAM, you would observe “loss of data” if they are too large, The NVM would </p>
<p>read/write only parts of your data to NVM memory. </p>
<p>A common reason is given by CPU’s alignment requirements: compilers may enlarge </p>
<p>structures by adding padding bytes in order to align its structures on adequate </p>
<p>boundaries. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.2.2 </b></p>
<p><b>Start-up </b></p>
<p>The basic initialization of the NVRAM Manager is done by the request </p>
<p>NvM_Init().</p>
<p> It </p>
<p>shall  be  invoked  e.g.  by  the  ECU  State  Manager  exclusively.  Due  to  strong  constraints </p>
<p>concerning  the  ECU  start-up  time  the </p>
<p>NvM_Init()</p>
<p>  request  does  not  contain  the  basic </p>
<p>initialization  of  the  configured  NVRAM  blocks.  The </p>
<p>NvM_Init()</p>
<p>  request  resets  the </p>
<p>internal variables of the NVM such as the queue and the state machine. </p>
<p><b>4.2.3 </b></p>
<p><b>Initialization of the Data Blocks </b></p>
<p>The initialization of the single blocks is normally also initiated by the ECU State Manager </p>
<p>by calling </p>
<p>NvM_ReadAll().</p>
<p> All blocks that have no valid RAM data any more and have </p>
<p>'Select for ReadAll' (see chapter  </p>
<p>7.2.4) set will be reloaded from NV memory or from ROM </p>
<p>(if available). </p>
<p>Block 1 (the configuration ID) has a special role. It is stored in NV memory and also as a </p>
<p>constant </p>
<p>(</p>
<p>NvM_CompiledConfigId_t</p>
<p>) </p>
<p>that </p>
<p>is </p>
<p>externally </p>
<p>visible </p>
<p>and </p>
<p>link-time </p>
<p>configurable.  During </p>
<p>NvM_ReadAll()</p>
<p>  the  NV  value  of  block  1  is  compared  against  the </p>
<p>constant </p>
<p>NvM_CompiledConfigId_t</p>
<p>. In case of a match all NV blocks are presumed to </p>
<p>be  valid  and  NvM  tries  to  read  them  from  NV  memory.  In  case  of  a  mismatch  or  if  the </p>
<p>configuration ID cannot be read the system behaves as following: </p>
<p></p>
<p> </p>
<p>If the configuration switch 'Dynamic Configuration Handling' (see chapter 7.2.2) is 'OFF', </p>
<p>the mismatch is ignored. It will be tried to read all blocks from NV memory (also called </p>
<p>‘normal runtime preparation’). </p>
<p></p>
<p> </p>
<p>If  the  'Dynamic  Configuration  Handling'  is  'ON',  the  normal  runtime  preparation  is </p>
<p>processed for all blocks having been configured with the option 'Resistant to Changed </p>
<p>SW'. For all other blocks an 'extended runtime preparation' will take place. </p>
<p></p>
<p> </p>
<p>All blocks that will be processed with the 'extended runtime preparation' will be treated </p>
<p>as invalid or blank. Thus, it is possible to rewrite a block having been marked as 'Write </p>
<p>Once'. If available, ROM defaults are loaded or the initialization callback is invoked. </p>
<p>Non-permanent RAM blocks, dataset blocks or blocks that are not selected for 'ReadAll' </p>
<p>(configuration  option)  are  skipped. They  must  be  loaded  manually  by  the  application  by </p>
<p>calling </p>
<p>NvM_ReadBlock(). </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>17 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>4.3 </b></p>
<p><b>States </b></p>
<p>The NVRAM Manager is internally organized with a state machine which is shown in the </p>
<p>following chapters. </p>
<p><b>4.4 </b></p>
<p><b>Main Functions </b></p>
<p><b>4.4.1 </b></p>
<p><b>Hardware Independence </b></p>
<p>The NVRAM Manager is independent from its underlying memory hardware. It accesses </p>
<p>the API of the MEMIF (Memory Abstraction Interface). The MEMIF abstracts the modules </p>
<p>FEE (Flash EEPROM Emulation) and EA (EEPROM Abstraction) for the NVM. FEE and </p>
<p>EA are used for storing data blocks in Flash or EEPROM devices. For selecting at which </p>
<p>FEE or EA instance a block shall be stored, the NVM uses a device handle (device ID) that </p>
<p>is provided by the MEMIF. </p>
<p><b>4.4.2 </b></p>
<p><b>Synchronous Requests </b></p>
<p>The NVM API services are divided into synchronous and asynchronous requests.  </p>
<p>The synchronous services are executed immediately when called. They are executed in </p>
<p>the context of the calling task. This means, that behavior depends on the characteristics of </p>
<p>the calling task and not on the NVM. For example, if the calling task is a non-preemptive </p>
<p>one, the synchronous NVM request will be executed until it has finished. Otherwise, if the </p>
<p>calling  task  is  a  preemptive  one,  the  synchronous  NVM  request  can  be  preempted  by </p>
<p>another higher prioritized task. </p>
<p>Following NVM API services initiate synchronous requests: </p>
<p></p>
<p> </p>
<p>NvM_Init() </p>
<p></p>
<p> </p>
<p>NvM_SetDataIndex()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_GetDataIndex()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_SetBlockProtection()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_SetBlockLockStatus()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_SetRamBlockStatus()</p>
<p> (for not CRC protected blocks) </p>
<p></p>
<p> </p>
<p>NvM_GetErrorStatus()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_GetVersionInfo()</p>
<p> </p>
<p><b>4.4.3 </b></p>
<p><b>Asynchronous Requests </b></p>
<p>Following NVM API services initiate asynchronous requests: </p>
<p></p>
<p> </p>
<p>NvM_ReadBlock() </p>
<p></p>
<p> </p>
<p>NvM_WriteBlock()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_RestoreBlockDefaults()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_EraseNvBlock()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_InvalidateNvBlock()</p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>18 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p></p>
<p> </p>
<p>NvM_SetRamBlockStatus()</p>
<p> (for CRC protected blocks) </p>
<p></p>
<p> </p>
<p>NvM_ReadAll()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_WriteAll()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_CancelWriteAll()</p>
<p> </p>
<p>The API call is handled in the context of the calling task. Here the service is queued and </p>
<p>will be processed asynchronously. The processing of the queued requests is done in the </p>
<p>context of the caller of the cyclic function </p>
<p>NvM_MainFunction(). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>RAM blocks must not be accessed by any user while a request to its associated </p>
<p>NVRAM Block is pending! </p>
<p>There are some exceptions to this limitation: </p>
<p></p>
<p> </p>
<p>NvM_InvalidateNvBlock and NvM_EraseNvBlock don’t access any RAM blocks. Thus </p>
<p>access is still possible without limitations </p>
<p></p>
<p> </p>
<p>While the NvM processes an NvM_WriteBlock request, the RAM block may still read. </p>
<p></p>
<p> </p>
<p>Though applications are not expected to be running while NvM processes NvM_WriteAll, </p>
<p>RAM blocks may be read, as during NvM_WriteBlock processing. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.4 </b></p>
<p><b>API Configuration Classes and additional API Services </b></p>
<p>Depending on the needs of the customer, the extent of the NVM can be tailored. Three </p>
<p>configuration classes are specified that offer a different amount of functionality/functions of </p>
<p>the NVM: </p>
<p><b>API configuration class 1: </b></p>
<p>A </p>
<p>minimum </p>
<p>set </p>
<p>of </p>
<p>API </p>
<p>services </p>
<p>is </p>
<p>used. </p>
<p>Queuing </p>
<p>and </p>
<p>Job </p>
<p>prioritization </p>
<p>are </p>
<p>not </p>
<p>implemented. Following functions are available: </p>
<p></p>
<p> </p>
<p>NvM_Init()</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_GetErrorStatus() </p>
<p></p>
<p> </p>
<p>NvM_SetRamBlockStatus() </p>
<p></p>
<p> </p>
<p>NvM_ReadAll() </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p>NvM_CancelWriteAll()</p>
<p> </p>
<p><b>API configuration class 2: </b></p>
<p>Intermediate set of API services. Queuing and job prioritization are implemented. Following </p>
<p>functions are available additionally according to API configuration class 1: </p>
<p></p>
<p> </p>
<p>NvM_SetDataIndex() </p>
<p></p>
<p> </p>
<p>NvM_GetDataIndex()</p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>19 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p></p>
<p> </p>
<p>NvM_ReadBlock() </p>
<p></p>
<p> </p>
<p>NvM_WriteBlock() </p>
<p></p>
<p> </p>
<p>NvM_RestoreBlockDefaults() </p>
<p><b>API configuration class 3: </b></p>
<p>All  API  services  are  available.  Following  functions  can  be  used  additionally  to  API </p>
<p>configuration class 2:</p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_SetBlockProtection() </p>
<p></p>
<p> </p>
<p>NvM_EraseNvBlock() </p>
<p></p>
<p> </p>
<p>NvM_InvalidateNvBlock() </p>
<p>The </p>
<p>functions </p>
<p>NvM_SetRamBlockStatus()</p>
<p> </p>
<p>and </p>
<p>NvM_GetVersionInfo()</p>
<p> </p>
<p>can </p>
<p>be </p>
<p>enabled/disabled </p>
<p>additionally </p>
<p>via </p>
<p>the </p>
<p>Configuration </p>
<p>tool. </p>
<p>The </p>
<p>function </p>
<p>NvM_SetBlockLockStatus() </p>
<p>is  always  available  independent  of  API  configuration </p>
<p>class. </p>
<p><b>4.4.5 </b></p>
<p><b>Block Handling </b></p>
<p><b>4.4.5.1 </b></p>
<p><b>NV Blocks and Block Handles </b></p>
<p>Every application's data packet that is intended for storage in NV memory is seen as a </p>
<p>block.  For  each  block  a  unique  block  handle  (block  ID)  is  used.  For  the  application  the </p>
<p>(RAM) block is just one of its variables associated with the block. To write this variable to </p>
<p>NV memory it calls the </p>
<p>NvM_WriteBlock()</p>
<p> service with the block handle that is mapped </p>
<p>to this variable. The block handle names are given during configuration of the NVM. They </p>
<p>are published to the application by including </p>
<p>NvM.h</p>
<p>. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>The block handle names are automatically prefixed by the module short name followed </p>
<p>by an underscore (NvM_). The prefixing has no influence on RTE. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>The application only needs to provide space  for CRC storage in its RAM block(s) when </p>
<p>“Internal  Buffer  for  Crc  Handling”  is  disabled  (see  chapter  7.2.2).  Is  the  internal  buffer </p>
<p>enabled, no additional space for CRC storage in the RAM block(s) is necessary. The NVM </p>
<p>copies in this case the data not directly from the application variable to the NV memory. </p>
<p>There  is  an  extra  buffering  within  the  module  NVM,  because  the  NVM  writes  data  and </p>
<p>CRC,  if  configured,  within  one  request  to  the  NV  memory.  CRC  is  not  stored  in  the </p>
<p>application variable; it is stored in an internal variable by the NVM. Before processing write </p>
<p>request to underlying components, the NVM copies data and CRC into the internal buffer. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>20 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The actual processing of an asynchronous job (such as a write job) is done in </p>
<p>NvM_MainFunction</p>
<p>. Therefore it needs to be called cyclically. Usually this is done by </p>
<p>the Basic Software Scheduler (SCHM). </p>
<p><b> </b></p>
<p><b>4.4.5.2 </b></p>
<p><b>Different Types of NV Blocks </b></p>
<p>The application data can be stored in different types of blocks in the NV memory. </p>
<p><b>Native Block: </b></p>
<p>This is the standard block type. The data is stored once in the NV area. </p>
<p><b>Redundant Block: </b></p>
<p>The data is stored twice in the NV area. A read request is successful even if one block is </p>
<p>corrupted  but  the  other  block  could  be  read.  An  erase  or  invalidate  request  is  only </p>
<p>successful if both blocks could be erased respectively invalidated.  </p>
<p>If  the  NVM  detects  a  defect  NV  Block,  it  is  written  in  preference  to  a  valid  NV  Block.  If </p>
<p>writing  to  one  single  NV  Block  failed,  the  NVM  reports  the  error  NVM_E_REQ_FAILED </p>
<p>(see chapter 4.5.2) to the DEM. If writing to primary NV block failed, NVM ends the request </p>
<p>always  with  a  negative  job  result.  If  the  primary  NV  block  was  written  successfully,  the </p>
<p>request always ends with a positive job result, even when the secondary NV block failed. </p>
<p><b>Dataset Blocks: </b></p>
<p>A dataset block can be seen as an array. A configurable number of instances of this block </p>
<p>are stored in NV-memory. In the RAM area there is only one RAM buffer. The appropriate </p>
<p>NV block instance is selected by the so called “data index”. The data index can be read </p>
<p>and </p>
<p>set </p>
<p>by </p>
<p>synchronous </p>
<p>API </p>
<p>services </p>
<p>NvM_GetDataIndex()</p>
<p> </p>
<p>and </p>
<p>NVM_SetDataIndex()</p>
<p>. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>21 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>Concept </b></p>
<p><b>Description </b></p>
<p>Block </p>
<p>General notion of the structure composed of data, state and CRC. It is </p>
<p>spread over RAM, ROM, NVRAM </p>
<p>NV Block </p>
<p>One block in NVRAM - CRC is optional. </p>
<p>NV Block of </p>
<p></p>
<p> </p>
<p>Native type </p>
<p></p>
<p> </p>
<p>Redundant type </p>
<p></p>
<p> </p>
<p>Dataset type </p>
<p>One NV Block of specified type </p>
<p>RAM Block </p>
<p>One data Block in RAM. The data is shared by NVRAM Manager and </p>
<p>application. E. g. application writes data to this block and requests </p>
<p>NVRAM Manager to write it into NVRAM. </p>
<p>ROM Block </p>
<p>One data block in ROM. Default data supplied by application. </p>
<p>NVRAM Block </p>
<p>A logical composition of one RAM block and its corresponding NV and </p>
<p>ROM Block. </p>
<p>NV = NVRAM </p>
<p>Non-volatile memory. Actually a synonym for Flash or EEPROM devices. </p>
<p>Table 4-3   Block concept </p>
<p><b>4.4.5.3 </b></p>
<p><b>Permanent and non-permanent RAM Blocks </b></p>
<p>The  RAM  block  (application  variable)  can  be  either  permanent  or  non-permanent.  A </p>
<p>permanent RAM block belongs to a NV block that is accessed only by one application. The </p>
<p>address of the RAM block is fix and is stored in the configuration of the NVM. </p>
<p>It  is  also  possible  to  have  multiple  applications  accessing  the  same  NV  block.  Each </p>
<p>application uses its own RAM block. In this case the RAM block is called non-permanent. </p>
<p>As the RAM address is not stored (and may vary) a pointer must be given for reading and </p>
<p>writing a non-permanent block. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Asynchronous API functions can be reentered by different tasks. So it is possible that </p>
<p>several tasks queue for example a write job at the same time (a task with higher priority </p>
<p>might interrupt a lower one). But it is not possible to queue the same block multiple </p>
<p>times (neither by different tasks nor for different jobs). So if for instance a read job for </p>
<p>block 5 is queued, an erase job for this block can’t be queued before the read job is </p>
<p>finished. </p>
<p>If one block is used by multiple tasks, which is a common task for non-permanent RAM </p>
<p>blocks, the application is responsible for synchronization. Of course if, for example, an </p>
<p>erase request is in process the RAM block could be read or written without any effect to </p>
<p>the result of the erase job. The only problem is that the NVM does not offer any </p>
<p>information to an application what service is currently processed for a block. The </p>
<p>application that initiated the service of course does know, but a different application that </p>
<p>also uses the block does not. So the safest way for block access is not to use the RAM </p>
<p>block as long as it is “pending”. This way RAM inconsistency can be avoided </p>
<p>definitively. </p>
<p><b> </b></p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>22 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>4.4.5.4 </b></p>
<p><b>ROM Defaults </b></p>
<p>ROM defaults can be assigned to any NVRAM block. The ROM defaults block is provided </p>
<p>by the application. Alternatively, an init callback can be used. These features are selected </p>
<p>during configuration. It is only possible to configure either ROM defaults or an init callback </p>
<p>for a block. </p>
<p>ROM defaults can be read explicit (by a call of </p>
<p>NvM_RestoreBlockDefaults()</p>
<p>). ROM </p>
<p>defaults will also be read implicitly during a read request, if no valid data could be read </p>
<p>from  NV-memory,  either  due  to  a  CRC  error  or  because  of  a  failure  reported  by  the </p>
<p>underlying MemHwA via MemIf. </p>
<p><b>4.4.5.5 </b></p>
<p><b>Checksum </b></p>
<p>For  each  block  an  optional  checksum  can  be  configured.  This  checksum  can  be  either </p>
<p>CRC16 or CRC32. The checksum is stored directly after the block data in the NV memory. </p>
<p>In RAM, CRC is not stored after the block data; it is stored in an internal variable. NVM </p>
<p>does not copy the data directly from the application variable to the NV memory. There is an </p>
<p>extra buffering within the module NVM, because it writes data and CRC with one request </p>
<p>to  the  NV  memory.  Thus  an  application  does  not  need  to  provide  any  space  for  NvM’s </p>
<p>checksum at the end of a RAM block. </p>
<p><b>4.4.6 </b></p>
<p><b>Prioritized or non-prioritized Queuing of asynchronous Requests </b></p>
<p>As mentioned before, asynchronous services are not processed immediately but queued </p>
<p>and  processed  asynchronously  by  the </p>
<p>NvM_MainFunction()</p>
<p>.  This  is  necessary  to </p>
<p>decrease the runtime of application tasks and to increase the predictability of their duration </p>
<p>(synchronous  write  jobs  on  an  EEPROM  or  Flash  would  block  your  task  for  multiple </p>
<p>milliseconds up to one second).  </p>
<p>Jobs </p>
<p>can </p>
<p>be </p>
<p>queued </p>
<p>either </p>
<p>prioritized </p>
<p>or </p>
<p>non-prioritized, </p>
<p>depending </p>
<p>on </p>
<p>the </p>
<p>user </p>
<p>configuration.  </p>
<p>If  job  prioritization  is  configured,  the  priorities  0  (immediate  priority)  until  255  (lowest </p>
<p>priority) can be selected for a block. It is important that the priority depends on the block, </p>
<p>rather than the request. Multi block requests always have a priority value greater than 255, </p>
<p>i.e. their priority is less than the lowest block specific priority; they will be processed after </p>
<p>all single block requests have been completed. </p>
<p>If block prioritization is not selected, the job queue works as a FIFO buffer. </p>
<p><b>4.4.7 </b></p>
<p><b>Asynchronous Job-End Polling </b></p>
<p>As </p>
<p>alluded </p>
<p>before, </p>
<p>asynchronous </p>
<p>requests </p>
<p>are </p>
<p>processed </p>
<p>in </p>
<p>the </p>
<p>background. </p>
<p>The </p>
<p>application  has  the  possibility  to  poll  the  NVM  for  the  end  of  the  service  by  calling </p>
<p>NvM_GetErrorStatus().</p>
<p> </p>
<p>NVM_REQ_PENDING</p>
<p>  will  be  returned  as  long  as  the  job  is </p>
<p>queued or in process. Once the job is finished </p>
<p>NvM_GetErrorStatus()</p>
<p> will return the </p>
<p>job result. </p>
<p><b>4.4.8 </b></p>
<p><b>Asynchronous Job-End Notification </b></p>
<p>Alternatively  to  poll  for  the  job-end,  a  job-end  notification  can  be  implemented  and </p>
<p>configured  for  every  block.  It  will  be  called  by  the  NVM  every  time  a  job  is  finished. </p>
<p>Finished means: Job finished either successfully or cancelled. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>23 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>4.4.9 </b></p>
<p><b>Immediate Priority Jobs and Cancellation of current Jobs </b></p>
<p>If job prioritization is selected, blocks of different priority exist. A new queued, higher prior </p>
<p>job, (e.g. priority 5) does not cancel/suspend a lower prioritized job (e.g. priority 10) if this </p>
<p>job is already processed. </p>
<p>The only exceptions for this are immediate priority jobs (priority 0) which can suspend a </p>
<p>running  job  that  priority  is  less.  The  suspended  job  will  be  restarted  after  all  jobs  with </p>
<p>higher priority are finished. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Pay attention that only blocks with high priority (0) can be erased (by using API </p>
<p>NvM_EraseNvBlock()</p>
<p>)! </p>
<p><b> </b></p>
<p><b>4.4.10 </b></p>
<p><b>Asynchronous CRC Calculation </b></p>
<p>The </p>
<p>(re-)calculation </p>
<p>of </p>
<p>a </p>
<p>block's </p>
<p>CRC </p>
<p>is </p>
<p>done </p>
<p>asynchronously </p>
<p>by </p>
<p>the </p>
<p>NvM_MainFunction()</p>
<p>. A CRC protected block's CRC value is calculated every time the </p>
<p>block shall be written to NV memory. If a block is read from NV memory the CRC value is </p>
<p>recalculated and compared to the one that was just read from NV memory. </p>
<p>If </p>
<p>NvM_SetRamBlockStatus(TRUE)</p>
<p> is called, the calculation of the CRC value over the </p>
<p>RAM  block’s  data  is  also  initiated,  unless  the  configuration  option  'Calculate  RAM  CRC' </p>
<p>(see chapter  7.2.4) was disabled for this block. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The purpose of requesting recalculation of the RAM CRC with every call to </p>
<p>NvM_SetRamBlockStatus</p>
<p> is to provide the possibility to re-use the RAM data even if a </p>
<p>reset (short power-loss, watchdog-reset) occurred. </p>
<p>Since CRC is quite time consuming, especially if performed frequently and/or over </p>
<p>large data blocks, it might be more applicable to disable it using the option mentioned </p>
<p>above. Then the data can only be re-used after a reset, if it did not change since last </p>
<p>CRC recalculation, caused by a write request or after the last read request (if it was </p>
<p>successful). </p>
<p><b> </b></p>
<p>The CRC calculation is done in the cyclically called service </p>
<p>NvM_MainFunction()</p>
<p>. To be </p>
<p>able to split a CRC calculation job, the number of CRC bytes to be calculated during one </p>
<p>cycle can be configured via the Configuration tool. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>24 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>If an AUTOSAR compliant CRC library implementation is used, the NvM ensures for all </p>
<p>supported CRC types that calculated values do not depend on the number of cycles </p>
<p>needed for calculation, i.e. for any number of calculation steps any CRC value is </p>
<p>guaranteed to be equal to the CRC value calculated over same data with one single </p>
<p>call to the appropriate library function. </p>
<p>For CRC32 this is a feature in NvM, beyond the requirements of AUTOSAR. For </p>
<p>compatibility with older releases, this feature can be disabled for CRC32, which is not </p>
<p>recommended, however. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.11 </b></p>
<p><b>Write Protection </b></p>
<p>The </p>
<p>NVM </p>
<p>supports </p>
<p>write </p>
<p>protection </p>
<p>of </p>
<p>any </p>
<p>NV </p>
<p>Block. </p>
<p>The </p>
<p>API </p>
<p>services </p>
<p>NvM_SetBlockProtection()</p>
<p> is used for locking and unlocking a NV block. The initial </p>
<p>write protection (after reset) can be configured. It will be set during </p>
<p>NvM_ReadAll()</p>
<p>. </p>
<p>A block can also be configured to be written once. The write protection of such a block can </p>
<p>not be removed by an API call. Nevertheless, it is possible to rewrite such a block by using </p>
<p>the extended runtime preparation during </p>
<p>NvM_ReadAll()</p>
<p>.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Pay attention, for a dataset block configured as write once only one dataset can be </p>
<p>written. The other datasets can’t be written any more. The whole block is protected </p>
<p>after first write. </p>
<p><b> </b></p>
<p><b>4.4.12 </b></p>
<p><b>Erase and Invalidate </b></p>
<p>There </p>
<p>are </p>
<p>two </p>
<p>services </p>
<p>specified </p>
<p>for </p>
<p>making </p>
<p>a </p>
<p>NV </p>
<p>block </p>
<p>unreadable: </p>
<p>NvM_EraseNvBlock()</p>
<p> and </p>
<p>NvM_InvalidateNvBlock().</p>
<p> </p>
<p>Invalidating  a  block  is  much  faster  than  erasing  the  block  because  only  the  status </p>
<p>information will be invalidated. </p>
<p><b>4.4.13 </b></p>
<p><b>Init Callbacks </b></p>
<p>For  any  block  ROM  defaults  or  an  initialization  callback  can  be  configured.  The  init </p>
<p>callback is called every time the default values of the block are to be loaded, e.g. during a </p>
<p>restore block defaults service. </p>
<p>The return value of the functions is specified but will not be used by the NVM. </p>
<p><b>4.4.14 </b></p>
<p><b>Define Locking/ Unlocking Services </b></p>
<p>In preemptive systems, it is necessary to protect some actions of preemption. That means </p>
<p>that  a  few  NVM  internal  actions  need  to  be  atomic.  So  for  protecting  these  sequences </p>
<p>functions for entering and leaving such a critical section can be configured. By default the </p>
<p>Operating System (OS) services are used. </p>
<p>The  Configuration  tool  can  be  used  to  define  or  configure  services  such  as  the  OSEK </p>
<p>services </p>
<p>GetResource(…)</p>
<p> and </p>
<p>ReleaseResource(…)</p>
<p> to lock and unlock resources. To </p>
<p>use these services of your Operating System, you must also publish the header file of the </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>25 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Operating System via Configuration tool (in the 'MyECU' window and the included tab 'OS </p>
<p>Services'). </p>
<p><b>4.4.15 </b></p>
<p><b>Interrupts </b></p>
<p>When interrupts occur during write accesses, they do not corrupt already saved data or </p>
<p>data  to  be  written.  To  ensure  this,  this  critical  sections  have  to  be  locked,  which  is </p>
<p>configurable via Configuration tool. </p>
<p><b>4.4.16 </b></p>
<p><b>Data Corruption </b></p>
<p>Write  operations  to  non-volatile  memories  are  non-atomic  operations.  A  power  supply </p>
<p>failure during write accesses may lead to corrupted/invalid data. Assuring that corrupted </p>
<p>data will not be signaled as valid is no more the task of the NVM but of the FEE or EA. </p>
<p><b>4.4.17 </b></p>
<p><b>Concurrent access to NV data for DCM </b></p>
<p>NVM </p>
<p>provides </p>
<p>possibility </p>
<p>to </p>
<p>access </p>
<p>NV </p>
<p>data </p>
<p>concurrently </p>
<p>with </p>
<p>NVM’s </p>
<p>applications. </p>
<p>Therefore each configured NVRAM block has an additional alias. Aliases are neither read </p>
<p>at </p>
<p>start-up </p>
<p>(during </p>
<p>NvM_ReadAll </p>
<p>processing) </p>
<p>nor </p>
<p>written </p>
<p>at </p>
<p>shut-down </p>
<p>(during </p>
<p>NvM_WriteAll processing).  </p>
<p>For </p>
<p>accessing </p>
<p>the </p>
<p>alias </p>
<p>of </p>
<p>a </p>
<p>NVRAM </p>
<p>block, </p>
<p>NVM </p>
<p>provides </p>
<p>the </p>
<p>global </p>
<p>macro </p>
<p>NvM_GetDcmBlockId(). </p>
<p>The macro expects the BlockId of the original NVRAM block </p>
<p>as </p>
<p>parameter </p>
<p>and </p>
<p>returns </p>
<p>the </p>
<p>block’s </p>
<p>alias </p>
<p>of </p>
<p>type </p>
<p>NvM_BlockIdType</p>
<p>. </p>
<p>Only </p>
<p>one </p>
<p>asynchronous request of one alias can be queued at a time. Otherwise the asynchronous </p>
<p>API  returns  with  E_NOT_OK,  which  indicates  that  the  request  has  not  been  accepted, </p>
<p>because of the block pending state check. </p>
<p>All jobs of DCM are always put into “Standard Job Queue”, even if blocks with immediate </p>
<p>priority are requested and job prioritization is enabled. So cancellation of pending jobs by </p>
<p>an immediate DCM-Block is avoided. The original priority itself is kept. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>DCM should lock the block with API NvM_SetBlockLockStatus (see chapter 6.4.8) </p>
<p>before requesting the alias. In case of an error during job processing, DCM should also </p>
<p>unlock the block again. In case of a successful job processing the block is </p>
<p>automatically unlocked after next start-up (after NvM_ReadAll processing).  </p>
<p>Gets a block locked with NvM_SetBlockLockStatus, the original NVRAM block and the </p>
<p>alias gets locked independent if the alias or the original block is requested. </p>
<p><b> </b></p>
<p><b>4.4.18 </b></p>
<p><b>Removed Functionality </b></p>
<p>Unlike in former versions of the NVM some functionality is no more the task of the NVM </p>
<p>but of the FEE or the EA. Among this are: </p>
<p></p>
<p> </p>
<p>Walking block concepts </p>
<p></p>
<p> </p>
<p>Block allocation in memory </p>
<p></p>
<p> </p>
<p>Force erase boundaries (of NV devices) </p>
<p></p>
<p> </p>
<p>Methods for ensuring that corrupted data will not be signaled as valid </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>26 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>4.4.19 </b></p>
<p><b>Changed Functionality </b></p>
<p>Unlike in former versions of the NVM some functionality is changed: </p>
<p>The checksum is stored directly after the block data only in the NV memory. In RAM, CRC </p>
<p>is not stored after the block data; it is stored in an internal variable. </p>
<p><b>4.5 </b></p>
<p><b>Error Handling </b></p>
<p><b>4.5.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>By </p>
<p>default, </p>
<p>development </p>
<p>errors </p>
<p>are </p>
<p>reported </p>
<p>to </p>
<p>the </p>
<p>DET </p>
<p>using </p>
<p>the </p>
<p>service </p>
<p>Det_ReportError()</p>
<p>as</p>
<p> </p>
<p>specified  in  [2],  if  development  error  reporting  is  enabled  (i.e. </p>
<p>pre-compile parameter </p>
<p>NVM_DEV_ERROR_DETECT == STD_ON)</p>
<p>. </p>
<p>If  another  module  is  used  for  development  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Det_ReportError()</p>
<p>. </p>
<p>The reported NVM ID can be seen here [chapter 3]. </p>
<p>The  reported  service  IDs  identify  the  services  which  are  described  in  6.4. The  following </p>
<p>table presents the service IDs and the related services: </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x00 </p>
<p>NvM_Init() </p>
<p>0x01 </p>
<p>NvM_SetDataIndex() </p>
<p>0x02 </p>
<p>NvM_GetDataIndex() </p>
<p>0x03 </p>
<p>NvM_SetBlockProtection() </p>
<p>0x04 </p>
<p>NvM_GetErrorStatus() </p>
<p>0x05 </p>
<p>NvM_SetRamBlockStatus() </p>
<p>0x06 </p>
<p>NvM_ReadBlock() </p>
<p>0x07 </p>
<p>NvM_WriteBlock() </p>
<p>0x08 </p>
<p>NvM_RestoreBlockDefaults() </p>
<p>0x09 </p>
<p>NvM_EraseNvBlock() </p>
<p>0x0A </p>
<p>NvM_CancelWriteAll()       </p>
<p>0x0B </p>
<p>NvM_InvalidateNvBlock() </p>
<p>0x0C </p>
<p>NvM_ReadAll() </p>
<p>0x0D </p>
<p>NvM_WriteAll() </p>
<p>0x0E </p>
<p>NvM_MainFunction() </p>
<p>0x0F </p>
<p>NvM_GetVersionInfo() </p>
<p>0x10 </p>
<p>NvM_SetBlockLockStatus() </p>
<p>Table 4-4   Mapping of service IDs to services </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>27 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>The errors reported to DET are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>0x14 </p>
<p>NVM_E_NOT_INITIALIZED </p>
<p>Every API service, except </p>
<p>NvM_Init()</p>
<p> and </p>
<p>NvM_GetVersionInfo(),</p>
<p> may check if NVM has </p>
<p>already been initialized. </p>
<p>0x15 </p>
<p>NVM_E_BLOCK_PENDING </p>
<p>As long as an asynchronous operation on a certain </p>
<p>Block has not been completed, no further requests </p>
<p>belonging to this Block are allowed.  </p>
<p>0x16 </p>
<p>NVM_E_LIST_ OVERFLOW </p>
<p>All asynchronous requests can only be en-queued if the </p>
<p>list is not full.  </p>
<p>0x17 </p>
<p>NVM_E_NV_WRITE_PROT</p>
<p>ECTED </p>
<p>NvM_WriteBlock(), NvM_EraseNvBlock()</p>
<p> and </p>
<p>NvM_InvalidateNvBlock()</p>
<p> check, if the block with </p>
<p>specified </p>
<p>BlockId</p>
<p> is write-protected, before it is written </p>
<p>(or erased or invalidated).  </p>
<p>0x18 </p>
<p>NVM_E_BLOCK_CONFIG </p>
<p>This service is not possible with this configuration. </p>
<p>0x0A </p>
<p>NVM_E_PARAM_BLOCK_ID NVM API services may check, whether the passed </p>
<p>BlockId</p>
<p> is in the allowed range. </p>
<p>0x0B </p>
<p>NVM_E_PARAM_BLOCK_ </p>
<p>TYPE </p>
<p>NvM_SetDataIndex()</p>
<p> and </p>
<p>NvM_GetDataIndex()</p>
<p> are </p>
<p>restricted to Dataset bocks. If these functions are called </p>
<p>with any other bock type, this error code is produced. </p>
<p>NvM_RestoreBlockDefaults()</p>
<p> is restricted to blocks </p>
<p>configured with ROM defaults or an init callback. </p>
<p>0x0C </p>
<p>NVM_E_PARAM_BLOCK_D</p>
<p>ATA_IDX </p>
<p>NvM_SetDataIndex()</p>
<p> may check the range of the </p>
<p>passed </p>
<p>DataIndex</p>
<p>.  </p>
<p>0x0D </p>
<p>NVM_E_PARAM_ADDRESS</p>
<p>A wrong pointer parameter was passed. (</p>
<p>NULL_PTR</p>
<p> </p>
<p>passed in an asynchronous call, e.g. </p>
<p>NvM_WriteBlock()</p>
<p> for a non-permanent block) </p>
<p>0x0E </p>
<p>NVM_E_PARAM_DATA </p>
<p>A </p>
<p>NULL_PTR</p>
<p> was passed in one of the synchronous </p>
<p>functions </p>
<p>NvM_GetDataIndex()</p>
<p>, </p>
<p>NvM_GetErrorStatus()</p>
<p> or </p>
<p>NvM_GetVersionInfo().</p>
<p> </p>
<p>0x20 </p>
<p>NVM_E_RAM_BLOCK_LEN</p>
<p>GTH </p>
<p>At least one RAM block’s size does not fit to the size </p>
<p>that has been configured. </p>
<p>May only be reported by </p>
<p>NvM_Init</p>
<p>. </p>
<p>0x21 </p>
<p>NVM_E_ROM_BLOCK_LEN</p>
<p>GTH </p>
<p>At least one ROM block’s size does not fit to the size </p>
<p>that has been configured. </p>
<p>May only be reported by </p>
<p>NvM_Init</p>
<p>. </p>
<p>Table 4-5   Errors reported to DET </p>
<p><b>4.5.1.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>AUTOSAR requires that API functions check the validity of their parameters. The checks in </p>
<p>Table  4-6  are  internal  parameter  checks  of  the  API  functions.  These  checks  are  for </p>
<p>development error reporting and can be en-/disabled separately. The configuration of en-</p>
<p>/disabling  the  checks  is  described  in  chapter  7.2.  En-/disabling  of  single  checks  is  an </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>28 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>addition to the AUTOSAR standard which requires to en-/disable the complete parameter </p>
<p>checking via the parameter </p>
<p>NVM_DEV_ERROR_DETECT</p>
<p>. </p>
<p> </p>
<p>The following table shows which parameter checks are performed on which services: </p>
<p><b>Check </b></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Service </b></p>
<p>Module’s </p>
<p>initialization </p>
<p>Block’s Manage-</p>
<p>ment Type check </p>
<p>Block’s Write </p>
<p>Protection check </p>
<p>Block’s Pending </p>
<p>State check </p>
<p>Block Id check </p>
<p>DataIndex check </p>
<p>Pointers check </p>
<p>Block length </p>
<p>check  check </p>
<p>NvM_Init() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_SetDataIndex() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_GetDataIndex() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_SetBlockProtection() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_GetErrorStatus() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_GetVersionInfo() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_SetRamBlockStatus() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_SetBlockLockStatus() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_ReadBlock() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_WriteBlock() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_RestoreBlockDefaults() </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_EraseNvBlock() </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_CancelWriteAll() </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_InvalidateNvBlock() </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_ReadAll() </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_WriteAll() </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_MainFunction() </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 4-6   Development Error Checking: Assignment of checks to services </p>
<p><b>4.5.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>Production  code  related  errors  are  reported  by  default  to  the  DEM  using  the  service </p>
<p>Dem_ReportErrorStatus()</p>
<p> as specified in [3]. </p>
<p>However, the service to be used (and the appropriate include file) for error reporting may </p>
<p>be configured. Please refer to chapter 7.2.5. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>29 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>If  another  module  is  used  for  production  code  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Dem_ReportErrorStatus()</p>
<p>. </p>
<p>The errors reported to DEM are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>NVM_E_INTEGRITY_FAILED </p>
<p>API request integrity failed </p>
<p>NVM_E_REQ_FAILED </p>
<p>API request failed </p>
<p>Table 4-7   Errors reported to DEM </p>
<p>Both shall have a value of type </p>
<p>Dem_EventIdType</p>
<p> (an integer type). It must be assured, </p>
<p>that these two error codes as well as the type are “published” to the NvM via the user-</p>
<p>specified include file. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>30 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>5 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR NVM into </p>
<p>an application environment of an ECU. </p>
<p><b>5.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the NVM contains the files which are described in the chapters 5.1.1 and </p>
<p>5.1.2: </p>
<p><b>5.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>NvM.h </p>
<p>This file must not be modified by user. </p>
<p>Defines the interface of NVM. Only this file shall be included by the </p>
<p>application.</p>
<p> </p>
<p>NvM_Cbk.h </p>
<p>This file must not be modified by user. </p>
<p>Contains the declarations of the callback functions being invoked by </p>
<p>EEPROM driver </p>
<p>NvM_Types.h </p>
<p>This file must not be modified by user. </p>
<p>Defines general types used by NVM.</p>
<p> </p>
<p>NvM.c / </p>
<p>NvM.lib/NvM.a </p>
<p>This file must not be modified by user. </p>
<p>Implementation of NVM, delivered as object library. </p>
<p>NvM_Act / </p>
<p>NvM_Crc / </p>
<p>NvM_JobProc / </p>
<p>NvM_Qry / </p>
<p>NvM_Queue.c *.h </p>
<p>These are files for internal use of the NvM. </p>
<p>If NVM is delivered as object then this parts are content of NvM.lib. </p>
<p>Table 5-1   Static files </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>31 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>32 / 84</p>
<p><b>5.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The  dynamic  files  are  generated  by  the  configuration  tool  DaVinci  Configurator.  Do  not </p>
<p>modify them manually. </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>NvM_Cfg.c </p>
<p>It contains configuration parameters of NVM which can be modified after </p>
<p>compilation of </p>
<p>NvM.c</p>
<p>. </p>
<p>NvM_Cfg.h </p>
<p>Contains “public” configuration parameters of NVM. They are (or might be) </p>
<p>also important to NvM’s user(s), or they may affect NvM’s API </p>
<p>It contains also “public” types and symbol declarations to be used by NVM </p>
<p>as well as its user(s). </p>
<p>NvM_PrivateCfg.h </p>
<p>Contains parameters as well as type and symbol declarations, which are </p>
<p>private to the NvM, i.e. they only affect internal behavior. </p>
<p>This file is intended to be included only by NvM’s sources. </p>
<p>Table 5-2   Generated files </p>
<p> </p>
<p> </p>
<p><b>5.2 </b></p>
<p><b>Include Structure </b></p>
<p>The </p>
<p>following </p>
<p>figure </p>
<p>illustrates </p>
<p>the </p>
<p>hierarchy </p>
<p>of </p>
<p>included </p>
<p>files. </p>
<p>It </p>
<p>also </p>
<p>shows </p>
<p>that </p>
<p>Std_Types.h and Nvm.h must be included by the application. </p>
<p> </p>
<p><b>deployment Analysis Model</b></p>
<p>Appl.c</p>
<p>Std_Types.h</p>
<p>NvM.h</p>
<p>NvM_Cfg.h</p>
<p>NvM_Types.h</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p> </p>
<p>Figure 5-1 The file structure of the NVM sections module </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>5.3 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions defined for the NVM and illustrates their assignment among each other. </p>
<p><b>Compiler Abstraction </b></p>
<p><b>Definitions </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>NVM_PRIVATE_CODE </p>
<p>NVM_PRIVATE_CONS</p>
<p>T</p>
<p>NVM_PRIVATE_DATA </p>
<p>NVM_FAST_DATA </p>
<p>NVM_PUBLIC_CODE </p>
<p>NVM_PUBLIC_CONST </p>
<p>NVM_APPL_CODE </p>
<p>NVM_APPL_CONST </p>
<p>NVM_APPL_DATA </p>
<p>NVM_CONFIG_CONS</p>
<p>T</p>
<p>NVM_CONFIG_DATA </p>
<p>NVM_START_SEC_CODE </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_ </p>
<p>VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_VAR_NOINIT_8</p>
<p>BIT </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_VAR_UNSPECIF</p>
<p>IED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_VAR_FAST_8BI</p>
<p>T </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_ </p>
<p>CONST_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_CONST_8BIT </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_CONST_16BIT </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_ </p>
<p>CONST_DESCRIPTOR_TABLE </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_VAR_POWER_</p>
<p>ON_INIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 5-3   Compiler abstraction and memory mapping </p>
<p>For  each  start  keyword,  there  is  a  stop  keyword. As  these  stop  keywords  are  used  to </p>
<p>restore the default section, the stop keywords do not need to be configured. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The size of the section NVM_START_SEC_CONST_DESCRIPTOR_TABLE depends </p>
<p>on the configuration settings. It makes sense to create an own section for this item if it </p>
<p>becomes too big to link it into the same page/section as the elements of the </p>
<p>MICROSAR NVM module. In this case the according memory modifier has to be used </p>
<p>in order to address the elements in this section. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>33 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b> </b></p>
<p>Above </p>
<p>listed </p>
<p>section </p>
<p>keywords </p>
<p>are </p>
<p>compiler </p>
<p>dependent. </p>
<p>They </p>
<p>are </p>
<p>set </p>
<p>in </p>
<p>the </p>
<p>files </p>
<p>MemMap.h and Compiler.h/Compiler_Cfg.h. Compiler pragmas may be used to open and </p>
<p>close a special memory section. As these  pragmas are already used when creating the </p>
<p>NVM library (object code) these parameters are not link-time configurable. Libraries with </p>
<p>different settings can be obtained at Vector Informatik GmbH. Please refer to the Software </p>
<p>release notes (SRN) (or to the delivered MemMap.h, Compiler.h/Compiler_Cfg.h) for the </p>
<p>settings made for your delivery. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>The sections configured above have to fit to the link file configuration as well as to </p>
<p>the memory modifier settings in the Compiler Abstraction! </p>
<p><b> </b></p>
<p><b>5.4 </b></p>
<p><b>Dependencies on SW Modules </b></p>
<p><b>5.4.1 </b></p>
<p><b>OSEK / AUTOSAR OS </b></p>
<p>An  OS  environment  is  not  necessary  unless  it  is  used  for  interrupt  or  resource  locking </p>
<p>issues. </p>
<p><b>5.4.2 </b></p>
<p><b>DEM </b></p>
<p>NVM depends on an implementation of the DEM. It is used to report errors occurred during </p>
<p>processing. The header file declaring the API must be configured via Configuration tool. </p>
<p><b>5.4.3 </b></p>
<p><b>DET </b></p>
<p>Module  DET:  Can  be  used  in  development  mode.  It  records  all  development  errors  for </p>
<p>evaluation  purposes.  Its  usage  can  be  enabled/disabled  via  Configuration  tool  by  the </p>
<p>switch “Development Error Reporting”. </p>
<p><b>5.4.4 </b></p>
<p><b>MEMIF </b></p>
<p>The NVM uses configuration parameters defined by the MemIf. </p>
<p><b>5.4.5 </b></p>
<p><b>CRC Library </b></p>
<p>For  CRC  calculations  the  NVM  uses  the  services  provided  by  an AUTOSAR  compliant </p>
<p>CRC Library. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>Since the “Configuration Id Block” (see also chapter  7.2.3) must be configured with </p>
<p>either CRC16 or CRC32; you will always need the CRC library. </p>
<p><b> </b></p>
<p><b>5.4.6 </b></p>
<p><b>Callback Functions </b></p>
<p>MICROSAR  NVM  offers  the  usage  of  notifications  that  can  be  mapped  to  callback </p>
<p>functions  provided  by  other  modules,  in  order  to  inform  them  about  job  completion.  For </p>
<p>each  NVRAM  block  a  separate  callback  function  may  be  defined  by  application.  These </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>34 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>callback function declarations must be made within the application and be included by the </p>
<p>NVM. </p>
<p><b>5.4.7 </b></p>
<p><b>RTE </b></p>
<p>When at least one Service Port is enabled (see chapter 7.2.4) and corresponding PIM (see </p>
<p>TechnicalReference of RTE) is available, all additional necessary header files are included </p>
<p>automatically. SWC must not include </p>
<p>NvM.h.</p>
<p> </p>
<p><b>5.5 </b></p>
<p><b>Integration Steps </b></p>
<p>To integrate MICROSAR NVM into your system, several steps beginning with configuration </p>
<p>have to be done: </p>
<p></p>
<p> </p>
<p>Configure </p>
<p>MICROSAR </p>
<p>NVM </p>
<p>and </p>
<p>MICROSAR </p>
<p>MEMIF </p>
<p>according </p>
<p>to </p>
<p>applications’ </p>
<p>requirements using MICROSAR Configuration tool or a GCE editor.  </p>
<p></p>
<p> </p>
<p>Generate the configuration files of the modules NVM and MEMIF. </p>
<p></p>
<p> </p>
<p>Configure </p>
<p>and </p>
<p>generate </p>
<p>the </p>
<p>lower </p>
<p>modules </p>
<p>FEE/EA </p>
<p>and </p>
<p>the </p>
<p>driver </p>
<p>modules </p>
<p>for </p>
<p>FLS/EEP. </p>
<p></p>
<p> </p>
<p>If  a  FEE  or  EA  module  is  used  that  is  not  delivered  by  Vector,  make  sure  that  the </p>
<p>parameters that are exchanged between the two modules are consistent. </p>
<p></p>
<p> </p>
<p>Each application is responsible to make their RAM and ROM blocks available (do not </p>
<p>use  the  static  modifier!).  The  MICROSAR  NVM  includes  the  file  that  declares  these </p>
<p>blocks and defines memory modifier to address the blocks. This memory modifier can </p>
<p>be changed in the </p>
<p>Compiler.h</p>
<p>. </p>
<p></p>
<p> </p>
<p>Make sure all applications using MICROSAR NVM include </p>
<p>Std_Types.h</p>
<p> and </p>
<p>NvM.h</p>
<p> </p>
<p>(in that order). </p>
<p></p>
<p> </p>
<p>Check  the  initialization  of  the  drivers  FLS/EEP,  FEE/EA  and  the  MICROSAR  NVM </p>
<p>(MICROSAR NVM does not initialize any other module). </p>
<p></p>
<p> </p>
<p>Make  sure  that  the  initialization  sequence  is  correct.  FEE/EA  and  FLS/EEP  must  be </p>
<p>initialized before any NVM request (usually </p>
<p>NvM_ReadAll()</p>
<p>) can be used. </p>
<p></p>
<p> </p>
<p>Ensure that the main functions of the NVM, the FEE/EA and the FLS/EEP drivers are </p>
<p>called  cyclically.  This  must  be  done  within  an  application  task  running  at  sufficient </p>
<p>priority (to avoid starving). </p>
<p></p>
<p> </p>
<p>Ensure that a waiting task frees CPU to make it possible that the action for the task is </p>
<p>waiting for, can be done! </p>
<p>Finally: Compile and link your MICROSAR NVM together with your project. </p>
<p><b>5.6 </b></p>
<p><b>Estimating Resource Consumption </b></p>
<p>Besides resources needed anyway when using NVM, there are some configuration options </p>
<p>influencing  resource  consumption  of  your  system.  In  general  these  options  affect  usage </p>
<p>independently  of  the  number  of  configured  NVRAM  blocks.  Additionally  each  NVRAM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>35 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>block itself requires resources in RAM, ROM and NV, respectively. The following sections </p>
<p>will summarize the options and give you hints, how to estimate their effects. </p>
<p><b>5.6.1 </b></p>
<p><b>RAM Usage </b></p>
<p>In general, each NVRAM block consumes RAM – for the application-defined RAM-block as </p>
<p>well as for the internal block management structure, which holds information about request </p>
<p>results, blocks’ attributes and the data indexes. The amount of RAM occupied by the RAM </p>
<p>block itself should equal the configured length. However, the actual size depends on the </p>
<p>size of the object (variable) the application declares. The size of each management area is </p>
<p>currently 3 bytes. </p>
<p>The configuration options affecting RAM consumption pertain to size of the queue(s) and </p>
<p>the option job prioritization. The size of one queue entry depends on the target platform </p>
<p>and the compiler options used. It ranges from 8 bytes (16 bit platform, 16bit pointers) to 12 </p>
<p>bytes (32bit architectures, aligned structure members). </p>
<p>Additionally the setting “Internal Buffer for Crc Handling” affects RAM usage: If enabled, </p>
<p>the NVM internally allocates a RAM buffer. Its size equals the size of largest configured </p>
<p>NVRAM block with CRC, having a permanent RAM block associated, including CRC size.  </p>
<p>Additionally, each NVRAM block with CRC automatically gets a dedicated RAM area for </p>
<p>CRC storage, exactly matching CRC’s size. As a result, applications’ RAM blocks do not </p>
<p>need to provide additional space for CRC. Therefore it does not affect RAM consumption. </p>
<p><b>5.6.2 </b></p>
<p><b>ROM Usage </b></p>
<p>The largest amount of ROM resources being needed depends on the number (and sizes) </p>
<p>of  blocks  configured  with  ROM  defaults.  The  remarks  about  RAM  blocks  also  apply  to </p>
<p>ROM  blocks.  Especially  for  block  management  type  'DATASET_ROM'.  The  size  of  the </p>
<p>object (variable) declared by application must be considered, rather than the configured </p>
<p>NVRAM block length.  </p>
<p>Because each NVRAM block’s configuration is compiled into a constant block descriptor, </p>
<p>the  ROM  needed  is  also  affected  by  the  whole  number  of  configured  NVRAM  blocks. </p>
<p>Again, the size of one descriptor varies with the target platform and the compiler options </p>
<p>used.  It  can  be  from  18  bytes  (16bit  architecture,  16bit  pointers)  to  44  bytes  (32bit </p>
<p>architecture, 32bit pointers, structure members aligned). </p>
<p>There are some configuration options affecting NVM's code size. The options  </p>
<p></p>
<p> </p>
<p>Development mode </p>
<p></p>
<p> </p>
<p>API configuration class </p>
<p></p>
<p> </p>
<p>use Version Info API </p>
<p></p>
<p> </p>
<p>use Set Ram Block Status API </p>
<p>result in switching on/off complete code sections. </p>
<p><b>5.6.3 </b></p>
<p><b>NV Usage </b></p>
<p>The requirements on NV memory space per device are affected by the NVRAM blocks and </p>
<p>their configuration. Basically, each NV block allocates as many bytes as specified for its </p>
<p>length,  plus  CRC  bytes  (if  configured).  Underlying  components  (FEE  or  EA)  would  also </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>36 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>add  internal  management  information,  as  well  as  padding  bytes  to  meet  NV  memory </p>
<p>device’s alignment requirements. </p>
<p>According  to  the  management  type  of  the  NVRAM  block,  it  consists  of  one  ore  more </p>
<p>blocks consuming NV space: </p>
<p></p>
<p> </p>
<p>NATIVE  </p>
<p> </p>
<p> </p>
<p> </p>
<p>1 NV Block </p>
<p></p>
<p> </p>
<p>REDUNDANT </p>
<p>2 NV Blocks </p>
<p></p>
<p> </p>
<p>DATASET  </p>
<p> </p>
<p> </p>
<p>“Count” NV Blocks </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>37 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6 </b></p>
<p><b>API Description </b></p>
<p><b>6.1 </b></p>
<p><b>Interfaces Overview </b></p>
<p>For an interfaces overview please see Figure 3-2. </p>
<p><b>6.2 </b></p>
<p><b>Type Definitions </b></p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>NVM_REQ_OK (see chapter </p>
<p>4.5.1) </p>
<p>The last asynchronous request has </p>
<p>been finished successfully. This is the </p>
<p>default value after reset. This status </p>
<p>has the value 0. </p>
<p>NVM_REQ_NOT_OK (see chapter </p>
<p>4.5.1) </p>
<p>The last asynchronous request has </p>
<p>been finished unsuccessfully. </p>
<p>NVM_REQ_PENDING (see chapter </p>
<p>4.5.1) </p>
<p>An asynchronous request is currently </p>
<p>being processed by the task. </p>
<p>NVM_REQ_INTEGRITY_FAILED (see </p>
<p>chapter 4.5.1) </p>
<p>A NV block was supposed to be valid </p>
<p>but it turned out that the data are </p>
<p>corrupted (either CRC mismatch or the </p>
<p>FEE or the EA reported an </p>
<p>inconsistency). </p>
<p>NVM_REQ_BLOCK_SKIPPED (see </p>
<p>chapter 4.5.1) </p>
<p>The block was skipped during a multi </p>
<p>block request. </p>
<p>NVM_REQ_NV_INVALIDATED (see </p>
<p>chapter 4.5.1) </p>
<p>The NV block is marked as invalid. </p>
<p>NvM_RequestResult </p>
<p>Type </p>
<p>uint8 </p>
<p>An asynchronous API </p>
<p>service can have following </p>
<p>results or status that can be </p>
<p>polled by </p>
<p>NvM_GetErrorStatus()</p>
<p>. </p>
<p>NVM_REQ_CANCELLED (see </p>
<p>chapter 4.5.1) </p>
<p>The last asynchronous </p>
<p>NvM_WriteAll() </p>
<p>has been </p>
<p>cancelled by </p>
<p>NvM_CancelWriteAll().</p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>38 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>39 / 84</p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>NvM_BlockIdType </p>
<p>uint16 </p>
<p>It is the type of a block </p>
<p>handle that is used by the </p>
<p>application in order to </p>
<p>access a NVM block. There </p>
<p>are two reserved IDs: </p>
<p></p>
<p> </p>
<p>Block ID 0 for multi </p>
<p>block requests (Block ID </p>
<p>0 is only allowed for API </p>
<p>NvM_GetErrorStatus()) </p>
<p>and </p>
<p></p>
<p> </p>
<p>Block ID 1 for the </p>
<p>configuration Id block </p>
<p>The block handles are </p>
<p>created as defines in an </p>
<p>ascending define list. </p>
<p> </p>
<p> </p>
<p>[0 </p>
<p>2^(16-</p>
<p>NVM_DATASET_SELECTION_BITS)-</p>
<p>1] </p>
<p>NVM_DATASET_SELECTION_BITS</p>
<p> is </p>
<p>the maximum number of bits that are </p>
<p>needed in order to store the maximum </p>
<p>dataset value. </p>
<p>Example: </p>
<p>The dataset block with the greatest </p>
<p>number of datasets has six of them. So </p>
<p>it is necessary to store the data index </p>
<p>0…5 to select the appropriate dataset </p>
<p>block. To store the value five, three bits </p>
<p>are necessary. So </p>
<p>NVM_DATASET_SELECTION_BITS</p>
<p> has </p>
<p>the value 3. </p>
<p>This means that only the block IDs </p>
<p>0…2^(16-3)-1 = 2…8191 are available </p>
<p>as block handles.</p>
<p> </p>
<p>NvM_ServiceIdType </p>
<p>uint8 </p>
<p>Service Ids of the different </p>
<p>service routines of the </p>
<p>NVM. </p>
<p>NVM_INIT (0u) </p>
<p>NVM_SET_DATA_INDEX (1u) </p>
<p>NVM_GET_DATA_INDEX (2u) </p>
<p>NVM_SET_BLOCK_PROTECTION (3u)</p>
<p>NVM_GET_ERROR_STATUS (4u) </p>
<p>NVM_SET_RAM_BLOCK_STATUS (5u)</p>
<p>NVM_READ_BLOCK (6u) </p>
<p>NVM_WRITE_BLOCK (7u) </p>
<p>NVM_RESTORE_BLOCK_DEFAULTS </p>
<p>(8u) </p>
<p>NVM_ERASE_BLOCK (9u) </p>
<p>NVM_CANCEL_WRITE_ALL (10u) </p>
<p>NVM_INVALIDATE_NV_BLOCK (11u)</p>
<p>NVM_READ_ALL (12u) </p>
<p>NVM_WRITE_ALL (13u) </p>
<p>NVM_MAINFUNCTION (14u) </p>
<p>NVM_GET_VERSION_INFO (15u) </p>
<p>NVM_SET_BLOCK_LOCK_STATUS </p>
<p>(16u) </p>
<p>The single values are applied as </p>
<p>defines. </p>
<p>See also chapter </p>
<p>4.5.1 </p>
<p>Table 6-1   Type definitions </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.3 </b></p>
<p><b>Global API Constants </b></p>
<p>These  NVM  specific  constants  are  available  through  the  inclusion  of </p>
<p>NvM.h</p>
<p>.  They  are </p>
<p>configurable within DaVinci Configurator Pro. </p>
<p></p>
<p> </p>
<p>NVM_COMPILED_CONFIG_ID</p>
<p>: configured identifier for the NV memory layout  </p>
<p></p>
<p> </p>
<p>NVM_NO_OF_BLOCK_IDS</p>
<p>:  number  of  all  defined  NVRAM  Blocks  (including  reserved </p>
<p>blocks) </p>
<p></p>
<p> </p>
<p>Name of the NVRAM blocks </p>
<p> </p>
<p><b>6.4 </b></p>
<p><b>Services provided by NVM </b></p>
<p>The NVM API consists of services, which are realized by function calls. </p>
<p><b>6.4.1 </b></p>
<p><b>NvM_Init </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_Init </b>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Service for basic NVM initialization. (Exclusively called by ECU State Manager). The time consuming </p>
<p>NVRAM block initialization and setup according to the block descriptor is done by the </p>
<p>NvM_ReadAll</p>
<p> </p>
<p>request. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-2   NvM_Init </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>40 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.2 </b></p>
<p><b>NvM_SetDataIndex </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_SetDataIndex </b>( NvM_BlockIdType BlockId,  </p>
<p>                        uint8 DataIndex ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>DataIndex </p>
<p>Index position of a Block in the NV Block of Dataset type. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The request sets the specified index to associate a dataset NV block (with/without ROM blocks) with its </p>
<p>corresponding RAM block. The </p>
<p>DataIndex</p>
<p> needs to have a valid value before a read/write/erase or </p>
<p>invalidate request is initiated. </p>
<p>If the dataset block has a set of ROM defaults, this function is used (prior to </p>
<p>NvM_ReadBlock()</p>
<p>) to select </p>
<p>the appropriate ROM set.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-3   NvM_SetDataIndex </p>
<p><b>6.4.3 </b></p>
<p><b>NvM_GetDataIndex </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_GetDataIndex </b>( NvM_BlockIdType BlockId,  </p>
<p>                        uint8* DataIndexPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>DataIndexPtr </p>
<p>Address where the current DataIndex shall be written to </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The request passes the current DataIndex (association) of the specified dataset block. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM manager shall have been initialized before this request is called. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>41 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-4   NvM_GetDataIndex </p>
<p><b>6.4.4 </b></p>
<p><b>NvM_SetBlockProtection </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_SetBlockProtection </b>( NvM_BlockIdType BlockId,  </p>
<p>                              boolean ProtectionEnabled ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>ProtectionEnabled </p>
<p>This parameter is responsible for setting the write protection of a selected </p>
<p>NVRAM block: </p>
<p>TRUE</p>
<p>: enable protection </p>
<p>FALSE</p>
<p>: disable protection </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The request sets the write protection for the NV block. Any further write/erase/invalidate requests to the </p>
<p>NVRAM block are rejected synchronously if the NV block-write protection is set. The data area of the RAM </p>
<p>block remains writable in any case. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. The protection can not be </p>
<p>released for a write once block that has already been written. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-5   NvM_SetBlockProtection </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>42 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.5 </b></p>
<p><b>NvM_GetErrorStatus </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_GetErrorStatus </b>( NvM_BlockIdType BlockId,  </p>
<p>                          uint8* RequestResultPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>RequestResultPtr </p>
<p>Pointer where the result shall be written to. </p>
<p>Result is of type </p>
<p>NvM_RequestResultType</p>
<p>. All possible results are </p>
<p>described in chapter 6.2. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The request reads the block dependent error/status information and writes it to the given address. The </p>
<p>status/error information was set by a former or current asynchronous request. </p>
<p>This API can also be requested with BlockId 0 (multi block). Then the multi block error/status information </p>
<p>will be read to the given address. Only </p>
<p>NvM_ReadAll()</p>
<p> and </p>
<p>NvM_WriteAll()</p>
<p> are multi block requests </p>
<p>and change the status/error information of the multi block.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-6   NvM_GetErrorStatus </p>
<p><b>6.4.6 </b></p>
<p><b>NvM_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_GetVersionInfo </b>( Std_VersionInfoType* versioninfo ) </p>
<p><b>Parameter </b></p>
<p>versioninfo </p>
<p>Pointer to the address where the version info shall be written to. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The request writes the version info (Vendor ID, module ID, Instance ID, SW major version, SW minor </p>
<p>version, SW patch version) to the given pointer. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if the pre-compile switch “Use version info API” is enabled. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>43 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-7   NvM_GetVersionInfo </p>
<p><b>6.4.7 </b></p>
<p><b>NvM_SetRamBlockStatus </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_SetRamBlockStatus </b>( NvM_BlockIdType BlockId,  </p>
<p>                             boolean BlockChanged )  </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The block identifier. </p>
<p>BlockChanged </p>
<p>Sets the new status of the RAM block: </p>
<p>TRUE: Validates the RAM block and marks it as changed. If the block has a </p>
<p>CRC and the option NVM_CALC_RAM_BLOCK_CRC is TRUE the CRC </p>
<p>calculation is initiated. </p>
<p>FALSE: Mark the block as unchanged </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The request sets a block’s status to valid/changed respectively to unchanged. Setting a block to changed </p>
<p>marks it for writing it during </p>
<p>NvM_WriteAll()</p>
<p>. </p>
<p>If the block shall be set to “changed”, it has a CRC and the option </p>
<p>NVM_CALC_RAM_BLOCK_CRC</p>
<p> is </p>
<p>TRUE</p>
<p> </p>
<p>the CRC calculation of the RAM block is initiated. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Though this service is defined to operate synchronously, the CRC re-calculation will be </p>
<p>performed asynchronously. However, there is no restriction on accessing RAM block data, or on </p>
<p>calling other services. Consistency of data and CRC is ensured by WriteBlock/WriteAll, which </p>
<p>will unconditionally recalculate the CRC before writing. Requesting CRC re-calculation, using </p>
<p>NvM_SetRamBlockStatus</p>
<p> again, will be recognized in a save way, the calculation will be re-</p>
<p>queued, if necessary.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-8   NvM_SetRamBlockStatus </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>44 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.8 </b></p>
<p><b>NvM_SetBlockLockStatus </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>NvM_SetBlockLockStatus </b>( NvM_BlockIdType BlockId,  </p>
<p>                                        boolean Locked ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>Locked </p>
<p>This parameter is responsible for setting the lock protection status of a </p>
<p>selected NVRAM block: </p>
<p>TRUE</p>
<p>: Lock shall be enabled  </p>
<p>FALSE</p>
<p>: Lock shall be disabled </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted. </p>
<p><b>Functional Description </b></p>
<p>Service for setting/resetting the lock of a NV block.  </p>
<p>The NV contents associated to the NVRAM block identified by BlockId, will not be modified by any request. </p>
<p>The Block is skipped during </p>
<p>NvM_WriteAll</p>
<p>. Other requests, that are </p>
<p>NvM_WriteBlock</p>
<p>, </p>
<p>NvM_InvalidateNvBlock</p>
<p>, </p>
<p>NvM_EraseNvBlock</p>
<p>, return without error notification to Det or Dem.  </p>
<p>During processing of </p>
<p>NvM_ReadAll</p>
<p>, this NVRAM block shall be loaded from NV memory. After loading the </p>
<p>block from NV memory the lock is disabled again. </p>
<p>If a block gets locked with </p>
<p>NvM_SetBlockLockStatus</p>
<p>, the original NVRAM block and the alias is locked. </p>
<p>The lock is independent on the requested BlockId, original one or DCM BlockId. (see chapter 4.4.17) </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This function is an addition to the standard AUTOSAR specification.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available independent on API configuration class. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. The protection can not be </p>
<p>released for a write once block that has already been written. </p>
<p></p>
<p> </p>
<p>The service is only usable by BSW components, it is not accessible via RTE. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called by DCM. </p>
<p>Table 6-9   NvM_SetBlockLockStatus </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>45 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.9 </b></p>
<p><b>NvM_MainFunction </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_MainFunction </b>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This function has to be called cyclically. It is the entry point of the NVRAM Manager. In here the processing </p>
<p>of the asynchronous jobs (read/write/erase/invalidate/CRC calculation…) is handled. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-10 NvM_MainFunction </p>
<p> </p>
<p><b>6.4.10 </b></p>
<p><b>NvM_ReadBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>NvM_ReadBlock </b>( NvM_BlockIdType BlockId,  </p>
<p>                               uint8* NvM_DstPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>NvM_DstPtr </p>
<p>Pointer where the data of a non-permanent RAM block shall be written to. If </p>
<p>the block is permanent </p>
<p>NULL_PTR</p>
<p> shall be passed. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. because of a list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to copy the data of the NV block to its corresponding RAM block. This function queues the read </p>
<p>request and returns the acceptance result synchronously.  </p>
<p>The NVM can notify the application by callback when the service is finished.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development mode the </p>
<p>service will not accept the call if the block is already queued (either for this or for a different service). </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>46 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-11  NvM_ReadBlock </p>
<p><b>6.4.11 </b></p>
<p><b>NvM_WriteBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>NvM_WriteBlock </b>( NvM_BlockIdType BlockId,  </p>
<p>                                const uint8* NvM_SrcPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>NvM_SrcPtr </p>
<p>Pointer where the data of a non-permanent RAM block shall be read from. If </p>
<p>the block is permanent, </p>
<p>NULL_PTR</p>
<p> shall be passed. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request for copying data from the RAM block to its corresponding NV block. This function queues the write </p>
<p>request and returns the acceptance result synchronously.  </p>
<p>If the block has a CRC, the RAM block CRC will be recalculated before the data and the CRC are written to </p>
<p>the NV memory, even if the service </p>
<p>NvM_SetRamBlockStatus</p>
<p> was called before and the configuration </p>
<p>was set that within this service, the CRC calculation should be done. </p>
<p>If writing the data to NV memory fails, the NVM will retry writing. The number of write retries is a </p>
<p>configuration option. </p>
<p>The NVM can notify the application by callback when the service is finished.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development mode the </p>
<p>service will not accept the call if the block is already queued (either for this or for a different service). If </p>
<p>the block’s write protection is activated it can’t be written. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-12 NvM_WriteBlock </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>47 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.12 </b></p>
<p><b>NvM_RestoreBlockDefaults </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>NvM_RestoreBlockDefaults </b>( NvM_BlockIdType BlockId,   </p>
<p>                                          uint8* NvM_DstPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>NvM_DstPtr </p>
<p>Pointer where the data of a non-permanent RAM block shall be written to. If </p>
<p>the block is permanent, </p>
<p>NULL_PTR</p>
<p> shall be passed. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to copy the ROM block default data to its corresponding RAM block. The selected block needs </p>
<p>either ROM defaults or an initialization callback.  </p>
<p>This function queues the restore request and returns the acceptance result synchronously.  </p>
<p>The NVM can notify the application by callback when the service is finished.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development mode the </p>
<p>service will not accept the call if the block is already queued (either for this or for a different service). </p>
<p>This function is not intended for reading ROM sets of a dataset ROM block. Use </p>
<p>NvM_ReadBlock()</p>
<p> </p>
<p>instead for these blocks. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-13 NvM_RestoreBlockDefaults </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>48 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.13 </b></p>
<p><b>NvM_EraseNvBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>NvM_EraseNvBlock </b>( NvM_BlockIdType BlockId ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to erase a specified NV block. This function queues the erase request and returns the acceptance </p>
<p>result synchronously. </p>
<p>The NVM can notify the application by callback when the service is finished</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development mode the </p>
<p>service will not accept the call if the block is already queued (either for this or for a different service). If </p>
<p>the block’s write protection is activated it also can’t be erased. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Pay attention that only high priority jobs (priority 0) can be erased!</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-14 NvM_EraseNvBlock </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>49 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.14 </b></p>
<p><b>NvM_InvalidateNvBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>NvM_InvalidateNvBlock </b>( NvM_BlockIdType BlockId ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to invalidate a specified NV block. This function queues the invalidate request and returns the </p>
<p>acceptance result synchronously.  </p>
<p>The NVM can notify the application by callback when the service is finished.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if API configuration class 3 is configured.  </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development mode the </p>
<p>service will not accept the call if the block is already queued (either for this or for a different service). If </p>
<p>the block’s write protection is activated it also can’t be invalidated. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-15 NvM_InvalidateNvBlock </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>50 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.15 </b></p>
<p><b>NvM_ReadAll </b></p>
<p><b>Prototype </b></p>
<p>Void <b>NvM_ReadAll </b>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to (re)load all RAM blocks that have the option </p>
<p>NVM_SELECT_BLOCK_FOR_READALL</p>
<p> selected. </p>
<p>The function queues the request that will be processed asynchronously in </p>
<p>NvM_MainFunction()</p>
<p>. </p>
<p>Before reloading a block’s NV data, it first checks if the RAM block data is still valid. This can only be </p>
<p>assured if the block has a checksum. In case of valid RAM data, the NV data will not be reloaded.  </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Non-permanent blocks and dataset blocks are also skipped during a ReadAll job.</p>
<p> </p>
<p><b> </b></p>
<p>The first block that is read from NV memory is the configuration ID (block 1). The value is compared to the </p>
<p>compiled configuration ID. The result of this check affects the further processing of the ReadAll job, </p>
<p>depending on the setting of “Dynamic Configuration Handling” (see chapter 7.2.2): If disabled, all NVRAM </p>
<p>blocks will be processed as described above, regardless of the result of reading/checking the configuration </p>
<p>ID (match/mismatch/block invalid/integrity error/read failure). </p>
<p>If “Dynamic Configuration Handling” is enabled, the NVM loads all NVRAM blocks as described above, only </p>
<p>if it detected a configuration ID match. Otherwise (including failures) those blocks having option “Resistant </p>
<p>to Changed Software” (see chapter 7.2.4) set will be loaded as if the configuration ID matched. The </p>
<p>NVRAM blocks having this option cleared will be restored with ROM defaults, if available, and if “Select for </p>
<p>ReadAll” was configured. </p>
<p>When the last block is reloaded the NVM can notify the application by callback (configurable multi block </p>
<p>callback).</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is a multi block request. </p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This function is intended only to be called by the ECU State Manager during startup. </p>
<p>Table 6-16 NvM_ReadAll </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>51 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.4.16 </b></p>
<p><b>NvM_WriteAll </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_WriteAll </b>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to write all blocks with changed RAM data to the NV memory. The function will queue the WriteAll </p>
<p>job that will be processed asynchronously. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Non permanent and dataset blocks will not be written during </p>
<p>NvM_WriteAll()</p>
<p>.</p>
<p> </p>
<p><b> </b></p>
<p>When the last block is written the NVM can notify the application by callback (configurable multiblock </p>
<p>callback).</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is a multi block request. </p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This function is intended only to be called by the ECU State Manager during shutdown. </p>
<p>Table 6-17 NvM_WriteAll </p>
<p><b>6.4.17 </b></p>
<p><b>NvM_CancelWriteAll </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_CancelWriteAll </b>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to cancel a running </p>
<p>NvM_WriteAll()</p>
<p> request. This call en-queues the request that will be </p>
<p>processed asynchronously. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is asynchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>52 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-18 NvM_CancelWriteAll </p>
<p><b>6.4.18 </b></p>
<p><b>NvM_KillWriteAll </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_KillWriteAll </b>( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to cancel a running </p>
<p>NvM_WriteAll()</p>
<p> request destructively. To keep required wake-up response </p>
<p>times in an ECU the ECUM has the possibility to time-out a non-destructive </p>
<p>NvM_CancelWriteAll()</p>
<p> </p>
<p>request. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is available if the pre-compile switch “NvmKillWriteAllApi” (only in Generic Editor in </p>
<p>container “Nvm_30_CommonVendorParams”) is enabled independent on API configuration class. </p>
<p></p>
<p> </p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This service is expected to be called by ECUM </p>
<p>Table 6-19 NvM_KilllWriteAll </p>
<p><b>6.5 </b></p>
<p><b>Services used by NVM </b></p>
<p>In the following table services provided by other components, which are used by the NVM </p>
<p>are listed. For details about prototype and functionality refer to the documentation of the </p>
<p>providing component. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>53 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p>DET </p>
<p>Det_ReportError </p>
<p>DEM </p>
<p>Dem_SetEventStatus </p>
<p>MEMIF </p>
<p>MemIf_Read </p>
<p>MEMIF </p>
<p>MemIf_InvalidateBlock </p>
<p>MEMIF </p>
<p>MemIf_GetJobResult </p>
<p>MEMIF </p>
<p>MemIf_Write </p>
<p>MEMIF </p>
<p>MemIf_EraseImmediateBlock </p>
<p>MEMIF </p>
<p>MemIf_GetStatus </p>
<p>MEMIF </p>
<p>MemIf_Cancel </p>
<p>MEMIF </p>
<p>MemIf_SetMode </p>
<p>CRC </p>
<p>Crc_CalculateCRC16 </p>
<p>CRC </p>
<p>Crc_CalculateCRC32 </p>
<p>EA </p>
<p>Used by MEMIF </p>
<p>FEE </p>
<p>Used by MEMIF </p>
<p>Table 6-20 Services used by the NVM </p>
<p><b>6.6 </b></p>
<p><b>Callback Functions </b></p>
<p>This chapter describes the callback functions that are implemented by the NVM and can </p>
<p>be invoked by other modules. The prototypes of the callback functions are provided in the </p>
<p>header file </p>
<p>NvM_Cbk.h</p>
<p> by the NVM. </p>
<p><b>6.6.1 </b></p>
<p><b>NvM_JobEndNotification </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_JobEndNotification </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Function to be used by the underlying memory abstraction to signal end of job without error. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>The callback function </p>
<p>NvM_JobEndNotification</p>
<p> is intended to be used by the underlying memory </p>
<p>abstraction (Fee/Ea) to signal end of job without error. </p>
<p>Table 6-21 NvM_JobEndNotification </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>54 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>6.6.2 </b></p>
<p><b>NvM_JobErrorNotification </b></p>
<p><b>Prototype </b></p>
<p>void <b>NvM_JobErrorNotification </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Function to be used by the underlying memory abstraction to signal end of job with error. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>The callback function </p>
<p>NvM_JobErrorNotification</p>
<p> is intended to be used by the underlying memory </p>
<p>abstraction (Fee/Ea) to signal end of job with error. </p>
<p>Table 6-22 NvM_JobErrorNotification </p>
<p><b>6.7 </b></p>
<p><b>Configurable Interfaces </b></p>
<p>At its configurable interfaces the NVM defines notifications that can be mapped to callback </p>
<p>functions  provided  by  other  modules. The  mapping  is  not  statically  defined  by  the  BSW </p>
<p>module but can be performed at configuration time. The function prototypes that can be </p>
<p>used  for  the  configuration  have  to  match  the  appropriate  function  prototype  signatures, </p>
<p>which are described in the following sub-chapters. </p>
<p><b>6.7.1 </b></p>
<p><b> SingleBlockCallbackFunction </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType &lt;<b>SingleBlockCallbackFunction&gt; </b>( NvM_ServiceIdType ServiceId,  </p>
<p>                                             NvM_RequestResultType JobResult ) </p>
<p><b>Parameter </b></p>
<p>ServiceId </p>
<p>The service identifier (see chapter 6.2) of the completed request. </p>
<p>NvM_ServiceIdType</p>
<p> is of type </p>
<p>uint8</p>
<p>. </p>
<p>JobResult </p>
<p>Result of the single block job. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Callback function has been processed successfully </p>
<p>E_NOT_OK </p>
<p>Callback function has not been processed successfully. </p>
<p><b>Functional Description </b></p>
<p>Callback routine to notify the upper layer that an asynchronous single block request has been finished. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>55 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p> </p>
<p></p>
<p> </p>
<p>Asynchronous block processing completed (except </p>
<p>NvM_WriteAll</p>
<p>, for </p>
<p>NvM_ReadAll</p>
<p> it is </p>
<p>configurable) </p>
<p>Table 6-23 SingleBlockCallbackFunction </p>
<p><b>6.7.2 </b></p>
<p><b>MultiBlockCallbackFunction  </b></p>
<p><b>Prototype </b></p>
<p>void &lt;<b>MultiBlockCallbackFunction&gt; </b>( NvM_ServiceIdType ServiceId,                </p>
<p>                                  NvM_RequestResultType JobResult ) </p>
<p><b>Parameter </b></p>
<p>ServiceId </p>
<p>The service identifier (see chapter 6.2) of the completed request. </p>
<p>NvM_ServiceIdType</p>
<p> is of type </p>
<p>uint8</p>
<p>. </p>
<p>JobResult </p>
<p>Result of the multi block job. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Common callback routine to notify the upper layer that an asynchronous multi block request has been </p>
<p>finished.  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p>. </p>
<p></p>
<p> </p>
<p>Called upon completion of </p>
<p>NvM_ReadAll</p>
<p> and </p>
<p>NvM_WriteAll</p>
<p>, respectively </p>
<p>Table 6-24 MultiBlockCallbackFunction </p>
<p><b>6.7.3 </b></p>
<p><b>InitBlockCallbackFunction </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType &lt;</p>
<p><b>InitBlockCallbackFunction&gt;</b></p>
<p> ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>NvM always returns </p>
<p>E_OK</p>
<p>. </p>
<p><b>Functional Description </b></p>
<p>Callback routine which shall be called by the NvM module to copy default data to a RAM block if a ROM </p>
<p>block is configured. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>56 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>Call Context </p>
<p></p>
<p> </p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p> </p>
<p></p>
<p> </p>
<p>Called during processing of </p>
<p>NvM_ReadAll</p>
<p>, if application shall copy default values into the </p>
<p>corresponding RAM block. </p>
<p>Table 6-25 InitBlockCallbackFunction </p>
<p><b>6.8 </b></p>
<p><b>Service Ports </b></p>
<p>Via Service Ports the software components (SWC) have the possibility to execute services </p>
<p>of </p>
<p>the </p>
<p>NVM </p>
<p>with </p>
<p>an </p>
<p>abstract </p>
<p>RTE </p>
<p>interface. </p>
<p>Hence, </p>
<p>the </p>
<p>software </p>
<p>components </p>
<p>are </p>
<p>independent from the underlying basic software stack. </p>
<p><b>6.8.1 </b></p>
<p><b>Client Server Interface </b></p>
<p>A  client  server  interface  is  related  to  a  Provide  Port  (PPort)  at  the  server  side  and  a </p>
<p>Require Port (RPort) at client side. </p>
<p>Configuration dependent naming details are described in the chapters 7.1.3 and 7.1.4. </p>
<p><b>6.8.1.1 </b></p>
<p><b>Provide Ports on NVM side </b></p>
<p>At the PPorts of the NVM the API functions described in 6.4 are available as Runnable </p>
<p>Entities.  The  Runnable  Entities  are  invoked  via  Operations.  The  mapping  from  a  SWC </p>
<p>client call to an Operation is performed by the RTE. In this mapping the RTE adds Port </p>
<p>Defined Argument Values to the client call of the SWC, if configured. </p>
<p>The following subchapters present the PPorts defined for the NVM and their Operations, </p>
<p>the API functions related to those Operations and the Port Defined Argument Values to be </p>
<p>added by the RTE: </p>
<p><b>6.8.1.1.1 </b></p>
<p><b>PAdmin_&lt;BlockName&gt; </b></p>
<p>A port of type ’PAdmin’ is a PPort of one NVRAM block, which is configured to use Service </p>
<p>Ports. </p>
<p>If the SWC setting “Long Service Port Names” is enabled, the name of the service ports is </p>
<p>PAdmin_&lt;BlockName&gt;; </p>
<p>if </p>
<p>“Long </p>
<p>Service </p>
<p>Port </p>
<p>Names” </p>
<p>is </p>
<p>disabled, </p>
<p>the </p>
<p>name </p>
<p>is </p>
<p>PAdmin_&lt;BlockId&gt;. </p>
<p>Available if API Config Class = 3 </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>SetBlockProtection </p>
<p>NvM_SetBlockProtection() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>Table 6-26 Operations of Port Prototype PAdmin_&lt;BlockName&gt; </p>
<p><b>6.8.1.1.2 </b></p>
<p><b>PS_&lt;BlockName&gt; </b></p>
<p>A  port  of  type  ’PS’  is  a  PPort  of  one  NVRAM block,  which  is  configured  to  use  Service </p>
<p>Ports. </p>
<p>If the SWC setting “Long Service Port Names” is enabled, the name of the service ports is </p>
<p>PS_&lt;BlockName&gt;; if “Long Service Port Names” is disabled, the name is PS_&lt;BlockId&gt;. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>57 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>GetErrorStatus</p>
<p> 1</p>
<p> </p>
<p>NvM_GetErrorStatus() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>SetRamBlockStatus</p>
<p>1</p>
<p> </p>
<p>NvM_SetRamBlockStatus() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>SetDataIndex</p>
<p>2,5</p>
<p> </p>
<p>NvM_SetDataIndex() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>GetDataIndex</p>
<p>2,5</p>
<p> </p>
<p>NvM_GetDataIndex() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>ReadBlock</p>
<p>2</p>
<p> </p>
<p>NvM_ReadBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>WriteBlock</p>
<p>2</p>
<p> </p>
<p>NvM_WriteBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>RestoreBlockDefaults</p>
<p>2, 6</p>
<p> </p>
<p>NvM_RestoreBlockDefaults() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>EraseBlock</p>
<p>3</p>
<p> </p>
<p>NvM_EraseNvBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>InvalidateNvBlock</p>
<p>3</p>
<p> </p>
<p>NvM_InvalidateNvBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>Table 6-27 Operations of Port Prototype PS_&lt;BlockName&gt; </p>
<p>1)</p>
<p> </p>
<p>Always available</p>
<p> </p>
<p>2)</p>
<p> </p>
<p>Available if API Config Class &gt;= 2</p>
<p> </p>
<p>3)</p>
<p> </p>
<p>Available if API Config Class = 3</p>
<p> </p>
<p>4)</p>
<p> </p>
<p>Is derived from the block’s position in the configuration</p>
<p> </p>
<p>5)</p>
<p> </p>
<p>Only available for blocks of Management Type Dataset</p>
<p> </p>
<p>6)</p>
<p> </p>
<p>Only available for blocks with Rom defaults configured</p>
<p> </p>
<p><b>6.8.1.2 </b></p>
<p><b>Require Ports </b></p>
<p>NvM invokes callbacks using RPorts. These Operations have to be provided by the SWCs </p>
<p>by  means  of  Runnable  Entities  using  PPorts.  These  Runnable  Entities  implement  the </p>
<p>callback functions expected by the NVM. </p>
<p>The following subchapters present the Require Ports defined for the NVM, the Operations </p>
<p>that are called from the NVM and the related Notifications, which are described in chapter </p>
<p>6.7. </p>
<p><b>6.8.1.2.1 </b></p>
<p><b>NvM_RpNotifyFinished_Id&lt;BlockName&gt; </b></p>
<p>A  port  of  type  ‘NvM_RpNotifyFinished_Id’  is  a  RPort  of  one  NVRAM  block,  which  is </p>
<p>configured to use Service Ports. </p>
<p>If the SWC setting “Long Service Port Names” is enabled, the name of the service ports is </p>
<p>NvM_RpNotifyFinished_Id&lt;BlockName&gt;;  if  “Long  Service  Port  Names”  is  disabled,  the </p>
<p>name is NvM_RpNotifyFinished_Id&lt;BlockId&gt;. </p>
<p>Available in all API Config Classes but “Use Callbacks” must be enabled. </p>
<p><b>Operation </b></p>
<p><b>Notification </b></p>
<p>JobFinished </p>
<p>SingleBlockCallbackFunction </p>
<p>Table 6-28 Operation of Port prototype NvM_RpNotifyFinished_Id&lt;BlockName&gt; </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>58 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>7 </b></p>
<p><b>Configuration </b></p>
<p><b>7.1 </b></p>
<p><b>Software Component Template </b></p>
<p><b>7.1.1 </b></p>
<p><b>Generation </b></p>
<p>The definition of the Provide Ports is described in an XML file. This file describes the NVM </p>
<p>as a software component with ports to which other applications can connect. This XML file </p>
<p>can </p>
<p>be </p>
<p>generated </p>
<p>on </p>
<p>demand </p>
<p>by </p>
<p>DaVinci </p>
<p>Configurator </p>
<p>via </p>
<p>the </p>
<p>menu </p>
<p>“Tools</p>
<p>Æ</p>
<p>AUTOSAR</p>
<p>Æ</p>
<p>SW-C</p>
<p>Æ</p>
<p>NvM”. Additionally, DaVinci Configurator Pro also generates </p>
<p>this file at the end of each generation process automatically. The target directory for SW-C </p>
<p>files can be set via the menu “Tools</p>
<p>Æ</p>
<p>Preferences</p>
<p>Æ</p>
<p>NvM</p>
<p>Æ</p>
<p>SW-C Files”. </p>
<p> </p>
<p>Figure 7-1 Generate an NVM software component template </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>59 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p> </p>
<p>Figure 7-2 Change target directory for all generated SW-C files of NvM. </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>60 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>7.1.2 </b></p>
<p><b>Import into DaVinci Developer </b></p>
<p>For further processing the generated software component template file has to be imported </p>
<p>into  DaVinci  Developer.  This  can  be  done  while  a  DaVinci-project  is  open  by  clicking </p>
<p>“File</p>
<p>Æ</p>
<p>Import XML File...”. Choose the correct file for the import. </p>
<p> </p>
<p>Figure 7-3 Import a new software component into DaVinci Developer </p>
<p>After  importing  the  NVM  as  software  component  there  is  a  new  component  type  in  the </p>
<p>library view available. After double clicking the component NVM, all configured ports are </p>
<p>presented. </p>
<p>The  DaVinci  tool  suite  lets  you  design  the  complete  architecture  of  a  car,  consisting  of </p>
<p>several ECUs, each with its own NVM. Therefore it is desirable to import several NVM SW-</p>
<p>C descriptions, each containing the description of an NVM to be mapped to a particular </p>
<p>ECU. Using the 'Service Component Name Parameter' you can give your configurations </p>
<p>meaningful  unique  names.  All  elements  of  the  SW-C  description  are  unique  in  this </p>
<p>particular  configuration  and  are  prefixed  with  this  parameter’s  value.  However,  most </p>
<p>elements  are  common  to  all  SW-C  descriptions,  or  are  at  least  unique  to  the  used </p>
<p>configuration (which is also expressed by the elements’ names) so that some elements are </p>
<p>contained in each different SW-C description. During import, DaVinci will warn you about </p>
<p>these doubled elements. You can ignore them (overwrite the existing elements); they are </p>
<p>identical. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>61 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>7.1.3 </b></p>
<p><b>Dependencies on Configuration of NVM Attributes </b></p>
<p>The  configuration  of  the  NVM  attributes  (described  in  chapter  7.2)  highly  influences  the </p>
<p>resulting  SW-C  Description.  So,  the  value  of  the  parameter  'Service  Component  Name' </p>
<p>influences the names of several elements in  the description, especially the name of the </p>
<p>'Service  Component'.  It  is  also  the  prefix  for  several  other  names  that  belong  to  this </p>
<p>particular NVM configuration (and the resulting service component). </p>
<p>There  is  a  couple  of  different  port  interfaces  that  will  be  generated,  depending  on  the </p>
<p>particular configuration. Each generated interface that results from a specific configuration </p>
<p>has a unique name, i.e. in different SW-C descriptions port interfaces with the same name </p>
<p>are compatible; they provide the same operations, each with the same arguments of same </p>
<p>type. </p>
<p><b>7.1.3.1 </b></p>
<p><b>Naming of Service Port Interfaces </b></p>
<p>The  Service  Port  Interface  provides  the  prototypes  of  the  elementary  block  related </p>
<p>services  of  the  NVM,  such  as  read  data  from  NV  memory,  write  data  to  NV  memory.  It </p>
<p>generally contains the string 'Srv'. </p>
<p>As described above, port interfaces resulting from different configurations, have different </p>
<p>names. These names are given according to this scheme: </p>
<p></p>
<p> </p>
<p>Each Interface is prefixed by 'NvM_' </p>
<p></p>
<p> </p>
<p>'Set Ram Block Status Api' </p>
<p>Æ</p>
<p> if enabled, the interface name contains the string 'SRBS', </p>
<p>and it contains the operation SetRamBlockStatus.</p>
<p> </p>
<p></p>
<p> </p>
<p>'API Configuration Class' </p>
<p>Æ</p>
<p> the interface name contains a short string that denotes the </p>
<p>API configuration class it belongs to: 'AC1', 'AC2' or 'AC3'. The operations the interface </p>
<p>describes in that configuration class are described in Chapter  </p>
<p>6.8.1.1. </p>
<p></p>
<p> </p>
<p>Availability </p>
<p>of </p>
<p>ROM </p>
<p>default </p>
<p>data </p>
<p>Æ</p>
<p> </p>
<p>the </p>
<p>interface </p>
<p>contains </p>
<p>the </p>
<p>operation </p>
<p>RestoreBlockDefaults; it contains the string 'Defs'. This interface will be used by all P-</p>
<p>Port-Prototypes  belonging  to  a  NVRAM  block  that  was  configured  with  ROM  default </p>
<p>data.</p>
<p> </p>
<p></p>
<p> </p>
<p>Block </p>
<p>Management </p>
<p>Type </p>
<p>'DATASET' </p>
<p>Æ</p>
<p> </p>
<p>the </p>
<p>interface </p>
<p>provides </p>
<p>the </p>
<p>operations </p>
<p>GetDataIndex and SetDataIndex. Its name contains 'DS'. This interface will be used by </p>
<p>all NVRAM blocks of Management Type 'DATASET' </p>
<p>The first two possibilities are common within one SW-C Description. Only one combination </p>
<p>of  them  will  occur.  Unless  'API  Configuration  Class  1'  was  chosen,  Port  Interfaces </p>
<p>describing any combination of the latter two possibilities may be generated. </p>
<p><b>7.1.4 </b></p>
<p><b>Service Port Prototypes </b></p>
<p>For each active NVRAM block (including the configuration ID block) that was configured </p>
<p>with  'Use  Service  Ports'  port,  prototypes  will  be  generated. The  port  interfaces  they  are </p>
<p>based on can differ. The interfaces depend on the block’s configuration, and hence on the </p>
<p>operations that are necessary for current block. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>62 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>7.1.4.1 </b></p>
<p><b>Port Prototype Naming </b></p>
<p>The short name uniquely identifying the prototype is based on the numeric block ID (which, </p>
<p>in  turn,  is  derived  from  the  block’s  position  in  the  configuration)  and  the  port  interface </p>
<p>&quot;class” it corresponds to. </p>
<p>Each </p>
<p>prototype </p>
<p>is </p>
<p>prefixed </p>
<p>by </p>
<p>the </p>
<p>String </p>
<p>'NvM_'; </p>
<p>the </p>
<p>next </p>
<p>substring </p>
<p>describes </p>
<p>the </p>
<p>corresponding  port  interface,  and  whether  it  is  a  Provide  Port  ('Pp')  or  a  Require  Port </p>
<p>('Rp'): </p>
<p></p>
<p> </p>
<p>'PAdmin' </p>
<p>Æ</p>
<p> Linked with port interface 'NvM_Administration' (only in 'API Configuration </p>
<p>Class 3') </p>
<p></p>
<p> </p>
<p>'PS' </p>
<p>Æ</p>
<p> Linked with Port Interface 'NvM_AC{1|2|3}[_SRBS][_Defs][_DS]_Srv'. The actual </p>
<p>interface depends on the possibilities described above.</p>
<p> </p>
<p></p>
<p> </p>
<p>'NvM_RpNotifyFinished' </p>
<p>Æ</p>
<p> </p>
<p>Linked </p>
<p>with </p>
<p>Port </p>
<p>Interface </p>
<p>NvM_NotifyJobFinished </p>
<p>that </p>
<p>describes the interface used by the NVM for 'single block job end notification' </p>
<p>If SWC setting “Long Service Port Names” is disabled, each port prototype’s name is post </p>
<p>fixed  by  '_Id{BlockId}'.  If  SWC  setting  “Long  Service  Port  Names”  is  enabled,  each  port </p>
<p>prototype’s name is post fixed by '_{BlockName}'.  </p>
<p>Additionally  each  port  prototype  contains  a  long  name  as  well  as  a  description,  which </p>
<p>describe  it  in  a  better,  human  readable  form.  They  contain  the  logical  block  name,  as </p>
<p>configured, instead of the block ID, and the used port interface’s short name. </p>
<p><b>7.2 </b></p>
<p><b>Configuration of NVM Attributes </b></p>
<p>In the NVM the attributes can be configured with the following methods: </p>
<p></p>
<p> </p>
<p>Configuration in DaVinci Configurator </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>63 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Because AUTOSAR forbids the use of the </p>
<p>sizeof</p>
<p>-operator in production code, the </p>
<p>exact sizes of your NVRAM blocks, and hence your data structures must be known at </p>
<p>configuration time. Therefore you are required to determine these values by yourself. </p>
<p>This leads to some significant pitfalls: </p>
<p></p>
<p> </p>
<p>The sizes of basic data types are platform dependent. To handle this problem, you should </p>
<p>use only AUTOSAR data types as defined in </p>
<p>Std_Types.h </p>
<p>(respectively </p>
<p>Platform_Types.h</p>
<p>). They are defined to have the same size on all platforms. The </p>
<p>enumeration type’s size also depends on your platform, the compiler and its options. Be </p>
<p>aware of the size the compiler actually chooses. Usually an </p>
<p>enum</p>
<p> equals to an </p>
<p>int</p>
<p> by </p>
<p>default, but you can force it to be the smallest possible type (e.g. </p>
<p>char</p>
<p>). </p>
<p></p>
<p> </p>
<p>Be aware of the composition of bit fields. It can be affected by compiler switches. </p>
<p></p>
<p> </p>
<p>The compiler may rearrange members of structures to save memory. The best solution </p>
<p>would be to arrange members according to their type manually. The compiler may add </p>
<p>unused padding bytes to increase accessibility to the members of a structure. According to </p>
<p>the previous fact, you should order your structure’s members. Doing so, you should be </p>
<p>aware of aligned start addresses for larger integral data types (e.g. </p>
<p>uint16</p>
<p> or </p>
<p>uint32</p>
<p>) </p>
<p>according to the CPU’s requirements for accessing them. </p>
<p></p>
<p> </p>
<p>As stated above, some compiler switches influence the sizes of data types. Keep in mind </p>
<p>that changing these ones may result in changed sizes of your data blocks, leading to a </p>
<p>reconfiguration of NVM. </p>
<p>A good way to determine the blocks’ sizes is to extract the required information from </p>
<p>the linker file or from the generated object. </p>
<p><b> </b></p>
<p> </p>
<p><b>7.2.1 </b></p>
<p><b>Start configuration of the NVM </b></p>
<p>The  component  name  of  the  NVRAM  Manager  in  DaVinci  Configurator  is  “NvM”.  In  the </p>
<p>“Architecture  view”  (initial  page)  of  DaVinci  Configurator  the  NvM  can  be  opened  by  its </p>
<p>context  menu  to  start  its  configuration.  The  NvM  can  also  be  opened  for  configuration </p>
<p>using the Project Explorer, selecting Memory </p>
<p>Æ</p>
<p> Services </p>
<p>Æ</p>
<p> NvM. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>64 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>7.2.2 </b></p>
<p><b>General Settings </b></p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>SWC Settings </p>
<p>Service </p>
<p>Component </p>
<p>Name </p>
<p>link-time </p>
<p>string </p>
<p>Valid C-</p>
<p>name, </p>
<p>maximum </p>
<p>length: 20 </p>
<p>characters, </p>
<p>default: </p>
<p><b>NvM </b></p>
<p>Create a unique name space for </p>
<p>the NVM. This name is used for </p>
<p>SWC Description generation. The </p>
<p>generated component will get this </p>
<p>name. Several names will be </p>
<p>prefixed with this name. </p>
<p>Long Service Port </p>
<p>Names </p>
<p>link-time </p>
<p>bool </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enables long service port names; </p>
<p>Each port prototype’s name is post </p>
<p>fixed by '{BlockName}' instead of </p>
<p>‘{BlockId}’ </p>
<p>Queues and API configuration </p>
<p>API Configuration </p>
<p>Class </p>
<p>pre-compile </p>
<p>-- </p>
<p>Class 1 </p>
<p>Class 2 </p>
<p><b>Class 3 </b></p>
<p>Different classes with API function </p>
<p>sets can be selected. </p>
<p>By setting this preprocessor </p>
<p>switch to 'Class 1' the following </p>
<p>options are disabled: </p>
<p>NVM_JOB_PRIORISATION </p>
<p>NVM_SIZE_STANDARD_JOB_QUEUE </p>
<p>NVM_SIZE_IMMEDIATE_JOB_QUEUE</p>
<p>Use Version Info </p>
<p>API </p>
<p>pre-compile </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Use </p>
<p>NvM_GetVersionInfo().</p>
<p> </p>
<p>Use Set Ram </p>
<p>Block Status API </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Use </p>
<p>NvM_SetRamBlockStatus().</p>
<p>Job Prioritization </p>
<p>pre-compile </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable the prioritized queuing of </p>
<p>jobs. </p>
<p>Size of Standard </p>
<p>Job Queue </p>
<p>link-time </p>
<p>integer </p>
<p>1.. </p>
<p><b>8 </b></p>
<p>..254 </p>
<p>Size of the standard job queue. </p>
<p>Size of Immediate </p>
<p>Job Queue </p>
<p>link-time </p>
<p>integer </p>
<p><b>1 </b></p>
<p>..254 </p>
<p>Size of the immediate job queue. </p>
<p>Configuration option </p>
<p>ID of this </p>
<p>Configuration Set </p>
<p>link-time </p>
<p>integer </p>
<p>0.. </p>
<p><b>1 </b></p>
<p>..65535 </p>
<p>Compiled configuration set </p>
<p>identifier. </p>
<p>Dynamic </p>
<p>Configuration </p>
<p>Handling </p>
<p>pre-compile </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable/disable dynamic </p>
<p>configuration handling. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>65 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>66 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Further settings </p>
<p>Drive Mode </p>
<p>pre-compile </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>If this option is selected, the drive </p>
<p>mode of the underlying memory </p>
<p>devices will be set to fast during </p>
<p>multi block services. </p>
<p>Polling Mode </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If this option is selected, NVM </p>
<p>polls the underlying layer till job </p>
<p>completion. The callback functions </p>
<p>are not used by the lower layer </p>
<p>and must be disabled in this layer. </p>
<p>Internal Buffer for </p>
<p>Crc Handling </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enable and disable internal Crc </p>
<p>Buffer. If Internal Crc Buffer is </p>
<p>enabled, NvM handles Crc in an </p>
<p>internal buffer. Memory for Crc </p>
<p>must not be allocated at the end of </p>
<p>Ram Block. If internal Crc Buffer is </p>
<p>disabled, Memory for Crc at the </p>
<p>end of Ram Block is necessary! </p>
<p>CRC Bytes per </p>
<p>Cycle </p>
<p>link-time </p>
<p>integer </p>
<p>1.. </p>
<p><b>64 </b></p>
<p>.. 65535 </p>
<p>Maximum number of bytes of a </p>
<p>CRC checksum that are </p>
<p>calculated during one cycle of </p>
<p>NvM_MainFunction</p>
<p>. </p>
<p>Max. Number of </p>
<p>Write Retries </p>
<p>link-time </p>
<p>integer </p>
<p>0.. </p>
<p><b>1 </b></p>
<p>..7 </p>
<p>Number of retries until a write job </p>
<p>fails. </p>
<p>Dataset Selection </p>
<p>Bits </p>
<p>link-time </p>
<p>integer </p>
<p>1.. </p>
<p><b>4 </b></p>
<p>..8 </p>
<p>Defines the number of least </p>
<p>significant bits which are used to </p>
<p>address a dataset of a block of </p>
<p>type dataset (see chapter 4.4.5.2).</p>
<p>Critical Sections </p>
<p>Function Set </p>
<p>link-time </p>
<p>-- </p>
<p>all named </p>
<p>sets </p>
<p>defined in </p>
<p>'MyECU', </p>
<p>default: </p>
<p><b>UseSuspe</b></p>
<p><b>ndFunctio</b></p>
<p><b>ns </b></p>
<p>The different services to protect </p>
<p>critical sections can be defined in </p>
<p>'MyECU'. </p>
<p>Table 7-1   General Settings </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>7.2.3 </b></p>
<p><b>Special NVRAM Blocks </b></p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Config ID Block </p>
<p>Name </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p>Valid C-</p>
<p>identifier, </p>
<p>default: </p>
<p><b>ConfigBlo</b></p>
<p><b>ck </b></p>
<p>Logical name of the reserved </p>
<p>configuration block to be used </p>
<p>within the application. </p>
<p>Device </p>
<p>link-time </p>
<p>FEE/EA </p>
<p>or third </p>
<p>party </p>
<p>module </p>
<p>All </p>
<p>configured </p>
<p>NV </p>
<p>abstraction </p>
<p>devices </p>
<p>(FEE/EA </p>
<p>…), no </p>
<p>default. </p>
<p>The device (Memory Hardware </p>
<p>Abstraction) the configuration </p>
<p>block is located in. </p>
<p>CRC Type </p>
<p>link-time </p>
<p>-- </p>
<p><b>CRC16 </b></p>
<p>CRC32 </p>
<p>CRC type for this block. </p>
<p>Ram Block </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p>Valid C-</p>
<p>identifier, </p>
<p>default: </p>
<p><b>CfgId_Ra</b></p>
<p><b>mBlock </b></p>
<p>Symbolic name of the RAM block </p>
<p>(Variable name as defined by </p>
<p>application) </p>
<p>If no name is defined, RAM Block </p>
<p>will be defined by NvM. </p>
<p>Single Block </p>
<p>Callback </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p><b>NULL_PT</b></p>
<p><b>R </b></p>
<p>or other </p>
<p>valid C-</p>
<p>identifier </p>
<p>Name of the callback function </p>
<p>supplied by application, if used. </p>
<p>This field is disabled, if 'Use </p>
<p>Service Ports' is checked, </p>
<p>because in this case, the callback </p>
<p>will be invoked, depending on RTE </p>
<p>configuration (Port Mapping). </p>
<p>It is also disabled, if 'Use Job End </p>
<p>Callback' is unchecked. </p>
<p>Requirement Id </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p>valid C-</p>
<p>identifier </p>
<p>A requirement id may be entered </p>
<p>here for traceability reason. </p>
<p>Priority </p>
<p>link-time </p>
<p>integer </p>
<p>0.. </p>
<p><b>127 </b></p>
<p>..255 </p>
<p>(0 </p>
<p>=immediat</p>
<p>e) </p>
<p>Priority of the Config ID Block </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>Note that a priority </p>
<p>of 0 (immediate) is </p>
<p>possible, but not </p>
<p>recommended</p>
<p>.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>67 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>68 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>RAM CRC </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enable/disable the calculation of </p>
<p>CRC in RAM, upon </p>
<p>NvM_SetRamBlockStatus(true)</p>
<p> </p>
<p>request. </p>
<p>Write Once </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Configure block as write once. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>When using </p>
<p>'Dynamic </p>
<p>Configuration </p>
<p>Handling', this </p>
<p>option should be </p>
<p>unchecked. </p>
<p><b> </b></p>
<p> </p>
<p>Initially Write </p>
<p>Protected </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Write protection enabled after </p>
<p>reset. </p>
<p>Use Service Ports </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Mark the configured block as </p>
<p>accessible via service ports. The </p>
<p>block name will be derived from </p>
<p>the symbolic name. </p>
<p>Use Job End </p>
<p>Callback </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enable/disable usage of the </p>
<p>'single block job end notification' </p>
<p>callback </p>
<p>Use Job End </p>
<p>Callback during </p>
<p>NvM_ReadAll </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable/disable usage of the </p>
<p>'single block job end notification' </p>
<p>callback during NvM_ReadAll, </p>
<p>when this block has been </p>
<p>processed. It depends on the </p>
<p>runtime-environment, whether this </p>
<p>option may be enabled, or not. </p>
<p>E.g., if the application is not yet </p>
<p>initialized, when NvM_ReadAll is </p>
<p>being processed, or (in case of </p>
<p>Service Ports usage) if the RTE is </p>
<p>not initialized yet, this option </p>
<p>should be disabled. </p>
<p>Multiblock Request Status </p>
<p>Blockname </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p>Valid C-</p>
<p>identifier, </p>
<p>default: </p>
<p><b>MultiBlock</b></p>
<p><b>Request </b></p>
<p>Logical name of the reserved </p>
<p>'Multiblock request status block' </p>
<p>(ID 0). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>69 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Callback </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p><b>NULL_PT</b></p>
<p><b>R </b></p>
<p>or other </p>
<p>valid C-</p>
<p>identifier </p>
<p>Name of the callback function </p>
<p>supplied by application, if used. </p>
<p>Include Files </p>
<p>Include List </p>
<p>link-time </p>
<p>header </p>
<p>file </p>
<p>Valid </p>
<p>header file, </p>
<p>default: </p>
<p><b>Applicatio</b></p>
<p><b>n.h </b></p>
<p>List of all includes, declaring the </p>
<p>callback functions used (including </p>
<p>the callbacks for the configuration </p>
<p>block as well as the Multiblock </p>
<p>Request Result Block) and the </p>
<p>extern declarations of RAM and </p>
<p>ROM blocks. Only files appearing </p>
<p>in the list will be recognized. A file </p>
<p>name in the edit filed will be </p>
<p>ignored, unless it’s added using </p>
<p>the 'Add' button </p>
<p>If NVRAM Blocks are configured </p>
<p>to 'Use Service Ports' and with </p>
<p>callbacks, you need to configure </p>
<p>an RTE include file. It needs to be </p>
<p>named Rte_&lt;Service Component </p>
<p>Name&gt;.h </p>
<p>Table 7-2   Special NVRAM blocks </p>
<p><b>7.2.4 </b></p>
<p><b>User Block Description </b></p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Block Description </p>
<p>Identifier </p>
<p>link-time </p>
<p>integer </p>
<p>1.. </p>
<p><b>2</b>.. </p>
<p>.. 65535 </p>
<p>Numeric handle of the NVRAM </p>
<p>Block to be passed as BlockId </p>
<p>parameter to the NvM. This value </p>
<p>will be calculated automatically. In </p>
<p>DaVinci Configurator Pro it is not </p>
<p>writeable by the user. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>70 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Name </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p>Valid C-</p>
<p>identifier, </p>
<p>must be </p>
<p>unique, </p>
<p>default: </p>
<p><b>Appl_Nvm</b></p>
<p><b>Block1 </b></p>
<p>Logical name of the User Block, to </p>
<p>be used within your application </p>
<p>(Don’t use the numeric Block IDs, </p>
<p>represented by the names, </p>
<p>directly). A block handle with this </p>
<p>name will be generated. </p>
<p>This name will also be used in </p>
<p>Descriptions and long names of </p>
<p>the NVM’s SWC Description. </p>
<p>Device </p>
<p>link-time </p>
<p>FEE/EA </p>
<p>or </p>
<p>dummie</p>
<p>s </p>
<p>All </p>
<p>configured </p>
<p>NV </p>
<p>abstraction </p>
<p>devices </p>
<p>(FEE/EA or </p>
<p>dummies), </p>
<p><b>no default</b>.</p>
<p>The device the User Block is </p>
<p>located in. </p>
<p>MngmtType </p>
<p>link-time </p>
<p>-- </p>
<p><b>Native </b></p>
<p>Redundant </p>
<p>Dataset </p>
<p>Management Type of the User </p>
<p>Block. </p>
<p>CRC Type </p>
<p>link-time </p>
<p>-- </p>
<p><b>OFF </b></p>
<p>CRC16 </p>
<p>CRC32 </p>
<p>CRC protection to be used for the </p>
<p>User Block. </p>
<p>RAM CRC </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>If checked, the CRC of the RAM </p>
<p>block is recalculated when </p>
<p>NvM_SetRamBlockStatus(TRUE)</p>
<p> </p>
<p>is called. </p>
<p>Prio </p>
<p>link-time </p>
<p>integer </p>
<p>0.. </p>
<p><b>127 </b></p>
<p>..255 </p>
<p>(0 </p>
<p>=immediat</p>
<p>e) </p>
<p>Priority of the User Block. </p>
<p>Length </p>
<p>link-time </p>
<p>integer </p>
<p><b>1 </b></p>
<p>.. 65535 </p>
<p>Length of the User Block in bytes. </p>
<p>Count </p>
<p>link-time </p>
<p>integer </p>
<p><b>Native: 1 </b></p>
<p>Redundant</p>
<p>: 2 </p>
<p>Dataset: </p>
<p>2...255 </p>
<p>Number of mapped blocks in the </p>
<p>NV area. Dependant on the </p>
<p>management type. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>71 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Further Settings </p>
<p>Service Ports </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Generate service port description </p>
<p>for the configured block. </p>
<p>If checked, the parameters 'Use </p>
<p>Init Callback', 'Init Callback' and </p>
<p>'Job End Callback' are disabled </p>
<p>WO </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p><b>W</b>rite <b>O</b>nce Flag. A write once </p>
<p>block can only be written once. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Pay attention that a </p>
<p>dataset block set to </p>
<p>write once cannot be </p>
<p>written once for all its </p>
<p>datasets. Only one </p>
<p>dataset could be </p>
<p>written. </p>
<p><b> </b></p>
<p> </p>
<p>IWP </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p><b>I</b>nitial <b>W</b>rite <b>P</b>rotection for this </p>
<p>block. Defines the state of this </p>
<p>block’s user-definable write </p>
<p>protection after start-up. </p>
<p>Res </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p><b>Res</b>istant to changed software </p>
<p>Option influences the block </p>
<p>handling during </p>
<p>NvM_ReadAll().</p>
<p> </p>
<p>ReadAll </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>If checked the block will be read </p>
<p>from NV during </p>
<p>NvM_ReadAll().</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>72 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Cbk @ ReadAll </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Enable/disable usage of the </p>
<p>'single block job end notification' </p>
<p>callback during NvM_ReadAll in </p>
<p>contrast to the typical behaviour </p>
<p>where only the ‘multiblock job end </p>
<p>notification’ would be called. </p>
<p>Nevertheless the ‘multiblock job </p>
<p>end notification’ will be called after </p>
<p>processing of all configured </p>
<p>“ReadAll”-blocks. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>It depends on the </p>
<p>runtime-environment, </p>
<p>whether this option </p>
<p>may be enbled, or </p>
<p>not. E.g., if the </p>
<p>application is not yet </p>
<p>initialized, when </p>
<p>NvM_ReadAll is </p>
<p>being processed, or </p>
<p>(in case of Service </p>
<p>Ports usage) if the </p>
<p>RTE is not initialized </p>
<p>yet, this option should </p>
<p>be disabled.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p>RAM Block </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p>NULL_PTR </p>
<p>or other </p>
<p>valid C-</p>
<p>identifier, </p>
<p>default: </p>
<p><b>RamBlock</b></p>
<p><b>Data1 </b></p>
<p>Symbolic name of the RAM block </p>
<p>(Variable name as defined by </p>
<p>application). If the block is non-</p>
<p>permanent the field can be left </p>
<p>empty or a </p>
<p>NULL_PTR</p>
<p> can be </p>
<p>entered. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>A RAM block must </p>
<p>not be allocated, if </p>
<p>the block is </p>
<p>configured by RTE. </p>
<p>The field can be left </p>
<p>empty or a </p>
<p>NULL_PTR can be </p>
<p>entered.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>73 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Service Port Settings </p>
<p>ROM Block </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p><b>NULL_PT</b></p>
<p><b>R </b></p>
<p>or other </p>
<p>valid C-</p>
<p>identifier </p>
<p>If the block shall have ROM </p>
<p>defaults the name of the constant </p>
<p>must be entered in this field </p>
<p>(constant name as defined by </p>
<p>application). </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Pay attention that a </p>
<p>block can only have </p>
<p>either ROM defaults </p>
<p>or an init call-back. If </p>
<p>the ROM block is </p>
<p>configured which </p>
<p>means that it is not </p>
<p>empty and not </p>
<p>NULL_PTR, the </p>
<p>setting of the Init </p>
<p>Callback will be </p>
<p>ignored. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>A ROM block must </p>
<p>not be allocated, if </p>
<p>the block is </p>
<p>configured by RTE. </p>
<p>The field can be left </p>
<p>empty or a </p>
<p>NULL_PTR can be </p>
<p>entered. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>74 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use Init Callback </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>An alternative to ROM defaults is </p>
<p>the use of an init callback. Checks </p>
<p>this control to enable usage of the </p>
<p>init callback. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Pay attention that a </p>
<p>block can only have </p>
<p>either ROM defaults </p>
<p>or an init call-back. If </p>
<p>a ROM Block was </p>
<p>configured, or if the </p>
<p>'Init Callback' was not </p>
<p>set, this option does </p>
<p>not have any effects. </p>
<p>If 'Use Service Ports' </p>
<p>was enabled, this </p>
<p>option is disabled, </p>
<p>because it cannot be </p>
<p>guaranteed that the </p>
<p>init callback can be </p>
<p>invoked during </p>
<p>NvM_ReadAll </p>
<p>processing, as it is </p>
<p>unclear whether the </p>
<p>RTE is running. </p>
<p><b> </b></p>
<p> </p>
<p>Init Callback </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p><b>NULL_PT</b></p>
<p><b>R </b></p>
<p>or other </p>
<p>valid C-</p>
<p>identifier </p>
<p>An alternative to ROM defaults is </p>
<p>the use of an init callback. Enter </p>
<p>the name in this field as defined </p>
<p>by the aplication. This control is </p>
<p>disabled, if 'Use Service Ports' </p>
<p>was checked. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Pay attention that a </p>
<p>block can only have </p>
<p>either ROM defaults </p>
<p>or an init call-back. If </p>
<p>a ROM block was </p>
<p>configured, the 'Init </p>
<p>Callback' will be </p>
<p>ignored. </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>75 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use Job End Cbk </p>
<p>link-time </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Use the Job end callback. If </p>
<p>checked, the control 'Job End </p>
<p>Callback' is enabled, unless 'Use </p>
<p>Service Ports' was also checked. </p>
<p>Job End Callback </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p><b>NULL_PT</b></p>
<p><b>R </b></p>
<p>or other </p>
<p>valid C-</p>
<p>identifier </p>
<p>Name of the callback function </p>
<p>supplied by application, if used. </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>If 'Use Service Ports' </p>
<p>was chosen, the </p>
<p>name of the callback </p>
<p>is implicitly defined. </p>
<p>Thus this control will </p>
<p>be disabled. </p>
<p><b> </b></p>
<p> </p>
<p>Requirement Id </p>
<p>link-time </p>
<p>C-</p>
<p>identifie</p>
<p>r </p>
<p>valid C-</p>
<p>identifier </p>
<p>A requirement id may be entered </p>
<p>here for traceability reason. </p>
<p>Table 7-3   User block description </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>7.2.5 </b></p>
<p><b>Error Detection </b></p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Error Detection – Development Mode </p>
<p>Development Error </p>
<p>Detection </p>
<p>pre-compile </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>If activated then all checks – if </p>
<p>enabled – will be done. Otherwise, </p>
<p>no further development error </p>
<p>detection will be done. </p>
<p>By setting this preprocessor </p>
<p>switch to ON the general </p>
<p>parameter checking is enabled. </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>In production mode, </p>
<p>this switch should be </p>
<p>disabled to save </p>
<p>RAM/ROM and to </p>
<p>speed up the module.</p>
<p><b> </b></p>
<p> </p>
<p>Check Module’s </p>
<p>Initialization Status </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate NVM initialization </p>
<p>check within each API function call </p>
<p>(except </p>
<p>NvM_Init() </p>
<p>and </p>
<p>NvM_GetVersionInfo()</p>
<p>). </p>
<p>Check Block’s </p>
<p>Management Type </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate checking of block’s </p>
<p>management type in API functions </p>
<p>NvM_RestoreBlockDefaults(),</p>
<p> </p>
<p>NvM_GetDataIndex()</p>
<p> and </p>
<p>NvM_SetDataIndex()</p>
<p> </p>
<p>respectively. </p>
<p>Check Block’s </p>
<p>Write Protection </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate checking of block’s </p>
<p>write protection and also the </p>
<p>correct use of the write protection </p>
<p>in API functions (write once): </p>
<p>NvM_WriteBlock(), </p>
<p>NvM_InvalidateNvBlock(),  </p>
<p>NvM_EraseBlock() and </p>
<p>NvM_SetBlockProtection(). </p>
<p>Check Block’s </p>
<p>Pending State </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate checking of block’s </p>
<p>listed/pending state in all API </p>
<p>functions, except </p>
<p>NvM_GetErrorStatus(), </p>
<p>NvM_GetVersionInfo()</p>
<p> and </p>
<p>NvM_Init().</p>
<p> </p>
<p>API Parameter </p>
<p>Checking </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>By setting this preprocessor </p>
<p>switch to ON the general </p>
<p>parameter checking is enabled. </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>76 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>77 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Check BlockId </p>
<p>pre-compile </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>(De)Activate checking for block ID </p>
<p>in correct range. </p>
<p>Check DataIndex </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate checking if DataIndex </p>
<p>passed to </p>
<p>NvM_SetDataIndex() </p>
<p>is in configured range. Applies </p>
<p>only to management type Dataset. </p>
<p>Relevant for the functions </p>
<p>NvM_WriteBlock()</p>
<p>, </p>
<p>NvM_InvalidateNvBlock() </p>
<p>and </p>
<p>NvM_EraseBlock()</p>
<p>. </p>
<p>Check Pointers </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate checking if a pointer </p>
<p>parameter is not the </p>
<p>NULL_PTR </p>
<p>(</p>
<p>NvM_GetDataIndex()</p>
<p>, </p>
<p>NvM_GetErrorStatus()</p>
<p>, </p>
<p>NvM_GetVersionInfo()</p>
<p>), or the </p>
<p>NULL_PTR</p>
<p> was passed for a non-</p>
<p>permanent block </p>
<p>(</p>
<p>NvM_ReadBlock()</p>
<p>, </p>
<p>NvM_WriteBlock(),</p>
<p> </p>
<p>NvM_RestoreRomDefaults()</p>
<p>). </p>
<p>Check RAM Block </p>
<p>Lengths </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate RAM Block Length </p>
<p>checks during initialization; see </p>
<p>chapter 4.2.1 </p>
<p>Check ROM Block </p>
<p>Lengths </p>
<p>link-time </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>(De)Activate ROM Block Length </p>
<p>checks during initialization; see </p>
<p>chapter 4.2.1 </p>
<p>Enable </p>
<p>Development Error </p>
<p>Reporting </p>
<p>pre-compile </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enable/disable calls to DET. </p>
<p>Nevertheless, the checks </p>
<p>configured above will be </p>
<p>performed, and API functions will </p>
<p>return an appropriate value. </p>
<p>By setting this preprocessor </p>
<p>switch to ON the following options </p>
<p>have to be configured: </p>
<p>NVM_ERRORHOOK </p>
<p>NVM_CFG_INCLUDE_DET</p>
<p> </p>
<p>Errorhook Function </p>
<p>pre-compile </p>
<p>C-</p>
<p>function </p>
<p>identifie</p>
<p>r </p>
<p>Valid C-</p>
<p>function </p>
<p>identifier, </p>
<p>default: </p>
<p><b>Det_Repor</b></p>
<p><b>tError  </b></p>
<p>Defines the function that is to be </p>
<p>called in case of a Development </p>
<p>Error. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>78 / 84</p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Include File </p>
<p>pre-compile </p>
<p>header </p>
<p>file </p>
<p>Valid </p>
<p>header file, </p>
<p>default: </p>
<p><b>Det.h </b></p>
<p>Include this header to get the </p>
<p>declaration of </p>
<p>Det_ReportError()</p>
<p>. </p>
<p>Error Detection – Production Mode </p>
<p>DEM Reporting </p>
<p>Function </p>
<p>pre-compile </p>
<p>C-</p>
<p>function </p>
<p>identifie</p>
<p>r </p>
<p>Valid C-</p>
<p>function </p>
<p>identifier, </p>
<p>default: </p>
<p><b>Dem_ </b></p>
<p><b>ReportErr</b></p>
<p><b>orStatus </b></p>
<p>Name of the function to be called </p>
<p>when reporting an error. If an </p>
<p>AUTOSAR compliant DEM is </p>
<p>used, it is named </p>
<p>Dem_ReportErrorStatus()</p>
<p>. </p>
<p>Include File </p>
<p>pre-compile </p>
<p>header </p>
<p>file </p>
<p>Valid </p>
<p>header file, </p>
<p>default: </p>
<p><b>Dem.h </b></p>
<p>Name of the header file publishing </p>
<p>the DEM API, thus the error </p>
<p>function named above. If an </p>
<p>AUTOSAR compliant DEM is </p>
<p>used, it is named </p>
<p>Dem.h</p>
<p>. </p>
<p>Table 7-4   Error Detection </p>
<p><b>7.2.6 </b></p>
<p><b>Module API </b></p>
<p><b>7.2.6.1 </b></p>
<p><b>Provided API group </b></p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Provided API </p>
<p>-- </p>
<p>-- </p>
<p>-- </p>
<p>This group shows the API </p>
<p>services that were currently </p>
<p>provided by the NVRAM </p>
<p>Manager depending on its </p>
<p>configuration. </p>
<p>Table 7-5   Provided API </p>
<p><b>7.3 </b></p>
<p><b>Attributes only configurable using GCE </b></p>
<p>The NVM contains parameters that can only be modified in GCE view; they are not visible </p>
<p>in “Comfort View”, because it is not recommended to modify them. If those parameter’s </p>
<p>differ  from  their  default  values  (which  are  also  recommended  values)  a  warning  will  be </p>
<p>issued during validation process. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b>Variant </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Nvm_30_CommonV</p>
<p>endorParams / </p>
<p>NvmCrcPreserveVal</p>
<p>ue </p>
<p>pre-compile </p>
<p>BOOL </p>
<p><b>TRUE</b>/FALS</p>
<p>E </p>
<p>Pre-Compile parameter, which </p>
<p>controls CRC(32) calculation. If </p>
<p>enabled, the calculated result </p>
<p>does not depend on setting of </p>
<p>“CRC Bytes per Cycle” </p>
<p>(NvmCrcNumOfBytes). See </p>
<p>also chapter 4.4.10 </p>
<p>Nvm_30_CommonV</p>
<p>endorParams / </p>
<p>NvmCfgChkBlockLe</p>
<p>ngthStrict </p>
<p>link-time </p>
<p>BOOL </p>
<p><b>TRUE</b>/FALS</p>
<p>E </p>
<p>Link-Time parameter, which </p>
<p>allows you to enable/disable </p>
<p>strict block length checks. </p>
<p>Refer to chapter 4.2.1 </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>79 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>8 </b></p>
<p><b>AUTOSAR Standard Compliance </b></p>
<p><b>8.1 </b></p>
<p><b>Deviations </b></p>
<p></p>
<p> </p>
<p>In contrast to AUTOSAR most configuration parameters are link-time parameters. </p>
<p></p>
<p> </p>
<p>Saving RAM CRC of current block is configuration dependent. Either it is saved behind </p>
<p>the block’s data or it is saved internally by NVM in an own variable. </p>
<p></p>
<p> </p>
<p>Unified  handling  of  ROM  defaults  among  all  block  management  types  is  processed. </p>
<p>Rom defaults handling of blocks of type dataset is just like the handling of blocks of the </p>
<p>other management types. </p>
<p></p>
<p> </p>
<p>NVM is able to provide the Config Id’s RAM block on its own. </p>
<p></p>
<p> </p>
<p>NvM_WriteAll() does not write unchanged data, even if this would repair (redundant) NV </p>
<p>data. </p>
<p></p>
<p> </p>
<p>NVM </p>
<p>provides </p>
<p>an </p>
<p>additional </p>
<p>customer </p>
<p>specific  API </p>
<p>NvM_SetBlockLockStatus() </p>
<p>for </p>
<p>setting/resetting a lock for a NV block. (see chapter 6.4.8) </p>
<p><b>8.2 </b></p>
<p><b>Additions/ Extensions </b></p>
<p><b>8.2.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>The  internal  parameter  checks  of  the API  functions  can  be  en-/disabled  separately. The </p>
<p>AUTOSAR standard requires en-/disabling of the complete parameter checking only. For </p>
<p>details see chapter 4.5.1.1. </p>
<p><b>8.2.2 </b></p>
<p><b>Concurrent access to NV data </b></p>
<p>NVM provides for DCM possibility to access NV data concurrently with NVM’s applications. </p>
<p>(see chapter 4.4.17) </p>
<p><b>8.2.3 </b></p>
<p><b>RAM-/ROM Block Size checks </b></p>
<p>NVM can be configured to check all RAM and ROM blocks’ lengths against corresponding </p>
<p>NV Block lengths, using </p>
<p>sizeof</p>
<p> operator; see chapter 4.2.1. </p>
<p><b>8.2.4 </b></p>
<p><b>Calculated CRC value does not depend on number of calculation steps </b></p>
<p>Due to the specified CRC32 algorithm, and missing further requirements on NVM’s CRC </p>
<p>calculation, a calculated CRC32 value depends on the number of necessary calculation </p>
<p>steps (defined by block length and parameter “CRC Bytes per Cycle”). Unless the CRC </p>
<p>can be calculated with one step (i.e. the block is small enough), the CRC32 value will not </p>
<p>match the value resulting from calling the CRC32 library function once for the whole block. </p>
<p>The reason is the negation of the result, as specified for CRC32 (which in turn belongs to </p>
<p>standard/widely  used  “Ethernet  CRC”).  This  behavior  introduces  some  drawbacks  on </p>
<p>NVM, especially:  </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>80 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p></p>
<p> </p>
<p>Changing parameter “CRC Bytes per Cycle” (for run-time optimization), in an existing </p>
<p>(already flashed) project. Data blocks with CRC32 could not be read after the update. </p>
<p></p>
<p> </p>
<p>CRC32  values  cannot  be  verified  outside  NVM  (e.g.  for  testing  purposes),  without </p>
<p>knowing the configuration – each single step would have to be reproduced. </p>
<p></p>
<p> </p>
<p>Valid  data  blocks  along  with  their  CRC32  cannot  be  pre-defined using  standard CRC </p>
<p>algorithms. </p>
<p>NVM circumvents these restrictions by reverting the final negation of each single CRC32 </p>
<p>calculation step, except the last one. This (quite simple) measure guarantees that the CRC </p>
<p>value does not depend on the number of calculation steps, as it is originally guaranteed for </p>
<p>CRC16 (since it will not be inverted by the CRC library). </p>
<p><b>8.3 </b></p>
<p><b>Limitations </b></p>
<p>There are no limitations. </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>81 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>9 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>9.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>DaVinci Configurator </p>
<p>Pro </p>
<p>Configuration and generation tool for MICROSAR. </p>
<p>DCM </p>
<p>Diagnostic Communication Manager </p>
<p>GCE </p>
<p>Generic Configuration Editor – generic tool for editing AUTOSAR </p>
<p>configuration files. </p>
<p>In DaVinci Configurator, the view can be switch to “Generic Editor”. </p>
<p>PIM </p>
<p>Per Instance Memory </p>
<p>Table 9-1   Glossary </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>82 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p><b>9.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>CRC </p>
<p>Cyclic Redundancy Check </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>EA </p>
<p>EEPROM Abstraction Module </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>ECUM </p>
<p>ECU State Manager </p>
<p>EEP </p>
<p>EEPROM Driver </p>
<p>EEPROM </p>
<p>Electrically Erasable Programmable Read Only Memory </p>
<p>FEE </p>
<p>Flash EEPROM Emulation Module </p>
<p>FIFO </p>
<p>First In First Out </p>
<p>FLS </p>
<p>Flash Driver </p>
<p>GCE </p>
<p>Generic Configuration Editor </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>MemHwA </p>
<p>Memory Hardware Abstraction Layer </p>
<p>MEMIF </p>
<p>Memory Abstraction Interface Module </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR </p>
<p>solution) </p>
<p>NVM </p>
<p>NVRAM Manager </p>
<p>NV, NVRAM </p>
<p>Non Volatile Random Access Memory </p>
<p>OS </p>
<p>Operating System </p>
<p>PPort </p>
<p>Provide Port </p>
<p>RAM </p>
<p>Random Access Memory </p>
<p>ROM </p>
<p>Read Only Memory </p>
<p>RPort </p>
<p>Require Port </p>
<p>RTE </p>
<p>Runtime Environment </p>
<p>SRS </p>
<p>Software Requirement Specification </p>
<p>SWC </p>
<p>Software Component </p>
<p>SWS </p>
<p>Software Specification </p>
<p>Table 9-2   Abbreviations </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>83 / 84</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>©</p>
<p>2011, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 3.01 </p>
<p>84 / 84</p>
<p><b>10 Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector-informatik.com </b></p>
<p> </p>
</body>
</html>
{% endraw %}